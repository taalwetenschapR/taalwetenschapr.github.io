[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Onderzoeksontwerp en Beschrijvende Statistiek",
    "section": "",
    "text": "Welkom\nDit is het dictaat bij de B1-cursus Onderzoeksontwerp en Beschrijvende Statistiek. Dit document geeft een beknopte inleiding in het werken met R en RStudio aan de hand van taalkundige voorbeelden. Aan het eind van elk hoofdstuk vind je onder het kopje Verder leren informatie waar je je kennis verder kunt verdiepen. De practica bij de cursus vind je onder het kopje Practica in de menubalk links."
  },
  {
    "objectID": "index.html#suggesties-voor-verbeteringen",
    "href": "index.html#suggesties-voor-verbeteringen",
    "title": "Onderzoeksontwerp en Beschrijvende Statistiek",
    "section": "Suggesties voor verbeteringen",
    "text": "Suggesties voor verbeteringen\nDit document is in ontwikkeling. Nog niet alle hoofdstukken in het linkermenu zijn op dit moment beschikbaar. Deze zullen gedurende de cursus worden toegevoegd net als de practica. Kom je dingen tegen die niet werken, niet kloppen of die onduidelijk zijn of heb je andere suggesties voor verbeteringen, laat het weten. Dit kan via het forum op Brightspace of direct bij de docent tijdens de practicumuren. Op deze manier zorgen we samen dat dit document een steeds beter leermiddel wordt."
  },
  {
    "objectID": "index.html#verantwoording",
    "href": "index.html#verantwoording",
    "title": "Onderzoeksontwerp en Beschrijvende Statistiek",
    "section": "Verantwoording",
    "text": "Verantwoording\nHet materiaal in dit dictaat is beïnvloed door een groot aantal inspiratiebronnen die ik door de afgelopen jaren heb bestudeerd. Het is niet altijd eenduidig aan te wijzen waar uitleg of voorbeelden op gebaseerd zijn, daarom hieronder een alfabetische lijst van de meest inspirerende bronnen."
  },
  {
    "objectID": "intro.html#hoe-dit-dictaat-te-gebruiken",
    "href": "intro.html#hoe-dit-dictaat-te-gebruiken",
    "title": "1  Inleiding",
    "section": "1.1 Hoe dit dictaat te gebruiken",
    "text": "1.1 Hoe dit dictaat te gebruiken\nWaarschijnlijk is het werken met een programmeertaal nieuw voor je. Dat is helemaal geen probleem. We beginnen vanaf het begin en veronderstellen geen voorkennis op dit gebied. Voor sommigen zal het leren programmeren (of beter gezegd coderen) soepel verlopen, maar misschien ben je wel iemand die er meer moeite mee heeft. Daar hoef je je geen zorgen over te maken. De leercurve kan best steil zijn. Vergelijk het met het leren van een nieuwe taal. Dat kost nu eenmaal wat tijd en kan lastig zijn. Het is belangrijk dat je hierbij actief met de stof aan de gang gaat. Maak voor jezelf een overzicht van het leermateriaal. Laat je niet te snel uit het veld slaan en stel vragen.\nAls je fit wilt worden, dan moet je zelf aan de slag in de sportschool of op het sportveld. Voor coderen geldt hetzelfde. Als je wilt leren coderen, moet je zelf aan de slag. Het alleen doorlezen van dit dictaat is hierbij niet voldoende. Probeer voorbeeldcode te ontcijferen, zodat je snapt wat elk onderdeel doet. Het helpt daarbij om de code zelf uit te voeren in R. Op die manier kun je precies zien wat er gebeurt in elke stap. Alle bestanden die in het dictaat gebruikt worden, kun je downloaden vanaf de Brightspace-pagina van deze cursus. Je kunt alle analyses dus op je eigen computer nadoen. Download hiervoor het bestand OBS_practica.zip van Brightspace en pak dat uit op je eigen computer. Zet deze map op een handige locatie op je computer (bijv. in de map voor de cursus OBS). In het volgende hoofdstuk leer je hoe je aan de slag kunt met de bestanden in deze map.\nDit dictaat biedt slechts een inleiding. Er is veel meer te leren en vertellen over R. Aan het eind van elk hoofdstuk vind je onder het kopje Verder leren informatie waar je meer je meer achtergrondkennis kunt opdoen of je kennis verder kunt verdiepen. Maak daar gebruik van. De leerdoelen aan het begin van ieder hoofdstuk kun je gebruiken om voor jezelf vast te stellen of je de stof uit het hoofdstuk voldoende onder de knie hebt."
  },
  {
    "objectID": "intro.html#generatieve-ai",
    "href": "intro.html#generatieve-ai",
    "title": "1  Inleiding",
    "section": "1.2 Generatieve AI",
    "text": "1.2 Generatieve AI\nGeneratieve AI biedt allerlei mogelijkheden. Het genereren van code is er daar een van. Het probleem is alleen dat je de gegenereerde code alleen kunt begrijpen als je zelf al iets weet over coderen. Dit noemen we ook wel de expert-paradox: je hebt (basis)kennis nodig om generatieve AI goed te kunnen gebruiken. En dan nog: ervaren coders geven aan dat wanneer je nieuwe problemen wilt analyseren generatieve AI je niet zoveel te bieden heeft. Des te meer reden dus om zelf kennis op te doen. Bovendien is het natuurlijk ook veel leuker en interessanter als je aan het eind van je opleiding naar eerlijkheid kunt zeggen dat je daadwerkelijk iets geleerd hebt en daadwerkelijk zelf iets kunt. We maken in deze cursus dus geen gebruik van generatieve AI. Misschien dat je later met de opgedane kennis ervan kunt profiteren, maar op dit moment doen we alles op eigen kracht."
  },
  {
    "objectID": "R.html#sec-RStudio",
    "href": "R.html#sec-RStudio",
    "title": "2  R en RStudio",
    "section": "2.1 Werken met R en RStudio",
    "text": "2.1 Werken met R en RStudio\nHet softwarepakket R is tegenwoordig de standaard voor data-analyse in taalkundig onderzoek. Het grote voordeel van R is dat veel professionele onderzoekers steeds weer nieuwe pakketten maken voor specifieke statistische of data-analytische functies.1 Daarnaast is het gratis te downloaden voor verschillende computerplatforms. Je kunt R downloaden als programma op je computer. Je kunt direct in het programma R werken. Als je het opent, krijg je een scherm te zien, de console, waarin je code kunt typen. Wij gebruiken echter het programma RStudio, dat een wat fijnere gebruikersinterface levert dan R zelf, en dus wat vriendelijker is voor (beginnende) gebruikers.1 Bodo Winter geeft in sectie 0.2 van Winter (2019) nog een aantal belangrijke voordelen.\nWinter, B. (2019). Statistics for Linguists: An Introduction Using R. Routledge. https://doi.org/10.4324/9781315165547\n\nOp de computers in het ESC horen R en RStudio al aanwezig te zijn. Om het op je eigen computer te installeren: ga naar https://posit.co/download/rstudio-desktop/#download en kies het installatieprogramma dat bij jouw computer past. Als je R nog niet hebt, installeer dat dan ook, vanaf die pagina of anders via https://cran.rstudio.com of http://cran.r-project.org.\nWanneer je RStudio opent, opent zich een programma met een aantal vensters (3 of 4), zoals je kunt zien in Figuur 2.1. Linksonder vind je de console van R (wanneer je vanuit het programma R zou werken, krijg je alleen dit venster te zien). Dat is waar alle code die je gaat maken zal worden uitgevoerd. Linksboven zie je een script met daarin 1 regel code. In het script kun je als in een kladblok code schrijven en die vervolgens uitproberen door deze naar de console te sturen. Dit doe je door de relevante code te selecteren en op ctrl + Enter (Cmd + Enter op een Mac) te drukken. Wanneer je je cursor op een regel hebt staan, wordt op deze manier alle code op die regel (en bijbehorende regels) uitgevoerd.\n\n\n\nFiguur 2.1: De vensters van het programma RStudio\n\n\nHet venster rechtsboven geeft een overzicht van alle data (datatabellen en vectoren, zie het volgende hoofdstuk) die voor R beschikbaar zijn om bewerkingen op uit te voeren. Dit venster is nu nog leeg. Hetzelfde geldt voor het venster rechtsonder. Dit venster kun je gebruiken om gemaakte grafieken (plots) te bekijken, inzicht te krijgen in je bestanden en ook de packages die je hebt geïnstalleerd (zie hieronder). Niet onbelangrijk: hier vind je ook de help-functie.\nOmdat het waarschijnlijker makkelijker is om een overzicht te krijgen van RStudio met bewegend beeld kun je deze video https://youtu.be/FIrsOBy5k58 bekijken voor een korte rondleiding."
  },
  {
    "objectID": "R.html#functies",
    "href": "R.html#functies",
    "title": "2  R en RStudio",
    "section": "2.2 Functies",
    "text": "2.2 Functies\nZoals gezegd is R in feite een grote verzameling functies die je kunt inzetten om data te analyseren. Functies koppelen een bepaalde input aan een bepaalde output. Neem bijvoorbeeld de functie seq(): gegeven een beginpunt, een eindpunt en een stapgrootte geeft deze functie je een reeks getallen. In onderstaand voorbeeld is het beginpunt gegeven als 1, het eindpunt als 10 en de stapgrootte als 1. Het resultaat is een reeks gehele getallen van 1 tot 10.\n\nseq(from = 1, to = 10, by = 1)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWanneer we de stapgrootte veranderen naar 2, krijgen we niet 10 getallen maar 5 (alle oneven getallen onder de 10).\n\nseq(from = 1, to = 10, by = 2)\n\n[1] 1 3 5 7 9\n\n\nVeranderen we vervolgens ook het beginpunt naar 2 dan krijgen we 5 even getallen:\n\nseq(from = 2, to = 10, by = 2)\n\n[1]  2  4  6  8 10\n\n\nDeze voorbeelden laten zien dat de uitkomst (output) van de functie dus volledig wordt bepaald door wat je erin stopt (de input). De functie seq() vraag om drie argumenten from, to en by. Ieder argument heeft in principe een vaste plek in de functie. Wanneer we die vaste volgorde aanhouden kunnen we de namen van de argumenten weglaten:\n\nseq(1, 10, 1)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWanneer je bekend raakt met bepaalde functies, zul je er op gegeven moment waarschijnlijk voor kiezen om de namen van de argumenten weg te laten. Dit scheelt namelijk veel typewerk. Het maakt je code mogelijk wel minder leesbaar voor buitenstaanders (en voor jezelf). In dit dictaat zullen we in de meeste gevallen bij het eerste gebruik van een functie de argumenten bij naam noemen, om ze bij vervolgd gebruik weg te laten.\nWanneer we de namen wel gebruiken, kunnen we er ook voor kiezen om de argumenten in een andere volgorde neer te zetten. Door de namen weet R toch wat we bedoelen.\n\nseq(by = 1, from = 1, to = 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nLaten we de namen weg en gebruiken we een andere volgorde, krijgen we een andere output:\n\nseq(1, 1, 10)\n\n[1] 1\n\n\nIn dit geval interpreteert R de argumenten in de standaardvolgorde.\nHet is voor elke functie dus belangrijk om te weten wat de benodigde argumenten zijn en in welke volgorde ze worden verwacht. De argumenten staan altijd tussen () achter de functienaam en worden gescheiden door een komma. Tussen de naam van het argument en de waarde die je wilt meegeven zet je een =-teken.\n\nDe anatomie van een functie\n\n\nfunctienaam(argument1, argument2, argument3)\n\n\n\n\nseq(from = , to = , by = )\n\n\n\nWanneer je wilt achterhalen hoe de structuur van een functie in elkaar zit, kun je de help-functie in R gebruiken. Door een vraagteken voor de functienaam te zetten, verschijnt in RStudio rechtsonder informatie over de functie.\n\n?seq()\n\nJe zult zien dat veel functies naast de verplichte argumenten ook default argumenten hebben. Dit zijn argumenten die een standaardwaarde hebben en dus niet door de gebruiker hoeven te worden gegeven, maar die je eventueel wel zou kunnen aanpassen.\nNiet alle functies hebben argumenten met een naam. De functie c() waarmee we dingen kunnen samenvoegen tot een geheel is bijvoorbeeld een veelgebruikte functie zonder argumentnamen:\n\nc(\"Nederland\", 1988, \"plek 1\")\n\n[1] \"Nederland\" \"1988\"      \"plek 1\"   \n\n\nDeze functie c() kun je ook gebruiken om meerdere waarden als argument van een functie mee te geven. Neem als voorbeeld de functie round(). Deze functie rondt getallen af op een aangegeven aantal decimalen (digits). In onderstaand voorbeeld wordt er afgerond op twee decimalen:\n\nround(4.246, digits = 2)\n\n[1] 4.25\n\n\nMet c() is het mogelijk om meerdere getallen tegelijk te laten afronden (in dit geval op 1 decimaal):\n\nround(c(4.246, 5.628, 9.463), 1)\n\n[1] 4.2 5.6 9.5\n\n\n\n\n\n\n\n\ncodeboek\n\n\n\nIn deze cursus leer je werken met zo’n 100 veelgebruikte functies in R. Het is belangrijk om voor jezelf een goed overzicht te houden van deze functies. Werk hier actief aan door een eigen codeboek aan te maken."
  },
  {
    "objectID": "R.html#sec-packages",
    "href": "R.html#sec-packages",
    "title": "2  R en RStudio",
    "section": "2.3 Packages",
    "text": "2.3 Packages\nR komt standaard met een hele verzameling aan functies die je kunt gebruiken. Dit noemen we ook wel base R. Soms wil je echter meer. In dat geval kun je gebruik maken van zogenaamde aanvullende packages. Een package is een verzameling functies die meestal gemaakt zijn om één bepaalde taak goed uit te kunnen voeren, bijv. het maken van grafieken of het analyseren van teksten. Om deze te kunnen gebruiken moet je deze packages eerst installeren op je computer en vervolgens ook aanroepen in je R-sessie. Tijdens deze cursus zullen we veelvuldig gebruik maken van het package tidyverse. Dat is eigenlijk een verzameling packages die helpen bij verschillende onderdelen van data-analyse. Het tidyverse is inmiddels zo succesvol geworden dat het een soort dialect binnen de programmeertaal R is geworden. Wanneer je het package tidyverse installeert en aanroept dan roep je meteen alle packages die daaronder vallen ook aan.\nPackages installeer je met behulp van de functie install.packages(). Tussen de haken zet je de naam van het package tussen aanhalingstekens.\n\ninstall.packages(\"tidyverse\") \n\nN.B. je hoeft een package maar één keer op je computer te installeren. Zet daarom, nadat je de installatie hebt voltooid, een # voor de regel met install.packages() of verwijder de regel met deze code. Als je de regel laat staan kan dat later problemen opleveren. Door de # zal R de regel negeren wanneer je het script nog een keer uitvoert. In RStudio kun je in het window rechtsonder onder het tabblad packages zien welke packages er geïnstalleerd zijn op jouw computer. Je vindt daar ook een optie om packages te installeren.\nEen package installeer je dus maar één keer, maar om de functies in het package te kunnen gebruiken moet je het package wel elke R-sessie opnieuw activeren. Dit doe je met behulp van de functie library() waarin je de naam van het te gebruiken package invult zonder aanhalingstekens. Dit moet je dus elke keer uitvoeren aan het begin van een nieuwe R-sessie, anders zal R klagen de functies uit het package niet te kennen. Om de functies uit het tidyverse te kunnen gebruiken, type je dus:\n\nlibrary(tidyverse)\n\nJe kunt deze functie voor meerdere packages achter elkaar uitvoeren. Let hierbij wel op dat de volgorde waarin je de packages aanroept een effect kan hebben. Wanneer er in verschillende packages een functie met dezelfde naam zit, dan zal de R de functie gebruiken zoals die in het laatst aangeroepen package gedefinieerd is. De functie in het eerder aangeroepen package zal dan gemaskeerd worden. R geeft je hier ook een waarschuwing over. Wanneer je uit een geïnstalleerd package maar één specifieke functie wilt gebruiken, dan kun je dit probleem omzeilen door het package niet aan te roepen met library(), maar door de notatie packagenaam::functienaam te gebruiken:\n\njanitor::clean_names()\n\nIn het bovenstaande voorbeeld kun je de functie clean_names uit het package janitor gebruiken zonder dat alle andere functies uit het package actief worden en mogelijk functies uit andere packages maskeren. Je moet het package hiervoor natuurlijk wel geïnstalleerd hebben op je computer.\nHet is verstandig om aan het begin van elk R-script een blokje te maken waarin je alle benodigde packages aanroept met library(). Dit is vooral ook handig voor lezers van je script. Die weten dan meteen wat ze kunnen verwachten en welke packages ze eventueel nog moeten installeren."
  },
  {
    "objectID": "R.html#verder-leren",
    "href": "R.html#verder-leren",
    "title": "2  R en RStudio",
    "section": "Verder leren",
    "text": "Verder leren\n\nIn Hoofdstuk 1 van SfL (Winter, 2019) wordt de basis van R (base R) verder uitgelegd. Ter voorbereiding op het eerste practicum is het prettig om vast wat commando’s te proberen uit dit hoofdstuk. Maak hiervoor een nieuw script aan in RStudio (via het menu File &gt; New File &gt; R Script of de sneltoetsen Ctrl + Shift + N (Cmd + Shift + N op een Mac)).2 Werk om een gevoel te krijgen bij hoe R werkt, nu hoofdstuk 1 door t/m sectie 1.4. Typ de commando’s in de grijze vakken over en voer ze uit. In sectie 1.2 doe je dit direct in de R-console, vanaf sectie 1.3 (en in alle volgende practica!) in een script. Zie sectie 1.15 voor handige shortcuts die je hierbij kunt gebruiken. Controleer steeds of je dezelfde output krijgt als in het boek. Toegegeven, het letterlijk overtypen van de commando’s uit het boek voelt misschien een beetje raar, maar het is dé manier om gevoel te krijgen bij hoe R werkt en waar je op moet letten (zie ook sectie 1.16 voor belangrijke adviezen op dit gebied). In de practica krijg je nog tijd genoeg om het allemaal zelf uit te vinden.\n\n\n\n2 Je kunt eventueel ook https://rdrr.io/snippets gebruiken voor het uitvoeren van R-code, mocht de installatie op je eigen computer niet werken. We kunnen dan tijdens een practicum proberen R en RStudio werkend te krijgen op je computer."
  },
  {
    "objectID": "data.html#sec-datatabellen",
    "href": "data.html#sec-datatabellen",
    "title": "3  Data in R",
    "section": "3.1 Datatabellen en vectoren",
    "text": "3.1 Datatabellen en vectoren\nWe kunnen data in R in verschillende formaten tegenkomen. Tijdens deze cursus krijgen we vooral te maken met datatabellen en vectoren. Een datatabel wordt in tidyverse een tibble genoemd en gaat in R ook wel door het leven onder de naam data.frame.1 Een datatabel bestaat uit rijen (de observaties) en kolommen (de variabelen) en doet daarmee erg denken aan een gewone tabel of spreadsheet zoals je dat misschien wel kent uit bijvoorbeeld Excel.1 Het tidyverse is voor een groot deel ontwikkeld door de Nieuw-Zeelander Hadley Wickham. Het woord tibble schijnt te verwijzen naar de manier waarop in Nieuw-Zeeland table wordt uitgesproken.\nHieronder vind je een voorbeeld van een tibble met data uit het package wordbankr. Dit package geeft toegang tot Wordbank een grote database met daarin informatie over hoe de woordenschat van kinderen zich ontwikkelt in verschillende talen.22 Voor een uitgebreide beschrijving van deze data, zie de website van het Wordbank Project: https://wordbank.stanford.edu/\nDe data in deze database zijn verzameld aan de hand van de MacArthur-Bates Communicative Development Inventory (MB-CDI), een vragenlijst waarin ouders aangeven welke woorden hun kind op welke leeftijd kent. Informatie over alle beschikbare versies van deze vragenlijst in verschillende talen hebben we opgeslagen in de tibble met de naam wordbank_datasets.\n\n\n\n\nwordbank_datasets\n\n# A tibble: 89 × 8\n   instrument_id language            form  form_type age_min age_max has_grammar\n           &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1             1 British Sign Langu… WG    WG              8      36           0\n 2             2 Cantonese           WS    WS             16      30           0\n 3             3 Croatian            WG    WG              8      16           0\n 4             4 Croatian            WS    WS             16      30           0\n 5             5 Danish              WG    WG              8      20           0\n 6             6 Danish              WS    WS             16      36           1\n 7             7 English (American)  WG    WG              8      18           0\n 8             8 English (American)  WS    WS             16      30           1\n 9             9 French (Quebecois)  WG    WG              8      16           0\n10            10 French (Quebecois)  WS    WS             16      30           1\n# ℹ 79 more rows\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\nJe kunt de inhoud van een datatabel bekijken door de naam van de tabel uit te voeren. Bij een tibble krijg je standaard de eerste tien rijen te zien. Het aantal kolommen (variabelen) dat je te zien krijgt is afhankelijk van de grootte van je scherm. Bovenaan de tibble kun je zien om hoeveel rijen en kolommen het gaat (hier 89 x 8). Onderaan wordt je verteld hoeveel rijen en welke variabelen er niet getoond zijn (hier bijvoorbeeld 79 rijen). Je kunt het aantal rijen en variabelen ook zichtbaar maken met de functies nrow() en ncol() respectievelijk.\n\nnrow(wordbank_datasets)\n\n[1] 89\n\nncol(wordbank_datasets)\n\n[1] 8\n\n\nWil je de gehele datatabel zien (afgeraden bij heel grote bestanden) dan kun je de functie View() gebruiken. Er zal dan een tabblad geopend worden in RStudio waarin je de datatabel kunt bekijken.\n\nView(wordbank_datasets)\n\nDe weergave van de tibble in R vertelt je ook iets over de manier waarop R de variabelen uit de tibble ziet. Onder de namen van de variabelen (de bovenste regel) vind je namelijk tussen vishaken &lt;&gt; het type dat R heeft toegekend op basis van de datapunten in de variabele. Zo heeft de variabele language het type chr voor character (tekst) toegewezen gekregen en de variabele age_min het type int voor integer (geheel getal). Tabel 3.1 geeft een overzicht van een aantal veel voorkomende datatypes van variabelen in R.\n\n\n\n\n\n\n\n\n\n\n\n\nsoort\nnaam in R\nafkorting in R\nvoorbeeld\nmeetniveau\n\n\n\n\ntekst, string\ncharacter\nchar, chr\n“a”, “woord”\nnominaal\n\n\nboolean, waarheidswaarde\nlogical\nlogi, lgl\nTRUE, FALSE\nnominaal\n\n\nfactor\nfactor\nfct\nDuits, Engels\nnominaal\n\n\ngeordende factor\nordered factor\nord\nlaag, hoog\nordinaal\n\n\ngetal\nnumeric, double\nnum, dbl\n1, 2.5, 3.14\nnumeriek\n\n\ngeheel getal\ninteger\nint\n1, 2, 100\nnumeriek\n\n\n\nTabel 3.1: een aantal veel voorkomende datatypes in R\nNaast de datatabel zijn vectoren een veel voorkomende dataformaat in R. Een vector is een geordend rijtje van elementen van hetzelfde type. Een variabele uit een datatabel kunnen we bijvoorbeeld omzetten naar een vector met de functie pull().\n\nlanguages &lt;- pull(wordbank_datasets, language)\n\nBovenstaande code wijst door het gebruik van de operator &lt;- de inhoud van de variabele language toe aan een vector met de naam languages. Je kunt hier zelf vrijwel elke naam kiezen. Het is verstandig om namen te kiezen die betekenisvol zijn voor jezelf (ook nog als je je code een tijd later weer leest) of voor iemand anders die je code bekijkt. Namen als dataset1, datasetdef en datasetechtdefinitief zijn dus niet zo handig. Daarnaast is het voor de leesbaarheid fijn om consistent te zijn: gebruik alleen kleine letters (snake case) en scheid inhoudswoorden met een underscore _, dus bijv. wordbank_datasets.\nHet resultaat van het uitvoeren van pull() is een vector met de naam languages met daarin de 89 namen van talen. Deze vector zal in RStudio in het venster rechtsboven onder het tabblad Environment verschijnen onder het kopje Values. In de Environment vind je een overzicht van alle datatabellen en vectoren die voor R toegankelijk zijn. Je kunt de namen van deze databronnen gebruiken in de code die je schrijft. Zo kunnen we de naam languages nu gebruiken als argument van functies. Laten we eerst kijken wat er in de vector zit. Hiervoor typen we alleen de naam van de vector:\n\nlanguages\n\n [1] \"British Sign Language\"  \"Cantonese\"              \"Croatian\"              \n [4] \"Croatian\"               \"Danish\"                 \"Danish\"                \n [7] \"English (American)\"     \"English (American)\"     \"French (Quebecois)\"    \n[10] \"French (Quebecois)\"     \"German\"                 \"Hebrew\"                \n[13] \"Hebrew\"                 \"Italian\"                \"Italian\"               \n[16] \"Mandarin (Beijing)\"     \"Mandarin (Beijing)\"     \"Mandarin (Beijing)\"    \n[19] \"Norwegian\"              \"Norwegian\"              \"Russian\"               \n[22] \"Russian\"                \"Slovak\"                 \"Slovak\"                \n[25] \"Spanish (Mexican)\"      \"Spanish (Mexican)\"      \"Swedish\"               \n[28] \"Swedish\"                \"Turkish\"                \"Turkish\"               \n[31] \"English (British)\"      \"English (British)\"      \"American Sign Language\"\n[34] \"American Sign Language\" \"American Sign Language\" \"American Sign Language\"\n[37] \"Greek (Cypriot)\"        \"Kigiriama\"              \"Kigiriama\"             \n[40] \"Kiswahili\"              \"Kiswahili\"              \"Czech\"                 \n[43] \"English (Australian)\"   \"English (British)\"      \"Latvian\"               \n[46] \"Latvian\"                \"Korean\"                 \"Korean\"                \n[49] \"French (French)\"        \"French (French)\"        \"Spanish (European)\"    \n[52] \"Spanish (European)\"     \"Portuguese (European)\"  \"Portuguese (European)\" \n[55] \"Mandarin (Taiwanese)\"   \"Mandarin (Taiwanese)\"   \"English (Irish)\"       \n[58] \"Irish\"                  \"Finnish\"                \"Dutch\"                 \n[61] \"Dutch\"                  \"Dutch\"                  \"Dutch\"                 \n[64] \"Dutch\"                  \"Dutch\"                  \"Dutch\"                 \n[67] \"Hungarian\"              \"Spanish (Argentinian)\"  \"American Sign Language\"\n[70] \"Spanish (Chilean)\"      \"Spanish (Peruvian)\"     \"Spanish (Peruvian)\"    \n[73] \"Persian\"                \"Persian\"                \"Finnish\"               \n[76] \"English (American)\"     \"English (American)\"     \"English (British)\"     \n[79] \"Arabic (Saudi)\"         \"Arabic (Saudi)\"         \"Arabic (Saudi)\"        \n[82] \"Estonian\"               \"Catalan\"                \"Korean\"                \n[85] \"Finnish\"                \"Finnish\"                \"Catalan\"               \n[88] \"Japanese\"               \"Japanese\"              \n\n\nHet gaat hier om een opsomming van alle talen die voorkomen in de dataset wordbank_datasets. Het aantal elementen in de vector kunnen we vaststellen met de functie length() en het datatype van de vector met de functie class()\n\nlength(languages)\n\n[1] 89\n\nclass(languages)\n\n[1] \"character\"\n\n\nHet gaat hier dus om een character vector die bestaat uit 89 elementen. Het type (de class) van de vector wordt toegepast op alle elementen in de vector ook als er oorspronkelijk elementen in zijn gestopt van een verschillend type (bijv. woorden en getallen). Dit zien we bijvoorbeeld als we aan R vragen wat het type is van onze eerder met de functie c() gemaakte vector.\n\nek_1988 &lt;- c(\"Nederland\", 1988, \"plek 1\")\nclass(ek_1988)\n\n[1] \"character\"\n\n\nOndanks dat we een getal hebben toegevoegd aan onze vector is het type van de vector als geheel toch character. Wanneer we de vector laten zien, dan valt ook op dat er rond het oorspronkelijk getal 1988 nu aanhalingstekens staan. Het wordt door R dus gezien als een woord.\n\nek_1988\n\n[1] \"Nederland\" \"1988\"      \"plek 1\""
  },
  {
    "objectID": "data.html#sec-data-inlezen",
    "href": "data.html#sec-data-inlezen",
    "title": "3  Data in R",
    "section": "3.2 Data inlezen",
    "text": "3.2 Data inlezen\nData om te analyseren zijn vaak opgeslagen in databestanden. Deze bestanden kunnen een verschillend formaat (extensie) hebben. Veel voorkomende formaten (in deze cursus) zijn tekstbestanden (.txt) en csv-bestanden (.csv). CSV staat voor ‘comma separated values’ en geeft aan dat de waarden van variabelen (‘de cellen’ in een spreadsheet) van elkaar gescheiden zijn door scheidingstekens. Zoals de naam doet vermoeden is de komma hier het te verwachten scheidingsteken, maar verwarrend genoeg kan dit ook een puntkomma zijn (zie Figuur 3.1). Welk scheidingsteken wordt gebruikt hangt onder anderen af van de instellingen van je computer. Het is dus van belang om goed te bekijken met wat voor een bestand je te maken hebt voor je het gaat inlezen en ook na het inlezen goed te controleren of dit goed is gegaan.\n\n\n\nFiguur 3.1: CSV-bestand met puntkomma als scheidingsteken\n\n\nExterne databestanden zul je eerst moeten inlezen in R voor je ermee kunt gaan werken. Hiervoor bestaan gelukkig verschillende functies in R, gespecificeerd voor het soort bestand waarmee je werkt. Die functies beginnen doorgaans met read. Binnen het tidyverse gebruiken we read-functies gevolgd door een underscore (read_). Deze functies lezen een specifiek soort databestand in als een tibble. Zo is er voor csv-bestanden een functie read_csv voor bestanden met een komma als scheidingsteken en een read_csv2 voor bestanden met een puntkomma als scheidingsteken. De functie read_delim() (voor read in delimited data file) is de algemene functie om databestanden in te lezen, waaronder tekstbestanden, en read_csv() en read_csv2() zijn specifieke versies hiervan waarbij het type delimiter (het scheidingsteken) is vastgelegd (dus read_csv() is onderliggend read_delim(file = , delim = \",\")). Type maar eens ‘read_’ in je R-script en RStudio zal automatisch alle opties geven zowel binnen baseR als binnen het tidyverse (zie Figuur 3.2). Aan jou de taak om de juiste functie te vinden bij je databestand. Wanneer je werkt in een R-project zal de read_()-functie gaan zoeken in de map van het R-project (zie box Waar staat je databestand? verderop).\nSoms is het handig om een in R-gecreëerde dataset op te slaan naar een databestand, zodat je het later of in een ander programma kunt gebruiken. Het opslaan van databestanden in R is eenvoudig. Er bestaat voor elke read_-functie namelijk een tegenhanger die begint met write_, bijv. write_csv. Wanneer je werkt in een R-project, hoef je de locatie wederom niet te specificeren. RStudio slaat het bestand automatisch op in de map van je project.\n\n\n\nFiguur 3.2: automatische aanvulopties in RStudio\n\n\nHet is belangrijk om altijd goed te controleren of het inlezen van je databestand is gelukt. Heb je inderdaad het aantal observaties en kolommen (variabelen) dat je verwacht. Zo niet, dan is er iets misgegaan. In onderstaand voorbeeld lezen we bijvoorbeeld het databestand wordbank_datasets.csv in met de functie read_csv2(), terwijl de datapunten niet gescheiden zijn door een puntkomma, maar door een komma (en dus read_csv() nodig is). Het resultaat laat zien dat we in plaats van 8 variabelen (en dus 8 kolommen), maar 1 variabele (1 kolom) hebben waarin alle informatie is samengepropt.\n\nwordbank_datasets &lt;- read_csv2(file = \"_datasets/wordbank_datasets.csv\")\n\nℹ Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n\n\nRows: 89 Columns: 1\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \";\"\nchr (1): instrument_id,language,form,form_type,age_min,age_max,has_grammar,u...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nwordbank_datasets\n\n# A tibble: 89 × 1\n   instrument_id,language,form,form_type,age_min,age_max,has_grammar,unilemma_…¹\n   &lt;chr&gt;                                                                        \n 1 1,British Sign Language,WG,WG,8,36,0,0.95                                    \n 2 2,Cantonese,WS,WS,16,30,0,0.95                                               \n 3 3,Croatian,WG,WG,8,16,0,1                                                    \n 4 4,Croatian,WS,WS,16,30,0,1                                                   \n 5 5,Danish,WG,WG,8,20,0,1                                                      \n 6 6,Danish,WS,WS,16,36,1,0.93                                                  \n 7 7,English (American),WG,WG,8,18,0,1                                          \n 8 8,English (American),WS,WS,16,30,1,1                                         \n 9 9,French (Quebecois),WG,WG,8,16,0,1                                          \n10 10,French (Quebecois),WS,WS,16,30,1,0.99                                     \n# ℹ 79 more rows\n# ℹ abbreviated name:\n#   ¹​`instrument_id,language,form,form_type,age_min,age_max,has_grammar,unilemma_coverage`\n\n\nDit moeten we herstellen voordat we verdergaan met de data-analyse. Bezuinig niet op de controle van deze stap. Je loopt anders geheid vast.\n\nwordbank_datasets &lt;- read_csv(file = \"_datasets/wordbank_datasets.csv\")\n\nRows: 89 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): language, form, form_type\ndbl (5): instrument_id, age_min, age_max, has_grammar, unilemma_coverage\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nwordbank_datasets\n\n# A tibble: 89 × 8\n   instrument_id language            form  form_type age_min age_max has_grammar\n           &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1             1 British Sign Langu… WG    WG              8      36           0\n 2             2 Cantonese           WS    WS             16      30           0\n 3             3 Croatian            WG    WG              8      16           0\n 4             4 Croatian            WS    WS             16      30           0\n 5             5 Danish              WG    WG              8      20           0\n 6             6 Danish              WS    WS             16      36           1\n 7             7 English (American)  WG    WG              8      18           0\n 8             8 English (American)  WS    WS             16      30           1\n 9             9 French (Quebecois)  WG    WG              8      16           0\n10            10 French (Quebecois)  WS    WS             16      30           1\n# ℹ 79 more rows\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWaar staat je databestand?\n\n\n\nOm databestanden te kunnen inlezen in R, moet je normaal gesproken eerst de computer vertellen waar deze te vinden zijn. Wanneer de databestanden onderdeel zijn van een R-project, weet RStudio al waar het die bestanden moet vinden. RStudio kijkt namelijk automatisch in de map van je project. Dat is een groot voordeel van werken met een R-project. Je kunt dan werken met een relatief pad. In bovenstaand voorbeeld staan de databestanden binnen de map van het R-project in een map _datasets en door dit voor de naam van het bestand te plakken _datasets/wordbank_datasets.csv gaat R in de map van het R-project zoeken naar bestanden in de map _datasets. Wanneer je problemen ondervindt met relatieve paden kun je ook kiezen voor een absoluut pad. Hierbij geeft je de hele naam van de locatie op je computer, bijv. C://Peter/OBS/_datasets/wordbank_datasets.csv.\n\n\n\n\n\n\n3.2.1 Variabelennamen aanpassen\nWanneer je het databestand goed hebt ingelezen is het eerste wat je moet doen de namen van de variabelen controleren. Zoals eerder gemeld, hanteren we voor variabelennamen snake_case: alleen kleine letters en scheiding van inhoudswoorden met een underscore _, dus bijv. wordbank_datasets. Dit is echter niet de enige manier waarop variabelennamen voorkomen. In de praktijk kun je echt vanalles verwachten. Zie bijvoorbeeld hieronder, waar we de namen van twee variabelen uit onze datatabel wordbank_datasets ter illustratie hebben aangepast. We gebruiken hier de functie head() om alleen een deel van de rijen zichtbaar te maken (hier maar 1):\n\nhead(wordbank_datasets_slechte_namen, n = 1) \n\n# A tibble: 1 × 8\n  InstrumentID language            form  `form type` age_min age_max has_grammar\n         &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt; &lt;chr&gt;         &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1            1 British Sign Langu… WG    WG                8      36           0\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\nWe kunnen ook de functie names() gebruiken:\n\nnames(wordbank_datasets_slechte_namen)\n\n[1] \"InstrumentID\"      \"language\"          \"form\"             \n[4] \"form type\"         \"age_min\"           \"age_max\"          \n[7] \"has_grammar\"       \"unilemma_coverage\"\n\n\nWe zien twee variabelen die een afwijkende naam hebben. InstrumentID gebruikt hoofdletters en geen _ om inhoudswoorden (instrument en id) te scheiden en form type heeft een spatie i.p.v. een underscore. Dat laatste is zeker iets om te vermijden, want dat kan allerlei ongemak opleveren. We kunnen deze namen handmatig aanpassen met de functie rename():\n\nrename(.data = wordbank_datasets_slechte_namen,\n       instrument_id = InstrumentID,\n       form_type = `form type`)\n\n# A tibble: 89 × 8\n   instrument_id language            form  form_type age_min age_max has_grammar\n           &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1             1 British Sign Langu… WG    WG              8      36           0\n 2             2 Cantonese           WS    WS             16      30           0\n 3             3 Croatian            WG    WG              8      16           0\n 4             4 Croatian            WS    WS             16      30           0\n 5             5 Danish              WG    WG              8      20           0\n 6             6 Danish              WS    WS             16      36           1\n 7             7 English (American)  WG    WG              8      18           0\n 8             8 English (American)  WS    WS             16      30           1\n 9             9 French (Quebecois)  WG    WG              8      16           0\n10            10 French (Quebecois)  WS    WS             16      30           1\n# ℹ 79 more rows\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\nBij rename() geven we als eerste argument .data de naam van de datatabel mee waarin we namen willen veranderen en vervolgens, gescheiden door komma’s de namen van de variabelen die we willen hernoemen. Hierbij geef je (verwarrend genoeg) eerst de nieuwe naam van de variabele en dan de oude naam. Variabelennamen met een spatie erin moet je tussen backticks ` ` zetten.\nWe zijn er nu nog niet. Met bovenstaande code hebben we de namen nog niet blijvend veranderd. Ze zijn alleen veranderd in de print out die je te zien krijgt in R. Dit kunnen we zien als we de datatabel nogmaals naar het scherm printen:\n\nwordbank_datasets_slechte_namen\n\n# A tibble: 89 × 8\n   InstrumentID language           form  `form type` age_min age_max has_grammar\n          &lt;dbl&gt; &lt;chr&gt;              &lt;chr&gt; &lt;chr&gt;         &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1            1 British Sign Lang… WG    WG                8      36           0\n 2            2 Cantonese          WS    WS               16      30           0\n 3            3 Croatian           WG    WG                8      16           0\n 4            4 Croatian           WS    WS               16      30           0\n 5            5 Danish             WG    WG                8      20           0\n 6            6 Danish             WS    WS               16      36           1\n 7            7 English (American) WG    WG                8      18           0\n 8            8 English (American) WS    WS               16      30           1\n 9            9 French (Quebecois) WG    WG                8      16           0\n10           10 French (Quebecois) WS    WS               16      30           1\n# ℹ 79 more rows\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\nHier zien we nog steeds de oude namen. Om de namen blijvend te veranderen moeten we de verandering toewijzen aan de datatabel zelf met de operator &lt;- die we eerder hebben gezien:\n\nwordbank_datasets_slechte_namen &lt;- rename(.data = wordbank_datasets_slechte_namen,\n       instrument_id = InstrumentID,\n       form_type = `form type`)\n\nnames(wordbank_datasets_slechte_namen)\n\n[1] \"instrument_id\"     \"language\"          \"form\"             \n[4] \"form_type\"         \"age_min\"           \"age_max\"          \n[7] \"has_grammar\"       \"unilemma_coverage\"\n\n\nDe functie rename() is goed te gebruiken als je maar een beperkt aantal namen moet aanpassen. Wanneer er echter veel (meer dan 3) namen moeten worden aangepast is het een beetje omslachtig. In dat geval kun je beter de functie clean_names() uit het package janitor gebruiken. Je kunt hiervoor het package als geheel laden of de functie aanroepen met janitor::clean_names(). Ook hier geldt dat je de output van deze functie weer moet toewijzen aan een datatabel om de verandering blijvend door te voeren. In onderstaand voorbeeld hebben we gekozen om de oorspronkelijk naam voor de datatabel (wordbank_datasets) weer te gebruiken, aangezien de slechte namen zijn aangepast.\n\nwordbank_datasets &lt;- janitor::clean_names(wordbank_datasets_slechte_namen)\n\nnames(wordbank_datasets)\n\n[1] \"instrument_id\"     \"language\"          \"form\"             \n[4] \"form_type\"         \"age_min\"           \"age_max\"          \n[7] \"has_grammar\"       \"unilemma_coverage\"\n\n\n\n\n3.2.2 Type van variabelen aanpassen\nNu de variabelen allemaal een eigen kolom en een goede naam hebben, moeten we nog controleren of ze ook van het juiste type zijn. Bij het inlezen van de data doet R een educated guess naar het type van de variabelen op basis van de data die in de variabelen zitten. Zitten er getallen in dan zal het gaan voor dbl (of num, int) en wanneer er alleen tekst in zit dan voor char. In de meeste gevallen gaat dit goed, maar niet altijd.\nEr is één ding om goed op te letten en dat is het feit dat we in statistische analyse categorische variabelen doorgaans factoren noemen. Factoren zijn categorische variabelen die een beperkt aantal terugkerende waarden kunnen aannemen. Die waarden noemen we levels. In R krijgen factoren het datatype factor.\nNeem als voorbeeld de variabele language uit onze datatabel wordbank_datasets, die we eerder ook als vector languages hebben opgeslagen. In deze variabelen staan de talen van alle vragenlijsten die in de wordbank zitten opgesomd. We zien dat sommige talen meerdere keren voorkomen. Bij de eerste 10 observaties komen 4 talen 2 keer voor (Croatian, Danish, English (American) en French (Quebecois)):\n\nwordbank_datasets\n\n# A tibble: 89 × 8\n   instrument_id language            form  form_type age_min age_max has_grammar\n           &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1             1 British Sign Langu… WG    WG              8      36           0\n 2             2 Cantonese           WS    WS             16      30           0\n 3             3 Croatian            WG    WG              8      16           0\n 4             4 Croatian            WS    WS             16      30           0\n 5             5 Danish              WG    WG              8      20           0\n 6             6 Danish              WS    WS             16      36           1\n 7             7 English (American)  WG    WG              8      18           0\n 8             8 English (American)  WS    WS             16      30           1\n 9             9 French (Quebecois)  WG    WG              8      16           0\n10            10 French (Quebecois)  WS    WS             16      30           1\n# ℹ 79 more rows\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\nMet de functie dinstinct() voor datatabellen of unique voor vectoren kunnen we laten zien dat er in de 89 observaties in de data 42 verschillende talen voorkomen:\n\ndistinct(.data = wordbank_datasets, language)\n\n# A tibble: 42 × 1\n   language             \n   &lt;chr&gt;                \n 1 British Sign Language\n 2 Cantonese            \n 3 Croatian             \n 4 Danish               \n 5 English (American)   \n 6 French (Quebecois)   \n 7 German               \n 8 Hebrew               \n 9 Italian              \n10 Mandarin (Beijing)   \n# ℹ 32 more rows\n\nunique(languages)\n\n [1] \"British Sign Language\"  \"Cantonese\"              \"Croatian\"              \n [4] \"Danish\"                 \"English (American)\"     \"French (Quebecois)\"    \n [7] \"German\"                 \"Hebrew\"                 \"Italian\"               \n[10] \"Mandarin (Beijing)\"     \"Norwegian\"              \"Russian\"               \n[13] \"Slovak\"                 \"Spanish (Mexican)\"      \"Swedish\"               \n[16] \"Turkish\"                \"English (British)\"      \"American Sign Language\"\n[19] \"Greek (Cypriot)\"        \"Kigiriama\"              \"Kiswahili\"             \n[22] \"Czech\"                  \"English (Australian)\"   \"Latvian\"               \n[25] \"Korean\"                 \"French (French)\"        \"Spanish (European)\"    \n[28] \"Portuguese (European)\"  \"Mandarin (Taiwanese)\"   \"English (Irish)\"       \n[31] \"Irish\"                  \"Finnish\"                \"Dutch\"                 \n[34] \"Hungarian\"              \"Spanish (Argentinian)\"  \"Spanish (Chilean)\"     \n[37] \"Spanish (Peruvian)\"     \"Persian\"                \"Arabic (Saudi)\"        \n[40] \"Estonian\"               \"Catalan\"                \"Japanese\"              \n\n\nWanneer de variable language als type character wordt gezien dan missen we de overeenkomsten tussen deze terugkerende talen. Door er een factor van te maken waarin elke taal een level is maken we dit juist zichtbaar. Dit biedt later allerlei voordelen bij het maken van grafieken, zoals het makkelijker kunnen herordenen van levels, en het doen van statistische analyses. Het is dus verstandig om categorische variabelen om te zetten naar type factor.\nJe kunt een variabele omzetten naar een factor met de functie as.factor().3 Deze zal de levels ordenen op alfabet. Om deze aanpassing te kunnen doen gebruiken we de veelgebruikte functie mutate() waarbij we weer de naam van de variabele eerst noemen en na de = wat we erin willen stoppen. Ook hier geldt weer: om de verandering blijvend te maken moeten we deze toewijzen aan de datatabel met &lt;-.3 Er bestaat ook een tidyverse-variant as_factor(). Deze functie zet variabelen ook om naar een factor, maar gebruikt de eerste observatie in de data als het eerste level.\n\nwordbank_datasets &lt;-\n  mutate(.data = wordbank_datasets,\n         language = as.factor(language))\n\nOm een snelle blik te werpen op hoe R de variabelen in onze datatabel ziet, kunnen we de functie str() voor structure gebruiken (het tidyverse-alternatief is glimpse()).44 De functie str() gebruikt types uit base R (dus bijv. num), terwijl glimpse() types uit het tidyverse gebruikt (dus &lt;dbl&gt;).\n\nstr(wordbank_datasets)\n\ntibble [89 × 8] (S3: tbl_df/tbl/data.frame)\n $ instrument_id    : num [1:89] 1 2 3 4 5 6 7 8 9 10 ...\n $ language         : Factor w/ 42 levels \"American Sign Language\",..: 3 4 6 6 8 8 10 10 17 17 ...\n $ form             : chr [1:89] \"WG\" \"WS\" \"WG\" \"WS\" ...\n $ form_type        : chr [1:89] \"WG\" \"WS\" \"WG\" \"WS\" ...\n $ age_min          : num [1:89] 8 16 8 16 8 16 8 16 8 16 ...\n $ age_max          : num [1:89] 36 30 16 30 20 36 18 30 16 30 ...\n $ has_grammar      : num [1:89] 0 0 0 0 0 1 0 1 0 1 ...\n $ unilemma_coverage: num [1:89] 0.95 0.95 1 1 1 0.93 1 1 1 0.99 ...\n\n\nWe zien dat language nu een factor is met 42 levels (zoveel talen als we hadden geteld) en het eerste level is American Sign Language, de naam die als eerste in het alfabet komt. Deze omzetting naar een factor zouden we ook moeten uitvoeren voor de andere variabelen van type character (form en form_type). Ook de variabele instrument_id komt hiervoor in aanmerking, want de getallen die hier zijn gebruikt als id voor de vragenlijst moeten we niet zien als getallen, maar als namen. Deze omzettingen kunnen we in een keer doen binnen de functie mutate() door de variabelen te scheiden met een komma. Voor de overzichtelijkheid van de code zetten we iedere omzetting op een eigen regel.\n\nwordbank_datasets &lt;-\n  mutate(.data = wordbank_datasets,\n         form = as.factor(form),\n         form_type = as.factor(form_type),\n         instrument_id = as.factor(instrument_id)\n         )\n\nstr(wordbank_datasets)\n\ntibble [89 × 8] (S3: tbl_df/tbl/data.frame)\n $ instrument_id    : Factor w/ 89 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10 ...\n $ language         : Factor w/ 42 levels \"American Sign Language\",..: 3 4 6 6 8 8 10 10 17 17 ...\n $ form             : Factor w/ 24 levels \"CDITwo\",\"FormA\",..: 17 22 17 22 17 22 17 22 17 22 ...\n $ form_type        : Factor w/ 2 levels \"WG\",\"WS\": 1 2 1 2 1 2 1 2 1 2 ...\n $ age_min          : num [1:89] 8 16 8 16 8 16 8 16 8 16 ...\n $ age_max          : num [1:89] 36 30 16 30 20 36 18 30 16 30 ...\n $ has_grammar      : num [1:89] 0 0 0 0 0 1 0 1 0 1 ...\n $ unilemma_coverage: num [1:89] 0.95 0.95 1 1 1 0.93 1 1 1 0.99 ...\n\n\nLet dus goed op: getallen zijn niet altijd getallen, maar kunnen ook als namen voor levels van een categorische variabele zijn gebruikt. Stel we maken een datatabel woordfrequenties aan met daarin de variabele frequentie van een aantal woorden. De woordfrequentie is door de onderzoeker gecodeerd als 1, 2 en 3 wat staat voor respectievelijk ‘laag frequent’, ‘midden frequent’ en ‘hoog frequent’.\n\nwoordfrequenties &lt;- tibble(frequentie = c(1,3,1,1,2))\n\nwoordfrequenties\n\n# A tibble: 5 × 1\n  frequentie\n       &lt;dbl&gt;\n1          1\n2          3\n3          1\n4          1\n5          2\n\n\nOmdat de waarden van de variabele frequentie getallen zijn, denkt R dat we hier te maken hebben met een numerieke variabele. We kunnen dit weer omzetten met de functie as.factor(), vervolgens kunnen we met de functie recode() de levels van deze factor expliciete namen geven. Wanneer we de datatabel nu weer bekijken dan zien we in plaats van getallen de namen van de levels. Dat maakt het inzichtelijker voor gebruikers van de data.\n\nwoordfrequenties &lt;- mutate(woordfrequenties,\n                           frequentie = as.factor(frequentie),\n                           frequentie = fct_recode(frequentie, \n                                                   laag = \"1\", \n                                                   midden = \"2\", \n                                                   hoog = \"3\")\n                           )\n\nwoordfrequenties\n\n# A tibble: 5 × 1\n  frequentie\n  &lt;fct&gt;     \n1 laag      \n2 hoog      \n3 laag      \n4 laag      \n5 midden    \n\n\nDe functie mutate() komen we nog vaak tegen. We kunnen deze bijvoorbeeld ook gebruiken om een nieuwe variabele aan te maken uit bestaande variabelen. Zo zouden we de variabele age_range kunnen aanmaken die het leeftijdsbereik uitdrukt als het verschil tussen de minimumleeftijd (age_min) en de maximumleeftijd (age_max):\n\nwordbank_datasets &lt;-\n  mutate(wordbank_datasets,\n         age_range = age_max - age_min)\n\nrelocate(.data = wordbank_datasets,\n         age_range,\n         .after = age_max)\n\n# A tibble: 89 × 9\n   instrument_id language  form  form_type age_min age_max age_range has_grammar\n   &lt;fct&gt;         &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n 1 1             British … WG    WG              8      36        28           0\n 2 2             Cantonese WS    WS             16      30        14           0\n 3 3             Croatian  WG    WG              8      16         8           0\n 4 4             Croatian  WS    WS             16      30        14           0\n 5 5             Danish    WG    WG              8      20        12           0\n 6 6             Danish    WS    WS             16      36        20           1\n 7 7             English … WG    WG              8      18        10           0\n 8 8             English … WS    WS             16      30        14           1\n 9 9             French (… WG    WG              8      16         8           0\n10 10            French (… WS    WS             16      30        14           1\n# ℹ 79 more rows\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\nWe maken hier met relocate() de nieuwe variabele zichtbaar direct achter de variabele age_max in de datatabel. Wanneer we dit niet doen dan zou deze achteraan komen. Je kunt .after (of .before) ook direct als argument aan mutate() meegeven."
  },
  {
    "objectID": "data.html#sec-voorbeeldscript",
    "href": "data.html#sec-voorbeeldscript",
    "title": "3  Data in R",
    "section": "3.3 Voorbeeldscript",
    "text": "3.3 Voorbeeldscript\nWanneer je begint met coderen is het vooral belangrijk dat je code werkt. Hoe je code precies tot het resultaat komt is nog van ondergeschikt belang. Het kan altijd eleganter of sneller. Toch is het verstandig om je vanaf het begin af aan een aantal zaken aan te leren die je code leesbaarder maken. Hier een aantal richtlijnen:\nGoede code gebruikt:\n\nduidelijke namen voor datatabellen en vectoren, waarbij we gebruik maken van snake_case (dus age_range en niet AgeRange);\nspaties om operatoren, zoals = en , (dus x = y en x, y i.p.v x=y en x,y);\nnieuwe regels om de lengte van code te beperken, bijvoorbeeld door na een , of &lt;- een return te geven;\ninspringing om aan te geven dat code op de huidige regel nog bij een vorige regel hoort en bijvoorbeeld argumenten van een functie op hetzelfde niveau te zetten.\n\nEen goed script:\n\nheeft een heldere opbouw met eerst het aanroepen van packages, dan het inlezen van de data, het bewerken van variabelen en dan de overige dingen die je gaat doen;\ngebruikt witregels om codeblokjes te maken van regels code die bij elkaar horen en deze te scheiden van andere code met een andere functie;\nheeft een goede toelichting op de werking van een blokje code, hierbij gebruik je # aan het begin van de regel. Je kunt # ook gebruiken om op een regel commentaar toe te voegen. R negeert alles wat na een # staat en probeert dit dus niet uit te voeren.\n\nHieronder een voorbeeldscript gebaseerd op de code uit dit hoofdstuk:\n\n# Aanroepen benodigde packages\nlibrary(tidyverse)\n\n# Bekijken dataset\nwordbank_datasets\n\n# Aanpassen type van variabelen\nwordbank_datasets &lt;-\n  mutate(.data = wordbank_datasets,\n         language = as.factor(language),\n         form = as.factor(form),\n         form_type = as.factor(form_type),\n         instrument_id = as.factor(instrument_id)\n         )\n\n# Aanmaken aparte vector met alle talen in de dataset\nlanguages &lt;- pull(wordbank_datasets, language)"
  },
  {
    "objectID": "data.html#omgaan-met-errors",
    "href": "data.html#omgaan-met-errors",
    "title": "3  Data in R",
    "section": "3.4 Omgaan met errors",
    "text": "3.4 Omgaan met errors\nR neemt alles wat je typt heel letterlijk. Je zult dus heel precies moeten werken, anders geeft R je een foutmelding. In onderstaand voorbeeld zijn we bijvoorbeeld de ‘s’ vergeten aan het eind van ‘dataset’. We vragen R dus om wordbank_dataset te laten zien, terwijl we wordbank_datasets bedoelen. Het is een klein verschil, maar voor R voldoende om een error te geven.\n\nwordbank_dataset\n\nError in eval(expr, envir, enclos): object 'wordbank_dataset' not found\n\n\nErrors horen bij coderen. Ze kunnen ontstaan door typefouten of door het verkeerd gebruik van de regels van de taal (bijv. het vergeten van een argument dat nodig is om een functie uit te kunnen voeren). Errors kunnen heel frustrerend zijn en soms ook veel tijd kosten om op te lossen. Probeer rustig te blijven, haal diep adem en probeer uit te vinden waar R over klaagt. Vaak zit er in de error-melding wel een aanwijzing wat er mis is. Wanneer R meldt ‘object nog found’ dan gaat het meestal of om een typefout in de naam van het object dat je wilt gebruiken of om een variabele in een datatabel, terwijl je R nog niet hebt verteld in een specifieke datatabel te zoeken.\nNaast errors geeft R ook waarschuwingen (warnings). De ernst daarvan is vaak wat moeilijker te bepalen. Soms kun je die voorbij laten gaan, maar soms moet je er ook echt iets mee. Ook voor warnings geldt dat het verstandig is om ze goed te bekijken, want vaak staat er een aanwijzing in. In onderstaand voorbeeld proberen we met de functie mean() het gemiddelde van te berekenen van een vector die niet uit getallen bestaat. De functie mean() vraagt echter om getallen. R wijst ons hierop in de warning en geeft ook aan wat het resultaat hiervan is: je krijgt ontbrekende data NAs (voor not available).\n\nmean(languages)\n\nWarning in mean.default(languages): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n\n\nZoals gezegd, errors horen bij coderen. Je moet er simpelweg mee leren leven. Laat je niet gek maken en weet dat je niet alleen bent. De kans is groot dat iemand anders dezelfde error ook heeft gehad en er al een oplossing voor heeft gevonden. Stel dus vragen of kopieer je error-melding naar Google om uit te vinden wat het probleem nu eigenlijk is en welke oplossingen er bestaan. Websites als stackoverflow bieden vaak hulp."
  },
  {
    "objectID": "data.html#verder-leren",
    "href": "data.html#verder-leren",
    "title": "3  Data in R",
    "section": "Verder leren",
    "text": "Verder leren\n\nIn Hoofdstuk 1 van SfL (Winter, 2019) wordt de basis van R (base R) verder uitgelegd. Ter voorbereiding op het eerste practicum is het prettig om vast wat commando’s te proberen uit dit hoofdstuk. Werk verder in het script dat je in het vorige hoofdstuk hebt aangemaakt.5 Werk nu hoofdstuk 1 door t/m sectie 1.8. Typ de commando’s in de grijze vakken over en voer ze uit. In sectie 1.2 doe je dit direct in de R-console, vanaf sectie 1.3 (en in alle volgende practica!) in een script. Zie sectie 1.15 voor handige shortcuts die je hierbij kunt gebruiken. Controleer steeds weer of je dezelfde output krijgt als in het boek.\n\n\nWinter, B. (2019). Statistics for Linguists: An Introduction Using R. Routledge. https://doi.org/10.4324/9781315165547\n5 Je kunt eventueel ook https://rdrr.io/snippets gebruiken voor het uitvoeren van R-code, mocht de installatie op je eigen computer niet werken. We kunnen dan tijdens een practicum proberen R en RStudio werkend te krijgen op je computer.Nu zou je in staat moeten zijn Practicum 1 te maken."
  },
  {
    "objectID": "bewerken.html#de-pipe-operator",
    "href": "bewerken.html#de-pipe-operator",
    "title": "4  Data Bewerken",
    "section": "4.1 de pipe-operator",
    "text": "4.1 de pipe-operator\nIn het tidyverse zit een hele verzameling aan werkwoorden die je kunt gebruiken om bewerkingen op je data uit te voeren. Deze werkwoorden hebben gemeenschappelijk dat ze altijd een bewerking uitvoeren op een datatabel (tibble) en (meestal) weer een nieuwe datatabel opleveren. In het vorige hoofdstuk hebben we bijvoorbeeld distinct() gezien. Dit ‘werkwoord’ geeft van een variabele in een datatabel de unieke waarden terug.\n\ndistinct(.data = wordbank_datasets, language)\n\n# A tibble: 42 × 1\n   language             \n   &lt;fct&gt;                \n 1 British Sign Language\n 2 Cantonese            \n 3 Croatian             \n 4 Danish               \n 5 English (American)   \n 6 French (Quebecois)   \n 7 German               \n 8 Hebrew               \n 9 Italian              \n10 Mandarin (Beijing)   \n# ℹ 32 more rows\n\n\nDe datatabel waarop de bewerking wordt uitgevoerd (hier: wordbank_datasets) staat altijd als eerste argument van de functie genoemd. Om de code overzichtelijker te maken en om het mogelijk te maken om meerdere operaties na elkaar uit te voeren bestaat de pipe-operator %&gt;%. Deze operator maakt het mogelijk om de datatabel uit de functie-aanroep te halen en ervoor te zetten:\n\nwordbank_datasets %&gt;% distinct(language)\n\n# A tibble: 42 × 1\n   language             \n   &lt;fct&gt;                \n 1 British Sign Language\n 2 Cantonese            \n 3 Croatian             \n 4 Danish               \n 5 English (American)   \n 6 French (Quebecois)   \n 7 German               \n 8 Hebrew               \n 9 Italian              \n10 Mandarin (Beijing)   \n# ℹ 32 more rows\n\n\nDeze code doet hetzelfde als de eerdere variant waarbij we de datatabel nog op de eerste plek benoemden. Onderliggend is dit namelijk precies wat R voor je doet, wanneer je de pipe gebruikt:\n\n\n\nde pipe-operator\n\n\n\n\nx %&gt;% functie(y) wordt functie(.data = x, y)\n\n\n\nHet is even wennen maar de pipe operator %&gt;% is een ontzettend handige toevoeging aan je gereedschapskist. Met deze operator kun je namelijk heel makkelijk verschillende operaties aan elkaar plakken zonder dat je data tussendoor een nieuwe naam hoeft te geven. Je kunt de pipe lezen als ‘pak datatabel \\(x\\) en pas functie \\(f\\) erop toe’. Aangezien de output van de functies doorgaans een nieuwe datatabel oplevert kun je de output van een functie weer met een pipe doorzetten naar een volgende. Je kunt de pipe dan lezen als en doe dan dit. De pipe maakt het eenvoudiger om je code van links naar rechts te lezen in plaats van binnen naar buiten.\n\ndata %&gt;% functie1() %&gt;% functie2()\n\nWij schrijven de pipe als %&gt;%, omdat deze manier ook gehanteerd wordt in de overige literatuur die we gebruiken in deze cursus. De nieuwste versie van tidyverse schrijft de pipe als |&gt;. In ons geval zijn deze twee schrijfwijzen equivalent, maar wij gebruiken in het dictaat en uitwerkingen dus %&gt;%."
  },
  {
    "objectID": "bewerken.html#sec-observaties",
    "href": "bewerken.html#sec-observaties",
    "title": "4  Data Bewerken",
    "section": "4.2 Observaties uitlichten",
    "text": "4.2 Observaties uitlichten\n\n4.2.1 filter()\nHet komt vaak voor dat je maar een deel van de data wilt bekijken. De functie filter() kun je gebruiken om een selectie te maken van de observaties die je wilt gaan bekijken. In de datatabel wordbank_datasets komen bijvoorbeeld twee typen vragenlijsten voor (variabele: form_type): vragenlijsten van type WG wat staat voor Words & Gestures zijn afgenomen bij ouders van babies en vragenlijsten van type WS wat staat voor Words & Sentences zijn afgenomen bij ouders van peuters. Wanneer we onze analyse nu willen beperken tot alleen de vragenlijsten afgenomen bij babies kunnen we dit met filter() aangeven:\n\nwordbank_datasets %&gt;% \n  filter(form_type == \"WS\")\n\n# A tibble: 48 × 9\n   instrument_id language           form  form_type age_min age_max has_grammar\n   &lt;fct&gt;         &lt;fct&gt;              &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 2             Cantonese          WS    WS             16      30           0\n 2 4             Croatian           WS    WS             16      30           0\n 3 6             Danish             WS    WS             16      36           1\n 4 8             English (American) WS    WS             16      30           1\n 5 10            French (Quebecois) WS    WS             16      30           1\n 6 11            German             WS    WS             18      30           0\n 7 13            Hebrew             WS    WS             25      36           1\n 8 15            Italian            WS    WS             18      36           0\n 9 17            Mandarin (Beijing) TC    WS             17      30           0\n10 18            Mandarin (Beijing) WS    WS             16      30           0\n# ℹ 38 more rows\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\nDe conditie form_type == \"WS\" binnen filter() moeten we lezen als ‘behoud de observaties waarbij form_type gelijk is aan WS’. We zien dat 48 van de 89 vragenlijst in de oorspronkelijke dataset aan deze conditie voldoen. Wanneer we met alleen deze data willen verder werken dan zouden we ervoor kunnen kiezen om deze weg te schrijven naar een nieuwe datatabel (met de inmiddels bekende operator &lt;-).\n\nwordbank_WS &lt;- wordbank_datasets %&gt;% \n  filter(form_type == \"WS\")\n\nDe functie filter() werkt met condities waaraan voldaan moet worden. Afhankelijk van het type variabele kunnen die een andere vorm aannemen. Bij factoren zal het doorgaans gaan om het al dan niet gelijk zijn aan een bepaald level (==: gelijk aan, !=: is niet gelijk aan) waarbij de naam van het level tussen aanhalingstekens moet staan. Bij numerieke variabelen kan er ook gekeken worden of een getal groter (&gt;) of kleiner (&lt;) is dan een bepaalde waarde. Willen we bijvoorbeeld alleen kijken naar datasets waarin de babies maximaal 18 maanden oud zijn dan kunnen we de variabele age_max beperken:\n\nwordbank_datasets %&gt;% \n  filter(age_max &lt;= 18)\n\n# A tibble: 31 × 9\n   instrument_id language           form  form_type age_min age_max has_grammar\n   &lt;fct&gt;         &lt;fct&gt;              &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 3             Croatian           WG    WG              8      16           0\n 2 7             English (American) WG    WG              8      18           0\n 3 9             French (Quebecois) WG    WG              8      16           0\n 4 16            Mandarin (Beijing) IC    WG             12      16           0\n 5 21            Russian            WG    WG              8      18           0\n 6 23            Slovak             WG    WG              8      16           0\n 7 25            Spanish (Mexican)  WG    WG              8      18           0\n 8 27            Swedish            WG    WG              8      16           0\n 9 29            Turkish            WG    WG              8      16           0\n10 38            Kigiriama          WG    WG              8      15           0\n# ℹ 21 more rows\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\nDe condities in filter() moeten een waarheidswaarde (true, false) opleveren. De operatoren die hierbij gebruikt kunnen worden zie je in Tabel 4.1. Dit worden ook wel booleans genoemd.\n\n\n\n\n\n\n\n\n\n\noperator\nte lezen als\nvoorbeeld\n\n\n\n\n==\nis gelijk aan\nform_type == \"WS\"\n\n\n!=\nis niet gelijk aan\nform_type != \"WS\"\n\n\n%in%\nkomt voor in de vector\nlanguage %in% c(\"Dutch\", \"German\")\n\n\n&lt;\nkleiner dan\nage_max &lt; 19\n\n\n&lt;=\nkleiner dan of gelijk aan\nage_max &lt;= 18\n\n\n&gt;\ngroter dan\nage_min &gt; 3\n\n\n&gt;=\ngroter dan of gelijk aan\nage_min &gt;= 2\n\n\nbetween()\ntussen\nbetween(age_min, 2, 10)\n\n\nis.na()\nis een missing value\nis.na(form_type)\n\n\n!is.na()\nis geen missing value\n!is.na(form_type)\n\n\n!\nniet, keert de waarheidswaarde om\n!age_max &lt;= 18\n\n\n\nTabel 4.1: boolean operatoren in R\nHet is ook mogelijk om meerdere condities te combineren. Dat kan op dezelfde variabele of op meerdere variabelen. Hiervoor kun je de logische operatoren & ‘en (beide condities moeten waar zijn)’, | ‘of (een van beide of beiden condities moeten waar zijn)’ of xor() ‘exclusief of (een van beide maar niet beide condities moeten waar zijn)’. In plaats van & kun je de condities ook scheiden door een komma. Als we dus filteren op de WS-vragenlijsten van babies van maximaal 18 maanden, hebben we twee opties:\n\nwordbank_datasets %&gt;% \n  filter(form_type == \"WS\" & age_max &lt;= 18)\n\n# A tibble: 2 × 9\n  instrument_id language       form    form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;          &lt;fct&gt;   &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 85            Arabic (Saudi) WS      WS              8      16           1\n2 86            Arabic (Saudi) WSOther WS              8      16           1\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\nwordbank_datasets %&gt;% \n  filter(form_type == \"WS\",\n         age_max &lt;= 18)\n\n# A tibble: 2 × 9\n  instrument_id language       form    form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;          &lt;fct&gt;   &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 85            Arabic (Saudi) WS      WS              8      16           1\n2 86            Arabic (Saudi) WSOther WS              8      16           1\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\n\n\n4.2.2 slice()\nMet de verschillende slice-functies kun je bepaalde rijen zichtbaar maken op basis van hun positie in de datatabel of een minimale of maximale waarde op een variabele.\nWanneer we de eerste of laatste rijen zichtbaar willen maken gebruiken we slice_head() of slice_tail(). Het argument n geeft hierbij aan hoeveel rijen je zichtbaar wilt maken:\n\nwordbank_datasets %&gt;% \n  slice_head(n = 3)\n\n# A tibble: 3 × 9\n  instrument_id language             form  form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;                &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 1             British Sign Langua… WG    WG              8      36           0\n2 2             Cantonese            WS    WS             16      30           0\n3 3             Croatian             WG    WG              8      16           0\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\nwordbank_datasets %&gt;% \n  slice_tail(n = 2)\n\n# A tibble: 2 × 9\n  instrument_id language form  form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;    &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 93            Japanese WG    WG              8      18           1\n2 94            Japanese WS    WS             16      36           1\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\nDe functie slice() is een algemenere functie waarin je de nummers van de rijen in de datatabel als argument meegeeft:\n\nwordbank_datasets %&gt;% \n  slice(10:15)\n\n# A tibble: 6 × 9\n  instrument_id language           form  form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;              &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 10            French (Quebecois) WS    WS             16      30           1\n2 11            German             WS    WS             18      30           0\n3 12            Hebrew             WG    WG             11      25           0\n4 13            Hebrew             WS    WS             25      36           1\n5 14            Italian            WG    WG              7      24           0\n6 15            Italian            WS    WS             18      36           0\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\nMet slice_min() en slice_max() kun je de rijen selecteren met de minimale of maximale waarde op een variabele. Ook hier kun je met n aangeven hoeveel. Wanneer meerdere rijen hier dezelfde waarde hebben kun je meer rijen krijgen dan het gevraagde aantal\n\nwordbank_datasets %&gt;% \n  slice_max(age_max)\n\n# A tibble: 1 × 9\n  instrument_id language          form     form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;             &lt;fct&gt;    &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 32            English (British) TEDS Th… WS             34      47           1\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\nwordbank_datasets %&gt;% \n  slice_min(age_min,\n            n = 3)\n\n# A tibble: 41 × 9\n   instrument_id language            form  form_type age_min age_max has_grammar\n   &lt;fct&gt;         &lt;fct&gt;               &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 14            Italian             WG    WG              7      24           0\n 2 1             British Sign Langu… WG    WG              8      36           0\n 3 3             Croatian            WG    WG              8      16           0\n 4 5             Danish              WG    WG              8      20           0\n 5 7             English (American)  WG    WG              8      18           0\n 6 9             French (Quebecois)  WG    WG              8      16           0\n 7 19            Norwegian           WG    WG              8      20           0\n 8 21            Russian             WG    WG              8      18           0\n 9 23            Slovak              WG    WG              8      16           0\n10 25            Spanish (Mexican)   WG    WG              8      18           0\n# ℹ 31 more rows\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\nWil je random een aantal observaties uit je datatabel halen dan kun je slice_sample() gebruiken. Deze functie zal iedere keer een ander resultaat geven. Het is dan voor de reproduceerbaarheid verstandig om aan het begin van je script (of voordat je de functie aanroept) een random seed aan te maken met de functie set.seed(). Wanneer iemand anders deze functie met hetzelfde getal uitboert, zal die dezelfde resultaten krijgen. Dit geldt dus ook voor jezelf, wanneer je het script meerdere keren of op een later moment uitvoert.\n\nset.seed(25)\n\nwordbank_datasets %&gt;% \n  slice_sample(n = 3)\n\n# A tibble: 3 × 9\n  instrument_id language           form    form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;              &lt;fct&gt;   &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 7             English (American) WG      WG              8      18           0\n2 24            Slovak             WS      WS             17      36           1\n3 65            Dutch              Swingl… WG              8      36           1\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;"
  },
  {
    "objectID": "bewerken.html#sec-selecteren",
    "href": "bewerken.html#sec-selecteren",
    "title": "4  Data Bewerken",
    "section": "4.3 Variabelen selecteren",
    "text": "4.3 Variabelen selecteren\nWe hebben nu steeds gekeken hoe je observaties (rijen) kunt uitlichten uit een dataset. Hetzelfde kunnen we ook doen met variabelen. De functie select() is hierbij de belangrijkste functie. Aan deze functie geven we de variabelen mee die we willen behouden in een vervolgstap. Stel we willen in onze dataset wordbank_datasets alleen verder met de variabelen instrument_id en language. We voegen dan deze variabelen gescheiden door een , toe aan de functie select():\n\nwordbank_datasets %&gt;% \n  select(instrument_id, language)\n\n# A tibble: 89 × 2\n   instrument_id language             \n   &lt;fct&gt;         &lt;fct&gt;                \n 1 1             British Sign Language\n 2 2             Cantonese            \n 3 3             Croatian             \n 4 4             Croatian             \n 5 5             Danish               \n 6 6             Danish               \n 7 7             English (American)   \n 8 8             English (American)   \n 9 9             French (Quebecois)   \n10 10            French (Quebecois)   \n# ℹ 79 more rows\n\n\nLet erop dat je in dit geval deze verandering alleen tijdelijk hebt gemaakt. Het is nu nog niet zo dat je de variabele definitief hebt verwijderd uit de datatabel. Om dat voor elkaar te krijgen zul je de actie toe moeten schrijven aan een naam met de operator &lt;-, zoals we al vaker hebben gezien.\nWanneer je meerdere opeenvolgende variabelen wilt toevoegen kun je gebruik maken van de operator :, die je moet lezen als ‘t/m’. Deze operator is te combineren met , als je daarnaast ook nog extra variabelen wilt toevoegen die verderop in de dataset voorkomen. Dit scheelt je typewerk.\n\nwordbank_datasets %&gt;% \n  select(instrument_id, language, form_type:has_grammar)\n\n# A tibble: 89 × 6\n   instrument_id language              form_type age_min age_max has_grammar\n   &lt;fct&gt;         &lt;fct&gt;                 &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 1             British Sign Language WG              8      36           0\n 2 2             Cantonese             WS             16      30           0\n 3 3             Croatian              WG              8      16           0\n 4 4             Croatian              WS             16      30           0\n 5 5             Danish                WG              8      20           0\n 6 6             Danish                WS             16      36           1\n 7 7             English (American)    WG              8      18           0\n 8 8             English (American)    WS             16      30           1\n 9 9             French (Quebecois)    WG              8      16           0\n10 10            French (Quebecois)    WS             16      30           1\n# ℹ 79 more rows\n\n\nSoms is het handiger om niet de variabelen die je wilt behouden, maar juist die variabelen die je niet wilt behouden te noemen. Hiervoor kun je de operator - gebruiken voor de naam van de variabele die je niet meer wilt gebruiken. Dus bijvoorbeeld om de variabele form uit te sluiten gebruiken we:\n\nwordbank_datasets %&gt;% \n  select(- form)\n\n# A tibble: 89 × 8\n   instrument_id language              form_type age_min age_max has_grammar\n   &lt;fct&gt;         &lt;fct&gt;                 &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 1             British Sign Language WG              8      36           0\n 2 2             Cantonese             WS             16      30           0\n 3 3             Croatian              WG              8      16           0\n 4 4             Croatian              WS             16      30           0\n 5 5             Danish                WG              8      20           0\n 6 6             Danish                WS             16      36           1\n 7 7             English (American)    WG              8      18           0\n 8 8             English (American)    WS             16      30           1\n 9 9             French (Quebecois)    WG              8      16           0\n10 10            French (Quebecois)    WS             16      30           1\n# ℹ 79 more rows\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\nDoor de pipe kunnen we select() combineren de eerder geïntroduceerde werkwoorden om de dataset tegelijkertijd ook in te perken op basis van observaties. Zo kunnen we select() combineren met filter(), bijvoorbeeld om een dataset te maken met de eerste drie variabelen met alleen vragenlijsten van type WS:\n\nwordbank_datasets %&gt;% \n  filter(form_type == \"WS\") %&gt;% \n  select(instrument_id, language)\n\n# A tibble: 48 × 2\n   instrument_id language          \n   &lt;fct&gt;         &lt;fct&gt;             \n 1 2             Cantonese         \n 2 4             Croatian          \n 3 6             Danish            \n 4 8             English (American)\n 5 10            French (Quebecois)\n 6 11            German            \n 7 13            Hebrew            \n 8 15            Italian           \n 9 17            Mandarin (Beijing)\n10 18            Mandarin (Beijing)\n# ℹ 38 more rows\n\n\nIn principe maakt het niet uit in welke volgorde we select() en filter() zetten. In sommige gevallen kan dit wel cruciaal zijn, zoals in dit voorbeeld. Als je wilt filteren op basis van een variabele (hier form_type), dan moet je natuurlijk niet eerst de dataset zo inperken dat die variabele niet meer aanwezig is, want dan krijg je een error. Denk dus altijd goed na welke gevolgen de volgorde van je functies kan hebben."
  },
  {
    "objectID": "bewerken.html#missing-values",
    "href": "bewerken.html#missing-values",
    "title": "4  Data Bewerken",
    "section": "4.4 Missing values",
    "text": "4.4 Missing values\n\n\n\nOnze voorbeelddataset wordbank_datasets is een complete dataset. Voor elke observatie zijn er voor alle variabelen waarden aanwezig. Dit is lang niet altijd het geval. Vaak is het zo dat er datapunten ontbreken. Een waarde voor een bepaalde variabele kan niet beschikbaar zijn, bijvoorbeeld doordat deze niet te achterhalen was, niet is uitgevraagd of dat er iets mis is gegaan in de dataverwerking. Ontbrekende waarden noemen we ook wel missing values. Deze worden in R gemarkeerd als NA voor ‘not available’. Er is veel te vertellen over missing values. We beperken ons hier ertoe dat je je bewust moet zijn van het bestaan van missing values. Het is dus verstandig om bij elke dataset voor de relevante variabelen die je mee wilt nemen in je analyse na te gaan of er ontbrekende waarden aanwezig zijn en deze eventueel te verwijderen. op deze manier voorkom je vaak problemen die later kunnen ontstaan.\nTer illustratie hebben we een dataset wordbank_dataset_NA gemaakt waaraan observaties zijn toegevoegd met een missing value op de variabele age_range. We kunnen de functie is.na() gebruiken (zie Tabel 4.1) om deze observaties zichtbaar te maken:\n\nwordbank_dataset_NA %&gt;% \n  filter(is.na(age_range))\n\n# A tibble: 3 × 4\n  instrument_id language form_type age_range\n  &lt;fct&gt;         &lt;fct&gt;    &lt;fct&gt;         &lt;dbl&gt;\n1 999           Irish    WS               NA\n2 9999          Dutch    WS               NA\n3 99999         Croatian WG               NA\n\n\nWe zien inderdaad in de kolom age_range drie keer NA verschijnen. De ontkenning !is.na() kunnen we gebruiken in combinatie met filter() om deze observaties uit de dataset te verwijderen.\n\nwordbank_dataset_NA %&gt;% \n  filter(!is.na(age_range))\n\n# A tibble: 89 × 4\n   instrument_id language              form_type age_range\n   &lt;fct&gt;         &lt;fct&gt;                 &lt;fct&gt;         &lt;dbl&gt;\n 1 1             British Sign Language WG               28\n 2 2             Cantonese             WS               14\n 3 3             Croatian              WG                8\n 4 4             Croatian              WS               14\n 5 5             Danish                WG               12\n 6 6             Danish                WS               20\n 7 7             English (American)    WG               10\n 8 8             English (American)    WS               14\n 9 9             French (Quebecois)    WG                8\n10 10            French (Quebecois)    WS               14\n# ℹ 79 more rows\n\n\nZoals eerder gezien, kunnen we hier ook meerdere variabelenamen invoeren gescheiden door een ,. Een alternatieve functie is drop_na() die, zoals de naam als zegt, de observaties verwijdert die een ontbrekende waarde hebben op de variabele die als argument wordt meegegeven:\n\nwordbank_dataset_NA %&gt;% \n  drop_na(age_range)\n\n# A tibble: 89 × 4\n   instrument_id language              form_type age_range\n   &lt;fct&gt;         &lt;fct&gt;                 &lt;fct&gt;         &lt;dbl&gt;\n 1 1             British Sign Language WG               28\n 2 2             Cantonese             WS               14\n 3 3             Croatian              WG                8\n 4 4             Croatian              WS               14\n 5 5             Danish                WG               12\n 6 6             Danish                WS               20\n 7 7             English (American)    WG               10\n 8 8             English (American)    WS               14\n 9 9             French (Quebecois)    WG                8\n10 10            French (Quebecois)    WS               14\n# ℹ 79 more rows\n\n\nZoals altijd, om deze wijziging blijvend te maken moeten we de datatabel weer toeschrijven aan een naam met &lt;-."
  },
  {
    "objectID": "bewerken.html#sec-tellingen",
    "href": "bewerken.html#sec-tellingen",
    "title": "4  Data Bewerken",
    "section": "4.5 Simpele tellingen",
    "text": "4.5 Simpele tellingen\nWanneer je begint te werken met een dataset wil je allereerst een goed beeld krijgen van de data. Nadat je eventueel de naam en het type van een of meerdere variabelen hebt aangepast (zie Hoofdstuk 3), is het handig om tellingen te maken van relevante variabelen. Dit geeft je een idee van wat je kan verwachten en of er bijvoorbeeld dubbelingen in de data zitten. We kunnen hiervoor de functie count() gebruiken. We geven als argument de naam van de variabele mee waarin we geïnteresseerd zijn, in dit geval language. Deze functie geeft een tabel waarin het aantal voorkomens staat vermeld in de kolom n.\n\nwordbank_dataset_NA %&gt;% \n  count(language)\n\n# A tibble: 42 × 2\n   language                   n\n   &lt;fct&gt;                  &lt;int&gt;\n 1 American Sign Language     5\n 2 Arabic (Saudi)             3\n 3 British Sign Language      1\n 4 Cantonese                  1\n 5 Catalan                    2\n 6 Croatian                   3\n 7 Czech                      1\n 8 Danish                     2\n 9 Dutch                      8\n10 English (American)         4\n# ℹ 32 more rows\n\n\nWe kunnen de tellingen in n met arrange() ordenen van klein naar groot …\n\nwordbank_dataset_NA %&gt;% \n  count(language) %&gt;% \n  arrange(n)\n\n# A tibble: 42 × 2\n   language                  n\n   &lt;fct&gt;                 &lt;int&gt;\n 1 British Sign Language     1\n 2 Cantonese                 1\n 3 Czech                     1\n 4 English (Australian)      1\n 5 English (Irish)           1\n 6 Estonian                  1\n 7 German                    1\n 8 Greek (Cypriot)           1\n 9 Hungarian                 1\n10 Spanish (Argentinian)     1\n# ℹ 32 more rows\n\n\n… of met toevoeging van desc() van groot naar klein:\n\nwordbank_dataset_NA %&gt;% \n  count(language) %&gt;% \n  arrange(desc(n))\n\n# A tibble: 42 × 2\n   language                   n\n   &lt;fct&gt;                  &lt;int&gt;\n 1 Dutch                      8\n 2 American Sign Language     5\n 3 English (American)         4\n 4 English (British)          4\n 5 Finnish                    4\n 6 Arabic (Saudi)             3\n 7 Croatian                   3\n 8 Korean                     3\n 9 Mandarin (Beijing)         3\n10 Catalan                    2\n# ℹ 32 more rows\n\n\nDe functie count() is zelfs ook toe te passen op numerieke variabelen\n\nwordbank_dataset_NA %&gt;% \n  count(age_range) %&gt;% \n  arrange(desc(n))\n\n# A tibble: 16 × 2\n   age_range     n\n       &lt;dbl&gt; &lt;int&gt;\n 1        20    20\n 2         8    16\n 3        14    13\n 4        28     8\n 5        10     7\n 6         7     6\n 7        12     5\n 8        18     4\n 9        13     3\n10        NA     3\n11        19     2\n12         4     1\n13         9     1\n14        11     1\n15        15     1\n16        17     1\n\n\nWe zien in bovenstaande output dat missing values ook worden geteld. Zoals eerder gezegd, het is dus verstandig deze eerst te verwijderen:\n\nwordbank_dataset_NA %&gt;% \n  drop_na(age_range) %&gt;% \n  count(age_range) %&gt;% \n  arrange(desc(n))\n\n# A tibble: 15 × 2\n   age_range     n\n       &lt;dbl&gt; &lt;int&gt;\n 1        20    20\n 2         8    16\n 3        14    13\n 4        28     8\n 5        10     7\n 6         7     6\n 7        12     5\n 8        18     4\n 9        13     3\n10        19     2\n11         4     1\n12         9     1\n13        11     1\n14        15     1\n15        17     1\n\n\nSoms wil je al iets meer de diepte in met je analyse. Stel je wilt kijken naar voorkomens van een variabele binnen verschillende niveaus van een andere variabele. Je kunt dan gebruikmaken van group_by(). Wanneer we de variabele form_type meegeven als argument dan krijgen we tellingen die weergeven hoe vaak elke taal voorkomt per type vragenlijst (‘WG’ en ‘WS’):\n\nwordbank_dataset_NA %&gt;% \n  group_by(form_type) %&gt;% \n  count(language)\n\n# A tibble: 72 × 3\n# Groups:   form_type [2]\n   form_type language                   n\n   &lt;fct&gt;     &lt;fct&gt;                  &lt;int&gt;\n 1 WG        American Sign Language     2\n 2 WG        Arabic (Saudi)             1\n 3 WG        British Sign Language      1\n 4 WG        Catalan                    1\n 5 WG        Croatian                   2\n 6 WG        Danish                     1\n 7 WG        Dutch                      5\n 8 WG        English (American)         2\n 9 WG        English (British)          2\n10 WG        Finnish                    2\n# ℹ 62 more rows\n\n\nJe kunt bovenstaand resultaat ook krijgen door beide variabelen mee te geven aan group_by:\n\nwordbank_dataset_NA %&gt;% \n  group_by(form_type, language) %&gt;% \n  count()\n\n# A tibble: 72 × 3\n# Groups:   form_type, language [72]\n   form_type language                   n\n   &lt;fct&gt;     &lt;fct&gt;                  &lt;int&gt;\n 1 WG        American Sign Language     2\n 2 WG        Arabic (Saudi)             1\n 3 WG        British Sign Language      1\n 4 WG        Catalan                    1\n 5 WG        Croatian                   2\n 6 WG        Danish                     1\n 7 WG        Dutch                      5\n 8 WG        English (American)         2\n 9 WG        English (British)          2\n10 WG        Finnish                    2\n# ℹ 62 more rows\n\n\nWanneer je iets anders dan tellingen wilt in combinatie met group_by(), bijvoorbeeld een gemiddelde berekenen, dan moet je deze functie combineren met summarize() (of summarise()). Binnen summarize() geef je dan aan wat je wilt dat R voor je berekent. Als we bijvoorbeeld de gemiddelde age_range per type vragenlijst willen bepalen, kunnen we de volgende code gebruiken:\n\nwordbank_dataset_NA %&gt;% \n  drop_na(age_range) %&gt;% \n  group_by(form_type) %&gt;% \n  summarize(mean_age_range = mean(age_range))\n\n# A tibble: 2 × 2\n  form_type mean_age_range\n  &lt;fct&gt;              &lt;dbl&gt;\n1 WG                  11.8\n2 WS                  17.2\n\n\nWe gebruiken hiervoor de functie mean() om het gemiddelde te berekenen. Binnen summarize() geven we hierbij aan hoe we de variabele waarin het gemiddelde wordt opgeslagen willen noemen. Dit doen we voor het =-teken. Let op dat je wel eerst de missing values verwijdert, want anders geeft de functie mean() NAs als resultaat, aangezien er van een reeks getallen met een NA geen gemiddelde kan worden berekend.\n\nwordbank_dataset_NA %&gt;% \n  group_by(form_type) %&gt;% \n  summarize(mean_age_range = mean(age_range))\n\n# A tibble: 2 × 2\n  form_type mean_age_range\n  &lt;fct&gt;              &lt;dbl&gt;\n1 WG                    NA\n2 WS                    NA\n\n\nBij de functie mean() kun je overigens ook in de functie zelf aangeven dat je missing values niet mee wilt nemen in de berekening:\n\nwordbank_dataset_NA %&gt;% \n  group_by(form_type) %&gt;% \n  summarize(mean_age_range = mean(age_range, na.rm = TRUE))\n\n# A tibble: 2 × 2\n  form_type mean_age_range\n  &lt;fct&gt;              &lt;dbl&gt;\n1 WG                  11.8\n2 WS                  17.2\n\n\nDoor het argument na.rm de waarde TRUE (of afgekort T) te geven worden NAs niet meegenomen. Wanneer je binnen summarize() een telling wilt toevoegen dan maak je gebruik van n() i.p.v. count().\n\nwordbank_dataset_NA %&gt;% \n  group_by(form_type) %&gt;% \n  summarize(mean_age_range = mean(age_range, na.rm = TRUE),\n            n = n())\n\n# A tibble: 2 × 3\n  form_type mean_age_range     n\n  &lt;fct&gt;              &lt;dbl&gt; &lt;int&gt;\n1 WG                  11.8    42\n2 WS                  17.2    50\n\n\nIn Hoofdstuk 7 vind je meer voorbeelden van functies die je binnen summarize() kunt gebruiken."
  },
  {
    "objectID": "bewerken.html#verder-leren",
    "href": "bewerken.html#verder-leren",
    "title": "4  Data Bewerken",
    "section": "Verder leren",
    "text": "Verder leren\n\nIn hoofdstuk 2 (t/m 2.6) uit Winter (2019) worden de belangrijkste tidyverse-functies besproken met andere voorbeelden.\nIn hoofdstuk 3 van Wickham et al. (2023) vind je een uitgebreidere beschrijving van de functies die in dit hoofdstuk aan bod zijn gekomen.\nhet dplyr cheatsheet geeft een overzicht van de werking van de functies.\n\n\nWinter, B. (2019). Statistics for Linguists: An Introduction Using R. Routledge. https://doi.org/10.4324/9781315165547\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2de dr.). O’Reilly. https://r4ds.hadley.nz/\nNu zou je in staat moeten zijn Practicum 2 te maken."
  },
  {
    "objectID": "grafieken.html#sec-grafieken-anatomie",
    "href": "grafieken.html#sec-grafieken-anatomie",
    "title": "5  Grafieken maken",
    "section": "5.1 De anatomie van een ggplot",
    "text": "5.1 De anatomie van een ggplot\nHet doel van dit hoofdstuk is om de grafiek in Figuur 5.1 na te maken.1 Op deze manier leer je de logica van het maken van grafieken in ggplot hopelijk snel begrijpen. De doelgrafiek biedt een weergave van data van Nederlandse kinderen uit Wordbank. Het geeft voor vier woorden aan door hoeveel van de kinderen voor wie een vragenlijst is ingevuld ze gebruikt worden in de leeftijd van 8 t/m 16 maanden.1 De opzet van dit hoofdstuk is gebaseerd op hoofdstuk 1 uit R for Data Science.\n\n\n\n\n\nFiguur 5.1: Ons doel voor dit hoofdstuk\n\n\n\n\n\n5.1.1 de data\nDe data waar we onze grafiek op baseren staan in het databestand wordbank_dutch_WG_items.csv in de map _datasets in ons R-project. We gaan dit bestand eerst inlezen en kijken of we aanpassingen moeten doen aan de namen of het type van de variabelen. Zorg voordat we beginnen dat je het package tidyverse hebt geladen. Dit zorgt ervoor dat het package ggplot2 ook actief is.\n\nlibrary(tidyverse)\n\n\n#inlezen databestand\nwordbank_dutch &lt;- read_csv(\"_datasets/wordbank_dutch_WG_items.csv\")\n\n#data bekijken\nwordbank_dutch\n\n# A tibble: 3,969 × 5\n   item_id item_definition category month proportion\n     &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;    &lt;dbl&gt;      &lt;dbl&gt;\n 1       1 au/ai(pijn)     sounds       8       0   \n 2       1 au/ai(pijn)     sounds       9       0   \n 3       1 au/ai(pijn)     sounds      10       0   \n 4       1 au/ai(pijn)     sounds      11       0.11\n 5       1 au/ai(pijn)     sounds      12       0.14\n 6       1 au/ai(pijn)     sounds      13       0.17\n 7       1 au/ai(pijn)     sounds      14       0.14\n 8       1 au/ai(pijn)     sounds      15       0.17\n 9       1 au/ai(pijn)     sounds      16       0.4 \n10       2 behbeh(schaap)  sounds       8       0   \n# ℹ 3,959 more rows\n\n\nDe data zien er goed uit: elke variabele heeft zijn eigen kolom. Het inlezen is dus goed gelukt. De namen van de variabelen voldoen aan onze standaard (snake_case) dus daar hoeven we niets aan aan te passen. Laten we de data eens bekijken om te zien of we misschien het type van variabelen aan moeten passen. De dataset geeft informatie over op welke leeftijd woorden (in de kolom item_definition) door hoeveel kinderen worden geproduceerd. De eerste variabele item_id bestaat uit getallen en wordt door R als numeriek gezien. De item_id moeten we echter als een naam zien en het dus beter om deze om te zetten naar een factor. Hetzelfde geldt voor de variabelen item_definition en category die nu nog van type character zijn. We hebben hier te maken met de specifieke woorden waarvoor gegevens verzameld zijn (item_definition) en de categorie waartoe de woorden volgens de vragenlijst behoren (category). Dit zijn beide terugkerende namen (bijv. au/ai(pijn) komt meerdere keren voor, net als sounds) en observaties willen we aan elkaar kunnen linken. Dat lukt alleen als we ze als factor behandelen. Tot slot geeft de variabelen month aan op welke leeftijd (in maanden) van de kinderen de vragenlijst is ingevuld en de variabele proportion geeft aan welke proportie kinderen (voor wie een vragenlijst is ingevuld) op die leeftijd het woord kon produceren. Het gaat hier in beide gevallen om getallen en de variabelen zijn door R ook als zodanig herkend (overigens is het ook mogelijk om month als een factor te beschouwen). Dit betekent dat de eerste drie variabelen moeten omzetten naar factoren, aangezien we hier te maken hebben met namen van levels. Omdat het hier gaat om drie kolommen maken we gebruik van de functie across() die het mogelijk maakt om een bewerking op meerdere kolommen tegelijk uit te voeren. Dit bespaart wat typewerk. We gebruiken : tussen de namen van de variabelen om aan te geven dat we ook de tussenliggende variabelen willen aanpassen. Het is hierbij natuurlijk wel belangrijk dat de volgorde van de variabelen niet is aangepast.\n\nwordbank_dutch &lt;- wordbank_dutch %&gt;% \n  mutate(across(item_id:category, as.factor))\n\nwordbank_dutch\n\n# A tibble: 3,969 × 5\n   item_id item_definition category month proportion\n   &lt;fct&gt;   &lt;fct&gt;           &lt;fct&gt;    &lt;dbl&gt;      &lt;dbl&gt;\n 1 1       au/ai(pijn)     sounds       8       0   \n 2 1       au/ai(pijn)     sounds       9       0   \n 3 1       au/ai(pijn)     sounds      10       0   \n 4 1       au/ai(pijn)     sounds      11       0.11\n 5 1       au/ai(pijn)     sounds      12       0.14\n 6 1       au/ai(pijn)     sounds      13       0.17\n 7 1       au/ai(pijn)     sounds      14       0.14\n 8 1       au/ai(pijn)     sounds      15       0.17\n 9 1       au/ai(pijn)     sounds      16       0.4 \n10 2       behbeh(schaap)  sounds       8       0   \n# ℹ 3,959 more rows\n\n\n\n\n5.1.2 De grafiek maken\nDe data staan er nu goed bij en we kunnen aan de slag met onze grafiek. Elke grafiek begint met een aanroep van de functie ggplot() waarin we moeten aangeven op basis van welke datatabel we een grafiek willen maken.\n\nggplot(data = wordbank_dutch)\n\n\n\n\nFiguur 5.2: Een leeg canvas\n\n\n\n\nDit levert een leeg canvas op (Figuur 5.2). We hebben ggplot namelijk nog niet verteld welke variabelen uit de dataset we op welke manier willen weergeven in de grafiek. Dit laatste noemen we een mapping van variabelen naar eigenschappen van de grafiek. Die eigenschappen worden aesthetics genoemd (aes in het kort). Je moet hierbij denken aan de x-as, y-as, kleuren en vormen. Zo zien we in onze doelgrafiek dat de variabele month is afgebeeld op de x-as, de variabele proportion op de y-as en dat de variabele item_definition tot uitdrukking komt in de kleur en de vorm van symbolen. Laten we beginnen met de mapping van variabelen op de x-as en de y-as.\n\nggplot(data = wordbank_dutch,\n       mapping = aes(x = month, y = proportion))\n\n\n\n\nFiguur 5.3: Mapping van variabelen op de x-as en de y-as\n\n\n\n\nNu zien we in Figuur 5.3 de namen van de variabelen verschijnen op de assen en zien we dat ook het bereik van beide variabelen is weergegeven, 0-1 voor proportion op de y-as en 8-16 voor month op de x-as. Voor we verder gaan, versimpelen we de code eerst met de pipe-operator die we in het vorige hoofdstuk hebben leren kennen. Onderstaande code geeft je het standaard begin voor elke grafiek: een dataset die naar ggplot wordt doorgezet en in aes() een specificatie van de mapping van variabelen die moeten worden afgebeeld.\n\nwordbank_dutch %&gt;% \n  ggplot(aes(x = month, y = proportion))\n\nWe zien nu al welke variabelen er afgebeeld gaan worden, maar we zien de data zelf nog niet. Om die zichtbaar te maken moeten we een geom toevoegen als een nieuwe laag aan onze grafiek. We hebben hier de keuze uit een groot aantal mogelijke type grafieken, denk aan lijnen, punten, staven. Elke dataset vraagt om zijn eigen aanpak. Dus het is noodzakelijk om vooraf goed na te denken over wat je precies wilt laten zien. Het beste kun je eerst op papier een schets maken voor jezelf.\nIn onze doelgrafiek wordt er gebruik gemaakt van zowel punten als lijnen. We beginnen met de punten. Hiervoor gebruiken we geom_point(). Let op: om een laag toe te voegen aan een grafiek gebruiken we na de aanroep van ggplot() een +. Deze + moet aan het eind van de regel komen, anders krijg je een error.\n\nwordbank_dutch %&gt;% \n  ggplot(aes(x = month, y = proportion)) +\n  geom_point()\n\n\n\n\nFiguur 5.4: De datapunten zijn zichtbaar geworden dankzij geom_point().\n\n\n\n\nWe hebben in Figuur 5.4 veel meer stippen dan we in onze doelgrafiek zien. Dit komt, omdat we de data van alle woorden in de vragenlijst naar ggplot() hebben gestuurd terwijl we de gegevens van maar vier woorden willen laten zien. We moeten onze dataset dus eerst nog filteren voor we de grafiek gaan maken. We maken hiervoor eerst een vector dutch_words aan met de relevante woorden erin. We filteren ook proporties van 0 eruit om de data iets overzichtelijker te maken.\n\ndutch_words &lt;- c(\"mama\", \"papa\", \"oma\", \"opa\")\n\n\nwordbank_dutch %&gt;%\n  filter(item_definition %in% dutch_words,\n         proportion &gt; 0) %&gt;% \n  ggplot(aes(x = month, y = proportion)) +\n  geom_point()\n\n\n\n\nFiguur 5.5: Alleen de datapunten van de doelwoorden zijn zichtbaar.\n\n\n\n\nWe zien nu de datapunten (Figuur 5.5), maar nog niet bij welk woord ze horen. Alle punten hebben dezelfde vorm en kleur. Als we de vorm en kleur willen laten variëren op basis van het woord waar het datapunt bijhoort, dan moeten we een nieuwe mapping maken, namelijk van de variabele item_definition (het woord). Zoals hierboven gezien, wordt die mapping gemaakt binnen aes(). We kunnen dit op twee niveaus doen: (i) op het niveau van ggplot() en/of (ii) op het niveau van het geom. Ter illustratie laten we het hier op beide niveaus zien: de mapping naar vorm (shape) maken we op het niveau van ggplot() en de mapping naar kleur op het niveau van geom_point().\n\nwordbank_dutch %&gt;%\n  filter(item_definition %in% dutch_words,\n         proportion &gt; 0) %&gt;% \n  ggplot(aes(x = month, y = proportion, shape = item_definition)) +\n  geom_point(aes(color = item_definition))\n\n\n\n\nFiguur 5.6: Dankzij een mapping naar shape en color is nu zichtbaar bij welke woorden de datapunten horen.\n\n\n\n\nDit lijkt er al meer op (Figuur 5.6). De grootte van de symbolen is alleen kleiner dan in onze doelgrafiek. Dit kunnen we aanpassen door het argument size toe te voegen aan geom_point() (Figuur 5.7). Omdat het hier niet gaat om de mapping van een variabele, maar om het toekennen van een constante waarde (de waarde ‘3’), voegen we dit argument toe buiten aes().\n\nwordbank_dutch %&gt;%\n  filter(item_definition %in% dutch_words,\n         proportion &gt; 0) %&gt;% \n  ggplot(aes(x = month, y = proportion, shape = item_definition)) +\n  geom_point(aes(color = item_definition), size = 3)\n\n\n\n\nFiguur 5.7: De grootte van de datapunten is aangepast met size.\n\n\n\n\nLet op: wanneer je een variabele meegeeft als argument buiten aes() dan gebeuren er andere dingen dan je verwacht (je zult waarschijnlijk een error krijgen). Bedenk dus altijd goed of je een eigenschap van de grafiek wil laten variëren op basis van een variabele: zo ja, dan moet dit binnen aes() gebeuren, zo niet, dan moet het buiten aes().\nLaten we nu de lijnen toevoegen, die ontbreken nog. Hiervoor gebruiken we het geom geom_line(). Deze voegen we met een + toe aan onze bestaande grafiek.\n\nwordbank_dutch %&gt;%\n  filter(item_definition %in% dutch_words,\n         proportion &gt; 0) %&gt;% \n  ggplot(aes(x = month, y = proportion, shape = item_definition)) +\n  geom_point(aes(color = item_definition), size = 3) +\n  geom_line()\n\n\n\n\nFiguur 5.8: Er zijn nu ook lijnen zichtbaar dankzij geom_line()\n\n\n\n\nWe zien lijnen in Figuur 5.8, maar er gaan twee dingen mis: (i) de lijnen hebben niet de juiste kleur, ze zijn allemaal zwart, en (ii) als je goed kijkt, zie je dat de lijnen over de punten heenlopen, dat ziet er minder fraai uit. Dit laatste is makkelijk op te lossen door de volgorde van de geoms om te draaien (Figuur 5.9).\n\nwordbank_dutch %&gt;%\n  filter(item_definition %in% dutch_words,\n         proportion &gt; 0) %&gt;% \n  ggplot(aes(x = month, y = proportion, shape = item_definition)) +\n  geom_line() +\n  geom_point(aes(color = item_definition), size = 3)\n\n\n\n\nFiguur 5.9: Door de volgorde van geoms om te draaien komen de punten boven de lijnen te liggen.\n\n\n\n\nDit laat zien dat je het maken van grafieken in ggplot (tot een bepaalde hoogte) kunt vergelijken met het schilderen op een doek (canvas): wat je het laatst toevoegt is het best zichtbaar. Een ggplot is letterlijk opgebouwd uit lagen (layers).\nHet eerste probleem (dat de lijnen zwart zijn) laat iets heel fundamenteels zien over de mapping in aes(). Zoals we eerder hebben gezien, kun je deze mapping zowel op het niveau van ggplot() als op het niveau van het geom specificeren. Dit maakt een wezenlijk verschil. Mappings op het niveau van ggplot() worden overgeërfd door latere geoms, tenzij de mapping op het niveau van het geom wordt overschreven. Mappings op het niveau van een geom zijn alleen beschikbaar op dat niveau en dus niet toegankelijk voor andere geoms. Dat is waar het in onze grafiek misgaat. We hebben kleur gespecificeerd op het niveau van geom_point() en daardoor is deze mapping niet toegankelijk voor geom_line(). Wanneer we deze mapping verhuizen naar het hoogste niveau van ggplot() dan zien we dat de lijnen de juiste kleur krijgen (Figuur 5.10).\n\nwordbank_dutch %&gt;%\n  filter(item_definition %in% dutch_words,\n         proportion &gt; 0) %&gt;% \n  ggplot(aes(x = month, y = proportion, \n             color = item_definition, shape = item_definition)) +\n  geom_line() +\n  geom_point(size = 3)\n\n\n\n\nFiguur 5.10: Door de mapping van color op het niveau van de functie ggplot() te zetten, wordt deze toegankelijk voor alle volgende geoms.\n\n\n\n\nHet is dus heel belangrijk om vooraf goed te bedenken waar je een mapping van een variabele naar een eigenschap van de grafiek (aesthetics) allemaal terug wilt zien. Om het belang van de goede plek van de mapping te onderstrepen, laten we zien wat er gebeurt als we beide mappings (color en shape) van ggplot() verhuizen naar het niveau van geom_point().\n\nwordbank_dutch %&gt;%\n  filter(item_definition %in% dutch_words,\n         proportion &gt; 0) %&gt;% \n  ggplot(aes(x = month, y = proportion)) +\n  geom_line() +\n  geom_point(aes(color = item_definition, shape = item_definition), size = 3)\n\n\n\n\nFiguur 5.11: Door verplaatsing van de mapping naar het laagste geom zijn de lijnen helemaal de weg kwijt.\n\n\n\n\nDe lijn verliest niet alleen zijn kleur, maar is nu ook helemaal de weg kwijt. Dit komt doordat geom_line() nu niet meer weet welke punten bij elkaar horen. Eerder krijg het geom die informatie nog overgeërfd via de mapping van shape in ggplot(), maar die is nu verdwenen. Om dit op te lossen moeten we die mapping weer terugzetten of we moeten de groepering expliciet maken op het niveau van ggplot(). Dat laatste doen we door item_definition te mappen op group (Figuur 5.12).\n\nwordbank_dutch %&gt;%\n  filter(item_definition %in% dutch_words,\n         proportion &gt; 0) %&gt;% \n  ggplot(aes(x = month, y = proportion, group = item_definition)) +\n  geom_line() +\n  geom_point(aes(color = item_definition, shape = item_definition), size = 3)\n\n\n\n\nFiguur 5.12: Het herstellen van de orde door mapping van group.\n\n\n\n\nDit laat zien dat er dus meerdere manieren zijn om tot een grafiek te komen. Stelregel is daarbij dat als je een bepaalde mapping van een variabele naar een eigenschap van de grafiek op meerdere plekken tot uitdrukking wilt laten komen, dat je die mapping dan zo hoog mogelijk moet specificeren (dus op het niveau van ggplot()). In ons geval is dit dus de beste oplossing:\n\nwordbank_dutch %&gt;%\n  filter(item_definition %in% dutch_words,\n         proportion &gt; 0) %&gt;% \n  ggplot(aes(x = month, y = proportion, \n             color = item_definition, shape = item_definition)) +\n  geom_line() +\n  geom_point(size = 3)\n\n\n\n\nFiguur 5.13: Mappings op de beste plek voor deze grafiek\n\n\n\n\nDe data in de grafiek in Figuur 5.13 zien er nu goed uit. We moeten alleen het uiterlijk van de grafiek nog aanpassen. We veranderen eerst de achtergrondkleur. Dit doen we door de theme aan te passen. Er zijn binnen ggplot meerdere themes beschikbaar. We gebruiken hier theme_minimal() dat een witte achtergrond met lichte rasterlijnen geeft (Figuur 5.14). Het getal (13) geeft de basisgrootte van de titels in de grafiek.\n\nwordbank_dutch %&gt;%\n  filter(item_definition %in% dutch_words,\n         proportion &gt; 0) %&gt;% \n  ggplot(aes(x = month, y = proportion, \n             color = item_definition, shape = item_definition)) +\n  geom_line() +\n  geom_point(size = 3) +\n  theme_minimal(13)\n\n\n\n\nFiguur 5.14: Met theme_minimal() krijgt de grafiek een witte achtergrond met lichte rasterlijnen.\n\n\n\n\nDe laatste stap is om de namen van de assen en de legenda aan te passen en een titel en ondertitel toe te voegen. Dit doen we via labs() (Figuur 5.15).\n\nwordbank_dutch %&gt;%\n  filter(item_definition %in% dutch_words,\n         proportion &gt; 0) %&gt;% \n  ggplot(aes(x = month, y = proportion, \n             color = item_definition, shape = item_definition)) +\n  geom_line() +\n  geom_point(size = 3) +\n  theme_minimal(13) +\n  labs(\n    x = \"leeftijd in maanden\",\n    y = \"proportie kinderen die woord produceert\",\n    shape = \"woord\",\n    color = \"woord\",\n    title = \"Mama of papa?\",\n    subtitle = \"ontwikkeltrajecten van woorden voor familieleden in Nederlandse kindertaal\"\n  )\n\n\n\n\nFiguur 5.15: Namen van assen en de legenda kun je aanpassen via labs().\n\n\n\n\nHiermee is het ons stapsgewijs gelukt om onze doelgrafiek (Figuur 5.1) volledig na te maken. Voordat je verder leest: check of je elke regel code in het laatste codeblok voor jezelf uit kunt leggen. Zo niet, kijk dan eerst nog even terug in het hoofdstuk."
  },
  {
    "objectID": "grafieken.html#sec-grafieken-soorten",
    "href": "grafieken.html#sec-grafieken-soorten",
    "title": "5  Grafieken maken",
    "section": "5.2 Soorten grafieken",
    "text": "5.2 Soorten grafieken\nHieronder geven we alvast een voorbeeld van de verschillende grafieken die je gaat tegenkomen en lichten we er in het voorbijgaan nog wat functionaliteiten van ggplot2 uit. Dit gaat in vogelvlucht. Veel van de dingen die je hier ziet langskomen zullen we in latere hoofdstukken nog verder uitwerken. Probeer voor nu steeds voor jezelf helder te krijgen wat de code doet.\n\n5.2.1 staafdiagrammen\nVoor staafdiagrammen gebruiken we de geoms geom_bar() of geom_col(). Het verschil is dat de eerste zelf tellingen uitvoert (Figuur 5.16) en de tweede (Figuur 5.17) tellingen gebruikt die je eerst zelf hebt aangemaakt. De kleur van een staaf pas je aan via de aesthetic fill en color wordt gebruikt voor de rand om de staaf heen. In onderstaande figuur hebben we deze vastgezet op een bepaalde kleur (cornflowerblue). Dit is een van de standaardkleuren beschikbaar in R. Zie colours() voor een overzicht van kleurnamen die je kunt gebruiken.\n\n# Aanmaken van subset van woordcategorieën die we willen gaan tellen\ndutch_categories &lt;- c(\"animals\", \"sounds\", \"people\", \"vehicles\", \"toys\", \"food_drink\", \"body_parts\")\n\n\nwordbank_dutch %&gt;%\n  filter(category %in% dutch_categories) %&gt;% \n  ggplot(aes(x = category)) +\n  geom_bar(fill = \"cornflowerblue\") +\n  theme_minimal(13) +\n  labs(\n   x = \"categorie\",\n   y = \"aantal voorkomens\"\n  )\n\n\n\n\nFiguur 5.16: Een staafdiagram met geom_bar() waarbij R zelf de tellingen uitvoert\n\n\n\n\n\nwordbank_dutch %&gt;%\n  filter(category %in% dutch_categories) %&gt;% \n  count(category) %&gt;% # tellen hoe vaak elke categorie voorkomt in de data\n  ggplot(aes(x = category, y = n)) +\n  geom_col(fill = \"cornflowerblue\") +\n  theme_minimal(13) +\n  labs(\n   x = \"categorie\",\n   y = \"aantal voorkomens\"\n  )\n\n\n\n\nFiguur 5.17: Zelfde staafdiagram maar nu met geom_col() waarbij we eerst zelf moeten tellen.\n\n\n\n\nOm een liggend staafdiagram te maken (Figuur 5.18), vaak beter leesbaar, kun je de functie coord_flip() toevoegen.\n\nwordbank_dutch %&gt;%\n  filter(category %in% dutch_categories) %&gt;% \n  ggplot(aes(x = category)) +\n  geom_bar(fill = \"cornflowerblue\") +\n  coord_flip() + # omdraaien van de assen\n  theme_minimal(13) +\n  labs(\n   x = \"categorie\",\n   y = \"aantal voorkomens\"\n  )\n\n\n\n\nFiguur 5.18: Een liggend staafdiagram gemaakt met coord_flip()\n\n\n\n\nBij geom_col() (en andere geoms waarbij een x en/of y gespecificeerd kan worden) kun je voor hetzelfde resultaat ook de mapping van variabelen naar x en y omdraaien i.p.v. coord_flip() te gebruiken. Dit kan nuttig zijn als je ook een andere coord_-functie wilt gebruiken.\n\nwordbank_dutch %&gt;%\n  filter(category %in% dutch_categories) %&gt;% \n  count(category) %&gt;% \n  ggplot(aes(x = n, y = category)) + # x en y zijn gewisseld t.o.v. eerder\n  geom_col(fill = \"cornflowerblue\") +\n  theme_minimal(13) +\n  labs(\n   x = \"categorie\",\n   y = \"aantal voorkomens\"\n  )\n\n\n\n\nFiguur 5.19: Een liggend staafdiagram gemaakt door de mapping naar de assen te verwisselen\n\n\n\n\n\n\n5.2.2 dotplots en scatterplots\nEerder in dit hoofdstuk hebben we gezien dat we geom_point() kunnen gebruiken om dotplots of scatterplots te maken. Hierbij geeft elk punt een observatie in de data weer. In Figuur 5.20 is voor elk kind in de dataset wordbank_dutch de proportie woorden die het kind kende toen de vragenlijst werd ingevuld uitgezet tegen de leeftijd in maanden op dat moment.\n\nwordbank_dutch %&gt;% \n  ggplot(aes(x = month, y = proportion)) +\n  geom_point(color = \"pink2\") +\n  theme_minimal(13)\n\n\n\n\nFiguur 5.20: Een scatterplot\n\n\n\n\nWanneer er veel observaties worden afgebeeld loop je bij dit soort grafieken het risico op overplotting, veel datapunten worden dan over elkaar heen afgebeeld. Hierdoor is het aantal observaties niet goed zichtbaar. Je ziet namelijk geen verschil tussen bijvoorbeeld 1 observatie of 10 observaties met dezelfde waardes. Om dit probleem (enigszins) tegen te gaan kun je doorzichtigheid van punten veranderen. Wanneer je punten doorzichtiger maakt, zullen plekken waar zich veel observaties ophouden uiteindelijk donkerder worden dan plekken met weinig observaties. De doorzichtigheid van geoms kun je instellen via de aesthetic alpha. De alpha-waarde ligt tussen 0 en 1. In Figuur 5.21 hebben we die ingesteld op de waarde .4. Vergelijk dit figuur maar eens met Figuur 5.20.\n\nwordbank_dutch %&gt;% \n  ggplot(aes(x = month, y = proportion)) +\n  geom_point(color = \"pink2\", alpha = .4) +\n  theme_minimal(13)\n\n\n\n\nFiguur 5.21: Door de alpha-waarde van de punten aan te passen wordt duidelijker waar zich meerdere observaties bevinden.\n\n\n\n\nEen alternatief om overplotting tegen te gaan is door gebruik te maken van jitter. Hierbij wordt er wat ruis toegevoegd aan elke observatie en zal deze iets van positie veranderen. Je kunt hiervoor geom_jitter() gebruiken waarbij je met het argument width aangeeft hoeveel ruis je wilt toevoegen (tussen 0 en 1). Je kunt deze functie ook gebruiken in combinatie met het toevoegen van doorzichtigheid, zoals in Figuur 5.22. Voorzichtigheid is wel geboden bij dit geom, omdat het de data enigszins aanpast. Dat zie je bijvoorbeeld ook als je naar de assen in Figuur 5.22 kijkt. Die geven nu continue waarden weer, terwijl de variabele month discreet gemeten is.\n\nwordbank_dutch %&gt;% \n  ggplot(aes(x = month, y = proportion)) +\n  geom_jitter(color = \"pink2\", alpha = .4, width = .2) +\n  theme_minimal(13)\n\n\n\n\nFiguur 5.22: Met geom_jitter() kun je de positie van de punten enigszins aanpassen. Hierdoor wordt duidelijker waar zich meerdere observaties bevinden.\n\n\n\n\nOm het verband tussen twee variabelen in een scatterplot zichtbaar te maken kun je een trendlijn (of regressielijn) toevoegen. Dit doe je met het geom geom_smooth(). Door het argument method = \"lm\" mee te geven zorg je dat er een rechte lijn wordt getrokken door de datapunten (Figuur 5.23).\n\nwordbank_dutch %&gt;% \n  ggplot(aes(x = month, y = proportion)) +\n  geom_point(color = \"pink2\", alpha = .4) +\n  geom_smooth(method = \"lm\") +\n  theme_minimal(13)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\nFiguur 5.23: Een trendlijn kun je toevoegen met geom_smooth.\n\n\n\n\nJe kunt dotplots met geom_point() ook gebruiken om berekende statistieken, zoals het gemiddelde per categorie, weer te geven (Figuur 5.24). Hiervoor zul je wel eerst zelf deze statistieken moeten berekenen, bijv. met een combinatie van de functies group_by() en summarize(). Meer hierover in Hoofdstuk 7. Met de toevoeging ylim() hebben we in Figuur 5.24 het bereik van de y-as ingeperkt van 0 tot 0.2.\n\nwordbank_dutch %&gt;%\n  filter(category %in% c(\"animals\", \"sounds\", \"toys\")) %&gt;% \n  group_by(category) %&gt;% \n  summarize(mean_proportion = mean(proportion)) %&gt;% \n  ggplot(aes(x = category, y = mean_proportion)) +\n  geom_point(aes(color = category), size = 3, show.legend = FALSE) +\n  ylim(0, .2) + #inperken van bereik y-as\n  labs(y = \"mean proportion\") +\n  theme_minimal(13)\n\n\n\n\nFiguur 5.24: Een dotplot met geom_point() waarbij een gemiddelde waarde per categorie wordt weergegeven\n\n\n\n\n\n\n\nTot slot, soms, en zeker in taalwetenschappelijk onderzoek, wil je in plaats van punten woorden zichtbaar maken. Het geom geom_text() geeft je die mogelijkheid. In Figuur 5.25 hebben we dit toegepast op onze doelgrafiek aan het begin van het hoofdstuk. Onder theme() hebben we hier bovendien toegevoegd dat we de legenda willen verwijderen, want met de woorden in de grafiek is deze overbodig geworden.\n\nwordbank_dutch %&gt;%\n  filter(item_definition %in% dutch_words,\n         proportion &gt; 0) %&gt;% \n  ggplot(aes(x = month, y = proportion, color = item_definition)) +\n  geom_line() +\n  geom_text(aes(label = item_definition), size = 3) +\n  theme_minimal(13) +\n  labs(\n    x = \"leeftijd in maanden\",\n    y = \"proportie kinderen die woord produceert\",\n    title = \"Mama of papa?\",\n    subtitle = \"ontwikkeltrajecten van woorden voor familieleden in Nederlandse kindertaal\"\n  ) + \n  theme(legend.position = \"none\") # legenda verwijderen\n\n\n\n\nFiguur 5.25: Met geom_text() kun je woorden zichtbaar maken.\n\n\n\n\n\n\n5.2.3 verdelingen zichtbaar maken\nEen verdeling van een numerieke variabele kun je zichtbaar maken met een histogram via geom_histogram() (Figuur 5.26). Net als bij geom_bar() (en geom_col()) kun je hier de kleur van de staven en de rand aanpassen met respectievelijk fill en color.\n\nwordbank_dutch %&gt;%\n  filter(proportion &gt; 0) %&gt;% \n  ggplot(aes(x = proportion)) +\n  geom_histogram(binwidth = .1, fill = \"seagreen2\", color = \"white\") +\n  theme_minimal(13)\n\n\n\n\nFiguur 5.26: Een histogram gemaakt met geom_histogram()\n\n\n\n\nEen alternatief is een density plot waarvoor geom_density() gebruikt wordt. Dit levert een wat vloeiendere variant op van een histogram (Figuur 5.27).\n\nwordbank_dutch %&gt;%\n  filter(proportion &gt; 0) %&gt;% \n  ggplot(aes(x = proportion)) +\n  geom_density(color = \"seagreen4\", fill = \"seagreen2\", alpha = .2) +\n  theme_minimal(13)\n\n\n\n\nFiguur 5.27: Een density plot via geom_density()\n\n\n\n\nHet laatste alternatief voor verdelingen van numerieke variabelen is het boxplot (Figuur 5.28). Zoals je misschien al kon raden, hebben we hiervoor geom_boxplot() tot onze beschikking. Boxplots zullen we uitgebreider bespreken in Hoofdstuk 7.\n\nwordbank_dutch %&gt;%\n  filter(proportion &gt; 0) %&gt;% \n  ggplot(aes(x = proportion)) +\n  geom_boxplot(color = \"seagreen4\", fill = \"seagreen2\", alpha = .2) +\n  theme_minimal(13)\n\n\n\n\nFiguur 5.28: Met geom_boxplot() kun je een boxplot maken.\n\n\n\n\nSoms wil je dezelfde grafiek maken voor verschillende levels van een andere variabele. Hiervoor kun je facet_wrap() gebruiken. Het resultaat is een trellis plot waarbij ieder level zijn eigen grafiek krijgt. In Figuur 5.29 is dit gedaan om voor 3 verschillende dierengeluiden die kinderen zouden kunnen nadoen een boxplot te maken.\n\n# Aanmaken van subset van dierengeluiden\nanimal_sounds &lt;- c(\"behbeh(schaap)\", \"beu/boe/meu/moeh(koe)\", \"kwakkwak(eend)\")\n\n\nwordbank_dutch %&gt;% \n  filter(item_definition %in% animal_sounds) %&gt;% \n  ggplot(aes(y = proportion)) +\n  geom_boxplot() +\n  facet_wrap(~ item_definition) +\n  labs(title = \"Dierengeluiden\") +\n  theme_minimal(13) +\n  theme(axis.text.x = element_blank()) # verwijderen getallen op de x-as\n\n\n\n\nFiguur 5.29: De toevoeging facet_wrap() maakt het mogelijk om dezelfde grafiek voor verschillende levels van een variabele te produceren."
  },
  {
    "objectID": "grafieken.html#verder-leren",
    "href": "grafieken.html#verder-leren",
    "title": "5  Grafieken maken",
    "section": "Verder leren",
    "text": "Verder leren\n\nIn hoofdstuk 1 van Wickham et al. (2023) vind je een andere uitwerking van veel functies die in dit hoofdstuk aan bod zijn gekomen.\nHoofdstuk 3 van Healy (2019) geeft een goede uiteenzetting van de anatomie van ggplots.\nhet ggplot2 cheatsheet geeft een overzicht van de werking van ggplot2. Voor nu misschien nog wat overweldigend, maar later zeker de moeite waard.\n\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2de dr.). O’Reilly. https://r4ds.hadley.nz/\n\nHealy, K. (2019). Data Visualisation: A Practical Introduction. Princeton University Press. https://socviz.co/\nNu zou je in staat moeten zijn Practicum 3 te maken."
  },
  {
    "objectID": "factoren.html#eigenaardigheden-van-barplots",
    "href": "factoren.html#eigenaardigheden-van-barplots",
    "title": "6  Categorische variabelen",
    "section": "6.1 Eigenaardigheden van barplots",
    "text": "6.1 Eigenaardigheden van barplots\nDe beschrijvende statistieken van categorische variabelen worden traditioneel zichtbaar gemaakt met staafdiagrammen, hoewel we hier ook punten zouden kunnen gebruiken. In ggplot gebruiken we hiervoor het geom geom_bar() of geom_col(). Als je de tellingen door R wilt laten uitvoeren tijdens het maken van de grafiek kies je voor geom_bar().\n\nwordbank_demo_romance %&gt;%\n  ggplot(aes(x = language)) +\n  geom_bar(fill = \"wheat\") +\n  theme_minimal(13)\n\n\n\n\nWe hebben hier alleen een variabele meegegeven voor op de x-as, geom_bar berekent achter de schermen zelf de aantallen per categorie voor op de y-as. De standaard is hier stat(count) en deze default zien we terug in de naam van de y-as. Dat geom_bar() puur het aantal voorkomens in de dataset telt, zien we duidelijk als we onze datatabel waarin we zelf de aantallen hebben berekend als input meegeven. We krijgen dan iets dat op het eerste gezicht mogelijk onverwacht is:\n\ncounts_romance %&gt;% \n  ggplot(aes(x = language)) +\n  geom_bar(fill = \"wheat\") +\n  theme_minimal(13)\n\n\n\n\nDit staafdiagram laat zien dat elke taal één keer voorkomt in de dataset. Dit klopt inderdaad, want de datatabel telt voor elke taal één regel. Er zijn twee opties om onze eigen telling te laten zien (i) de statistiek van geom_bar() veranderen, (ii) het geom geom_col() gebruiken.\nZoals gezegd rekent geom_bar() standaard met de statistiek count. Deze statistiek kun je veranderen in het geom door stat = te specificeren als identity. Het geom gaat nu niet meer zelf tellen, maar gebruikt de waarden uit de variabele n in onze eigen telling. We moeten dan wel bij de aesthetics mapping van ggplot aangeven dat we deze variabele n willen afbeelden op de y-as:\n\ncounts_romance %&gt;% \n  ggplot(aes(x = language, y = n)) +\n  geom_bar(stat = \"identity\", fill = \"wheat\") +\n  theme_minimal(13)\n\n\n\n\nHet tweede alternatief geom_col() is eigenlijk een afkorting voor geom_bar(stat = \"identity\"). Om dit geom te gebruiken moet je dus altijd eerst zelf de tellingen uitvoeren. Die geef je mee als variabele. Dit geom neemt dus altijd twee variabelen als argument onder aes(). Het geom geom_col() geeft je volledige controle over welke getallen worden afgebeeld. Je moet ze alleen wel eerst zelf berekenen. We zien dat dit geom precies dezelfde grafiek oplevert. We hebben alleen de kleur aangepast om de twee varianten uit elkaar te houden.\n\nwordbank_demo_romance %&gt;% \n  count(language) %&gt;% \n  ggplot(aes(x = language, y = n)) +\n  geom_col(fill = \"peachpuff2\") +\n  theme_minimal(13)\n\n\n\n\nAangezien je geom_col() zelf de getallen die je wilt afbeelden moet meegeven is het ook meteen te gebruiken voor proporties. We veranderen hiervoor alleen de mapping van de y-variabele y = proportion in aes() van ggplot():\n\ncounts_romance %&gt;% \n  ggplot(aes(x = language, y = proportion)) +\n  geom_col(fill = \"peachpuff2\") +\n  theme_minimal(13)"
  },
  {
    "objectID": "factoren.html#herordenen-van-levels",
    "href": "factoren.html#herordenen-van-levels",
    "title": "6  Categorische variabelen",
    "section": "6.2 Herordenen van levels",
    "text": "6.2 Herordenen van levels\nIn al onze grafieken zijn de talen op de x-as in alfabetische volgorde afgebeeld. Dit komt omdat R bij het aanmaken een factor met as.factor() de levels van de factor alfabetisch ordent. De grafiek volgt dus precies de informatie in de factor. Dit is alleen niet wat we altijd willen. Wanneer er geen logische volgorde in een factor zit (wat bijvoorbeeld wel zo is als het om een geordende factor (of ordinale variabele) gaat, zie Paragraaf 6.2.1) is alfabetisch niet altijd de handigste optie om inzicht in de data te krijgen. Zeker wanneer er veel factorlevels zijn, kan dit ervoor zorgen dat de grafiek nogal chaotisch oogt. Om dit te verbeteren kunnen we de levels ordenen op basis van hun waarde (aantal keer dat het level voorkomt of de proportie). In andere woorden we ordenen van van groot naar klein (of van klein naar groot). Om dit voor elkaar te krijgen moeten we de levels anders ordenen. Het heeft dus geen zin de data in volgorde van groot naar klein te zetten. Als we dat namelijk doen, dan krijgen we nog steeds dezelfde grafiek:\n\ncounts_romance %&gt;% \n  arrange(n)\n\n# A tibble: 4 × 3\n  language                  n proportion\n  &lt;fct&gt;                 &lt;int&gt;      &lt;dbl&gt;\n1 Spanish (European)      593       0.11\n2 Italian                 752       0.13\n3 French (French)        1233       0.22\n4 Portuguese (European)  3012       0.54\n\n\n\ncounts_romance %&gt;% \n  arrange(n) %&gt;% \n  ggplot(aes(x = language, y = proportion)) +\n  geom_col(fill = \"peachpuff2\") +\n  theme_minimal(13)\n\n\n\n\nHet package forcats dat onderdeel is van tidyverse en dus meteen wordt geladen als je library(tidyverse) aanroept (je hoeft het dus niet apart aan te roepen) heeft een groot aantal functies waarmee je factoren kunt manipuleren. Deze functies beginnen allemaal met fct_. Zo ordent de functie fct_infreq de levels op basis van het aantal voorkomens in de ruwe data met het level dat het meest voorkomt eerst. Om deze ordening zichtbaar te maken moeten we deze toepassen binnen een mutate(). Let op: in onderstaande code veranderen we de ordening niet in de oorspronkelijke datatabel wordbank_demo_romance alleen in de tabel die door middel van pipes naar de functie ggplot() wordt gestuurd. Willen we het blijvend veranderen dan moeten we de mutate-stap toewijzen aan de datatabel met &lt;- en vervolgens deze datatabel naar ggplot() sturen.\n\nwordbank_demo_romance %&gt;% \n  mutate(language = fct_infreq(language)) %&gt;% \n  ggplot(aes(x = language)) +\n  geom_bar(fill = \"wheat\") +\n  theme_minimal(13)\n\n\n\n\nWil je de volgorde omdraaien naar van klein naar groot dan kun je fct_rev() gebruiken. We passen deze hier in een keer toe samen met fct_infreq() door de pipe te gebruiken binnen mutate().\n\nwordbank_demo_romance %&gt;% \n  mutate(language = language %&gt;% fct_infreq() %&gt;% fct_rev()) %&gt;% \n  ggplot(aes(x = language)) +\n  geom_bar(fill = \"wheat\") +\n  theme_minimal(13)\n\n\n\n\nEr is ook de functie fct_reorder() die deze twee stappen in een keer kan uitvoeren. Deze functie neemt twee argumenten: (i) de variabele waarvan je de levels wilt aanpassen en (ii) de variabele op basis waarvan je de levels wilt ordenen (hier n).\n\nwordbank_demo_romance %&gt;% \n  count(language) %&gt;%\n  mutate(language = fct_reorder(language, n)) %&gt;% \n  ggplot(aes(x = language, y = n)) +\n  geom_col(fill = \"peachpuff2\") +\n  theme_minimal(13)\n\n\n\n\nFiguur 6.1: Staafdiagram met de x-as geordend van klein naar groot.\n\n\n\n\nOok in dit geval kunnen we het eerste argument (language) buiten de functie zetten met een pipe (in regel 3). Door de mapping van x en y om te wisselen (regel 4) maken we er meteen een liggend staafdiagram van. Deze optie maakt het vaak makkelijker om verschillen te zien, zeker als die niet erg groot zijn.\n\nwordbank_demo_romance %&gt;% \n  count(language) %&gt;%\n  mutate(language = language %&gt;% fct_reorder(n)) %&gt;% \n  ggplot(aes(x = n, y = language)) +\n  geom_col(fill = \"peachpuff2\") +\n  theme_minimal(13)\n\n\n\n\nHet draaien van de grafiek kan ook met de functie coord_flip(). Deze is alleen te gebruiken als je niet al een andere coord_-functie toepast in je grafiek. Wanneer je dat wel doet, zul je de variabelen moeten verwisselen in aes().\n\nwordbank_demo_romance %&gt;% \n  count(language) %&gt;%\n  mutate(language = fct_reorder(language, n)) %&gt;% \n  ggplot(aes(x = language, y = n)) +\n  geom_col(fill = \"peachpuff2\") +\n  coord_flip() +\n  theme_minimal(13)\n\n\n\n\n\n6.2.1 Een geordende factor\nBij geordende factoren kun je niet vrijelijk de levels herordenen, omdat de ordening hier een betekenis heeft. Laten we dit eens bekijken aan de hand van de variabele birth_order. Zoals de naam als zegt gaat het hier om een geordende factor. De variabele geeft namelijk de volgorde van geboorte in het gezin aan. We maken een eerste staafdiagram van deze variabele:\n\nwordbank_demo_romance %&gt;% \n  ggplot(aes(x = birth_order)) +\n  geom_bar(fill = \"olivedrab4\") +\n  theme_minimal(13)\n\n\n\n\nDe hoge staaf bij NA geeft aan dat deze informatie voor veel kinderen in de dataset niet geregistreerd is. Daarnaast valt vooral op dat de levels alfabetisch zijn geordend met ‘Fifth’ als eerste en niet First. Dit weerspiegelt de manier waarop R de ordening van de levels heeft geregistreerd:\n\nlevels(wordbank_demo_romance$birth_order)\n\n[1] \"Fifth\"  \"First\"  \"Fourth\" \"Second\" \"Sixth\"  \"Third\" \n\n\nDit gaan we aanpassen. Om onze code overzichtelijk te houden, maken we eerst een vector aan met de juiste ordening:\n\nbirth_order_levels &lt;- c(\"First\", \"Second\", \"Third\", \"Fourth\", \"Fifth\", \"Sixth\")\n\nMet fct_relevel() kunnen we deze ordening nu toepassen op de variabele birth_order. Nadat de ordening is toegepast sturen we de datatabel naar ggplot().\n\nwordbank_demo_romance %&gt;% \n  filter(!is.na(birth_order)) %&gt;% \n  mutate(birth_order = birth_order %&gt;% fct_relevel(birth_order_levels)) %&gt;% \n  ggplot(aes(x = birth_order)) +\n  geom_bar(fill = \"olivedrab4\") +\n  labs(x = \"birth order\") +\n  theme_minimal(13)\n\n\n\n\nFiguur 6.2: Staafdiagram met correcte ordening van een geordende factor."
  },
  {
    "objectID": "factoren.html#levels-hernoemen-of-samenvoegen",
    "href": "factoren.html#levels-hernoemen-of-samenvoegen",
    "title": "6  Categorische variabelen",
    "section": "6.3 Levels hernoemen of samenvoegen",
    "text": "6.3 Levels hernoemen of samenvoegen\nSoms wil je meer dan alleen de bestaand levels herordenen. Stel dat je onze eerdere grafiek Figuur 6.1 wilt opnemen in een Nederlandstalig verslag. Je zult dan Nederlandse namen voor assen en levels willen gebruiken. Onze dataset bevat alleen Engelse namen. Het aanpassen van de namen van de assen kunnen we in ggplot() doen binnen labs() zoals we al eerder hebben gedaan. Het staat ons hier vrij om een naam te kiezen dus dat kan ook een Nederlandse naam zijn. De namen van de levels van een variabele zullen we moeten hernoemen. Hiervoor gebruiken we fct_recode(), die we eerder al hebben gezien toen we namen aan numerieke levels toekenden. We gebruiken fct_recode() in onderstaande code om elke taal een Nederlandse naam te geven. Let op dat de nieuwe levelnaam voor = komt zonder aanhalingstekens en de oude naam erachter met aanhalingstekens.\n\nwordbank_demo_romance %&gt;% \n  count(language) %&gt;%\n  mutate(language = fct_reorder(language, n),\n         language = language %&gt;% fct_recode(\n           Frans = \"French (French)\",\n           Italiaans = \"Italian\",\n           Portugees = \"Portuguese (European)\",\n           Spaans = \"Spanish (European)\"\n         )) %&gt;% \n  ggplot(aes(x = language, y = n)) +\n  geom_col(fill = \"wheat\") +\n  labs(x = \"taal\",\n       y = \"aantal kinderen in dataset\") +\n  theme_minimal(13)\n\n\n\n\nSoms wil je het aantal levels reduceren bijvoorbeeld om je grafiek overzichtelijker te maken of omdat bepaalde levels weinig voorkomen in de data. Met fct_collapse() kun je meerdere levels samenvoegen tot een nieuw level (soms is fct_other() handiger, want minder typewerk). In onderstaand voorbeeld voegen we de levels Fourth, Fifth en Sixth samen tot een nieuw level Fourth or later dat we hier met spaties schrijven, omdat dat mooier staat in de grafiek. Om te zorgen dat R het als één variabele herkent, zetten we enkele aanhalingstekens om deze nieuwe heen. De levels die we willen samenvoegen geven we mee als argumenten aan de functie c().\n\nwordbank_demo_romance %&gt;% \n  filter(!is.na(birth_order)) %&gt;% \n  mutate(birth_order = birth_order %&gt;% fct_relevel(birth_order_levels),\n         birth_order = birth_order %&gt;% fct_collapse(`Fourth or later` = c(\"Fourth\", \"Fifth\", \"Sixth\"))) %&gt;% \n  ggplot(aes(x = birth_order)) +\n  geom_bar(fill = \"olivedrab4\") +\n  labs(x = \"birth order\") +\n  theme_minimal(13)"
  },
  {
    "objectID": "factoren.html#meerdere-categorische-variabelen",
    "href": "factoren.html#meerdere-categorische-variabelen",
    "title": "6  Categorische variabelen",
    "section": "6.4 Meerdere categorische variabelen",
    "text": "6.4 Meerdere categorische variabelen\nWe hebben ons tot nu toe gericht op gevallen met een enkele categorische variabele. De variabele geslacht is hier een voorbeeld van:\n\nwordbank_demo_romance %&gt;% \n  count(sex)\n\n# A tibble: 3 × 2\n  sex        n\n  &lt;fct&gt;  &lt;int&gt;\n1 Female  2655\n2 Male    2785\n3 &lt;NA&gt;     150\n\n\nVaak willen we beschrijvende statistieken geven van meerdere categorische variabelen tegelijk. In onze dataset kunnen we bijvoorbeeld de verdeling van geslacht per taal bekijken. We halen wel eerst de missing values eruit met !is.na().\n\nwordbank_demo_romance %&gt;% \n  filter(!is.na(sex)) %&gt;% \n  count(language, sex)\n\n# A tibble: 8 × 3\n  language              sex        n\n  &lt;fct&gt;                 &lt;fct&gt;  &lt;int&gt;\n1 French (French)       Female   558\n2 French (French)       Male     525\n3 Italian               Female   377\n4 Italian               Male     375\n5 Portuguese (European) Female  1424\n6 Portuguese (European) Male    1588\n7 Spanish (European)    Female   296\n8 Spanish (European)    Male     297\n\n\nOmdat we twee levels hebben van de variabele sex en vier van de variabele language krijgen we \\(2 \\times 4\\) getallen terug. De volgorde waarin we de variabelen meegeven aan count() bepaalt de volgorde waarin R de data teruggeeft aan ons. Wanneer we eerst sex meegeven, dan worden de data geordend per level van die variabele, dus eerst alle waarden voor het eerste level female en dan voor het tweede level. Binnen elk level van sex worden de levels van language steeds getoond in de levelvolgorde van die variabele met French (French) als eerste.\n\nwordbank_demo_romance %&gt;% \n  filter(!is.na(sex)) %&gt;% \n  count(sex, language)\n\n# A tibble: 8 × 3\n  sex    language                  n\n  &lt;fct&gt;  &lt;fct&gt;                 &lt;int&gt;\n1 Female French (French)         558\n2 Female Italian                 377\n3 Female Portuguese (European)  1424\n4 Female Spanish (European)      296\n5 Male   French (French)         525\n6 Male   Italian                 375\n7 Male   Portuguese (European)  1588\n8 Male   Spanish (European)      297\n\n\nDe uitdaging ontstaat wanneer we proporties gaan berekenen. We moeten ons dan steeds de vragen stellen: proporties van wat? We hebben hier namelijk verschillende mogelijkheden en het aantal mogelijkheden wordt groter met het toenemen van het aantal variabelen. We kunnen bijvoorbeeld van elke combinatie van taal en geslacht de proportie binnen de dataset als geheel berekenen. Hiervoor bepalen we eerst het totaal aantal observaties (regel 4) en gebruiken dat als deler voor n.\n\nwordbank_demo_romance %&gt;% \n  filter(!is.na(sex)) %&gt;% \n  count(language, sex) %&gt;% \n  mutate(sum_total = sum(n),\n         proportion_total = n/sum_total,\n         proportion_total = round(proportion_total, 2))\n\n# A tibble: 8 × 5\n  language              sex        n sum_total proportion_total\n  &lt;fct&gt;                 &lt;fct&gt;  &lt;int&gt;     &lt;int&gt;            &lt;dbl&gt;\n1 French (French)       Female   558      5440             0.1 \n2 French (French)       Male     525      5440             0.1 \n3 Italian               Female   377      5440             0.07\n4 Italian               Male     375      5440             0.07\n5 Portuguese (European) Female  1424      5440             0.26\n6 Portuguese (European) Male    1588      5440             0.29\n7 Spanish (European)    Female   296      5440             0.05\n8 Spanish (European)    Male     297      5440             0.05\n\n\nDe kolom proportion_total laat zien dat binnen elke taal de proportie per geslacht ongeveer een gelijk aandeel van het geheel heeft.\nWe kunnen de proporties ook per taal berekenen, dus bijvoorbeeld welk aandeel heeft het level female binnen het Frans? Hiervoor moeten we de totalen per taal berekenen. Dit doen we met de functie group-by().\n\nwordbank_demo_romance %&gt;% \n  filter(!is.na(sex)) %&gt;% \n  count(language, sex) %&gt;% \n  mutate(sum_total = sum(n),\n         proportion_total = n/sum_total,\n         proportion_total = round(proportion_total, 2)) %&gt;% \n  group_by(language) %&gt;% \n  mutate(sum_language = sum(n))\n\n# A tibble: 8 × 6\n# Groups:   language [4]\n  language              sex        n sum_total proportion_total sum_language\n  &lt;fct&gt;                 &lt;fct&gt;  &lt;int&gt;     &lt;int&gt;            &lt;dbl&gt;        &lt;int&gt;\n1 French (French)       Female   558      5440             0.1          1083\n2 French (French)       Male     525      5440             0.1          1083\n3 Italian               Female   377      5440             0.07          752\n4 Italian               Male     375      5440             0.07          752\n5 Portuguese (European) Female  1424      5440             0.26         3012\n6 Portuguese (European) Male    1588      5440             0.29         3012\n7 Spanish (European)    Female   296      5440             0.05          593\n8 Spanish (European)    Male     297      5440             0.05          593\n\n\nWe gebruiken die totalen per taal om vervolgens het aantal observaties te delen:\n\nwordbank_demo_romance %&gt;% \n  filter(!is.na(sex)) %&gt;% \n  count(language, sex) %&gt;% \n  mutate(sum_total = sum(n),\n         proportion_total = n/sum_total,\n         proportion_total = round(proportion_total, 2)) %&gt;% \n  group_by(language) %&gt;% \n  mutate(sum_language = sum(n),\n         proportion_language = n/sum_language,\n         proportion_language = round(proportion_language, 2))\n\n# A tibble: 8 × 7\n# Groups:   language [4]\n  language              sex        n sum_total proportion_total sum_language\n  &lt;fct&gt;                 &lt;fct&gt;  &lt;int&gt;     &lt;int&gt;            &lt;dbl&gt;        &lt;int&gt;\n1 French (French)       Female   558      5440             0.1          1083\n2 French (French)       Male     525      5440             0.1          1083\n3 Italian               Female   377      5440             0.07          752\n4 Italian               Male     375      5440             0.07          752\n5 Portuguese (European) Female  1424      5440             0.26         3012\n6 Portuguese (European) Male    1588      5440             0.29         3012\n7 Spanish (European)    Female   296      5440             0.05          593\n8 Spanish (European)    Male     297      5440             0.05          593\n# ℹ 1 more variable: proportion_language &lt;dbl&gt;\n\n\nWe zien hier dat binnen elke taal de proporties voor zowel female als male rond de .50 ligt.\nDe laatste optie is per geslacht te berekenen welke proportie elke taal inneemt. Hiervoor berekenen we eerst het totaal aantal observaties per geslacht met group_by(sex).\n\ndemo_romance &lt;- wordbank_demo_romance %&gt;% \n  filter(!is.na(sex)) %&gt;% \n  count(language, sex) %&gt;% \n  mutate(sum_total = sum(n),\n         proportion_total = n/sum_total,\n         proportion_total = round(proportion_total, 2)) %&gt;% \n  group_by(language) %&gt;% \n  mutate(sum_language = sum(n),\n         proportion_language = n/sum_language,\n         proportion_language = round(proportion_language, 2)) %&gt;% \n  group_by(sex) %&gt;% \n  mutate(sum_sex = sum(n),\n         proportion_sex = n/sum_sex,\n         proportion_sex = round(proportion_sex, 2))\n\ndemo_romance\n\n# A tibble: 8 × 9\n# Groups:   sex [2]\n  language              sex        n sum_total proportion_total sum_language\n  &lt;fct&gt;                 &lt;fct&gt;  &lt;int&gt;     &lt;int&gt;            &lt;dbl&gt;        &lt;int&gt;\n1 French (French)       Female   558      5440             0.1          1083\n2 French (French)       Male     525      5440             0.1          1083\n3 Italian               Female   377      5440             0.07          752\n4 Italian               Male     375      5440             0.07          752\n5 Portuguese (European) Female  1424      5440             0.26         3012\n6 Portuguese (European) Male    1588      5440             0.29         3012\n7 Spanish (European)    Female   296      5440             0.05          593\n8 Spanish (European)    Male     297      5440             0.05          593\n# ℹ 3 more variables: proportion_language &lt;dbl&gt;, sum_sex &lt;int&gt;,\n#   proportion_sex &lt;dbl&gt;\n\n\nDit voorbeeld laat zien dat je zelf als onderzoeker goed moet nadenken wat je wilt laten zien. Elke proportie vertelt een net wat ander verhaal.\nHoewel het mogelijk is om de proporties te laten bereken door geom_bar() levert dit al snel complicaties op. Wij kiezen er daarom voor om zelf proporties te berekene en deze af te beelden met geom_col(). Op deze manier houd je volledige controle over de data.\nLaten we eerst eens kijken of we de proportie geslacht per taal kunnen afbeelden.\n\ndemo_romance %&gt;% \n  ggplot(aes(x = language, y = proportion_language)) +\n  geom_col() +\n  labs(y = \"proportion per language\") +\n  theme_minimal(13)\n\n\n\n\nDeze grafiek geeft nog weinig inzicht. We zullen hiervoor de staven moet kleuren op basis van de variabele sex. We voegen deze toe in de aes() van ggplot() waar we een mapping maken met fill (N.B. color verandert de rand van de staaf niet de binnenkant.)\n\ndemo_romance %&gt;% \n  ggplot(aes(x = language, y = proportion_language, fill = sex )) +\n  geom_col() +\n  labs(y = \"proportion per language\") +\n  theme_minimal(13)\n\n\n\n\nDit laat meteen een probleem zien dat ontstaat door factoren met lange namen van levels. Door het toevoegen van kleur is er een legenda bij gekomen en hierdoor is er minder ruimte voor de staven. De namen van de levels overlappen. Het geeft ons de mogelijkheid om wat meer opties van ggplot() te laten zien. Er zijn namelijk meerdere manieren om dit op te lossen. We kunnen de grafiek draaien of we kunnen de positie van de legenda veranderen. Dit doen we binnen de functie theme() met de optie legend.position. We verplaatsen de legenda naar de onderkant van de grafiek (andere opties zijn left, right, top en none die we al eerder hebben gezien om de legenda geheel te verwijderen).\n\ndemo_romance %&gt;% \n  ggplot(aes(x = language, y = proportion_language, fill = sex )) +\n  geom_col(width = 0.5) +\n  labs(y = \"proportion per language\") +\n  theme_minimal(13) +\n  theme(legend.position = \"bottom\")\n\n\n\n\nWe kunnen er ook voor kiezen om de labels van de x-as wat de draaien. Ook dit specificeren we binnen theme(). Hier zijn talloze opties om het uiterlijk van de grafiek aan te passen, gebruik ?theme() voor een overzicht. Hier passen we een rotatie van 45 graden (angle = 45) toe op de text van de x-as axis.text.x en we verplaatsen de tekst ook wat in de hoogte en de breedte met vjust en hjust.\n\ndemo_romance %&gt;% \n  ggplot(aes(x = language, y = proportion_language, fill = sex )) +\n  geom_col(width = 0.5) +\n  labs(y = \"proportion per language\") +\n  theme_minimal(13) +\n  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))\n\n\n\n\nWanneer we de proporties voor meer dan twee levels willen laten zien dan geeft een gestapeld staafdiagram niet altijd de beste optie. Het kan dan namelijk lastig worden om over staven heen gelijke levels te vergelijken, omdat die een ander beginpunt hebben.\n\ndemo_romance %&gt;% \n  ggplot(aes(x = sex, y = proportion_sex, fill = language )) +\n  geom_col(width = 0.5) +\n  labs(y = \"proportion per language\") +\n  theme_minimal(13) \n\n\n\n\nWe kunnen er in dat geval voor kiezen om de elk level een eigen staaf te geven. Dat doen we binnen geom_col() door het argument position = \"dodge\" toe te voegen.\n\ndemo_romance %&gt;% \n  ggplot(aes(x = sex, y = proportion_sex, fill = language )) +\n  geom_col(position = \"dodge\", width = 0.5) +\n  labs(y = \"proportion per language\") +\n  theme_minimal(13) \n\n\n\n\nDit is een verkorte schrijfwijze voor position = position_dodge() dat je kunt gebruiken om de afstand tussen de staven aan te passen:\n\ndemo_romance %&gt;% \n  ggplot(aes(x = sex, y = proportion_sex, fill = language )) +\n  geom_col(position = position_dodge(.6), width = 0.5) +\n  labs(y = \"proportion per language\") +\n  theme_minimal(13) \n\n\n\n\nFiguur 6.3: Staafdiagram met iets grotere afstand tussen de staven."
  },
  {
    "objectID": "factoren.html#kleuren",
    "href": "factoren.html#kleuren",
    "title": "6  Categorische variabelen",
    "section": "6.5 kleuren",
    "text": "6.5 kleuren\nWe hebben net kleuren gebruikt om de verschillende levels van een variabele binnen een staaf zichtbaar te maken. Dit biedt ons een mooie gelegenheid om wat dieper in te gaan op kleurgebruik binnen R. Het blijkt namelijk dat vaak een leuk onderdeel wordt gevonden van het maken van grafieken. Ook hier zijn de mogelijkheden eindeloos.\nWanneer we een variabele via aes() afbeelden op een aesthetic waarin kleur een rol speelt (color of fill), dan zal R in principe zelf de kleuren bepalen die gebruikt worden, zoals te zien in Figuur 6.3. Je kunt deze kleuren ook handmatig aanpassen. Met het commando colors() krijg je een overzicht van alle in R gedefinieerde kleurennamen, voor een visueel overzicht zie https://sites.stat.columbia.edu/tzheng/files/Rcolor.pdf. Je kunt deze kleurennamen gebruiken wanneer je een vaste kleur wilt geven aan alle staven of punten in je grafiek. Dit hebben we aan het begin van het hoofdstuk steeds gedaan. In dit geval wijs je deze kleur toe binnen het geom buiten aes() met color = \"&lt;kleurnaam&gt;\", zie bijvoorbeeld Figuur 6.1 waar we peachpuff2 als kleurnaam hebben toegepast. Wanneer je een variabele naar een kleurattribuut mapt binnen aes() en je wilt de kleuren handmatig aanpassen dan moet je scale_fill_manual() toevoegen bij een mapping naar fill of scale_color_manual() bij een mapping naar color. Je moet dan met de functie c() aan het argument values evenveel kleurennamen meegeven als dat er levels zijn die je wilt kleuren. De kleuren worden in volgorde gekoppeld aan de levels van de factor. Hieronder hebben we dat gedaan voor Figuur 6.3.\n\ndemo_romance %&gt;% \n  ggplot(aes(x = sex, y = proportion_sex, fill = language )) +\n  geom_col(position = position_dodge(.6), width = 0.5) +\n  scale_fill_manual(values = c(\"violetred1\", \"violetred2\", \"violetred3\", \"violetred4\")) +\n  labs(y = \"proportion per language\") +\n  theme_minimal(13) \n\n\n\n\nWanneer je zelf kleuren gaat kiezen is het belangrijk om te zorgen dat de levels voldoende contrast hebben. In bovenstaand voorbeeld is dat niet heel erg duidelijk gelukt. Om je hierbij te helpen, bestaan er paletten van kleuren met voldoende contrast, https://r-graph-gallery.com/38-rcolorbrewers-palettes.html vind je een overzicht. Deze paletten voeg je toe met scale_fill_brewer(palette = \"&lt;palettenaam&gt;\") (of scale_color_brewer()). Verder is het ook raadzaam om rekening te houden met kleurenblindheid. Hieronder gebruiken we het palette PuRd.\n\ndemo_romance %&gt;% \n  ggplot(aes(x = sex, y = proportion_sex, fill = language )) +\n  geom_col(position = position_dodge(.6), width = 0.5) +\n  scale_fill_brewer(palette = \"PuRd\") +\n  labs(y = \"proportion per language\") +\n  theme_minimal(13)"
  },
  {
    "objectID": "factoren.html#een-level-highlighten",
    "href": "factoren.html#een-level-highlighten",
    "title": "6  Categorische variabelen",
    "section": "6.6 Een level highlighten",
    "text": "6.6 Een level highlighten\nOnze kennis over kleuren kunnen we toepassen om een level van een variabele te highlighten. Stel je voor dat je een verslag schrijft waarin je speciale aandacht hebt voor het Italiaans. Je zou er dan voor kunnen kiezen om dit level van de variabele language een andere kleur te geven dan de overige levels. Op deze manier springt het Italiaans er echt uit in je grafiek.\nAangezien we te maken hebben met een mapping van een variabele naar kleur, kun je een nieuwe variabele aanmaken. We geven deze variabele hier de naam lang_color. Binnen deze variabele geven we Italian een andere waarde dan de overige levels. We doen dat met de functie fct_other(). Binnen deze functie kun je aangeven van welk(e) level(s) je de naam wilt bewaren en welke je een andere naam wilt geven. Deze levels krijgen standaard de naam Other, maar je kunt er ook voor kiezen dit een andere naam te geven.\n\nwordbank_demo_romance %&gt;% \n  count(language) %&gt;%\n  mutate(language = fct_reorder(language, n),\n         lang_color = language %&gt;% fct_other(keep = c(\"Italian\"))) \n\n# A tibble: 4 × 3\n  language                  n lang_color\n  &lt;fct&gt;                 &lt;int&gt; &lt;fct&gt;     \n1 French (French)        1233 Other     \n2 Italian                 752 Italian   \n3 Portuguese (European)  3012 Other     \n4 Spanish (European)      593 Other     \n\n\nWe gebruiken deze nieuwe variabele lang_other vervolgens in de mapping van fill op het niveau van geom_col() (kan ook binnen ggplot()) en we voegen via scale_fill_manual() de kleuren toe die we willen gebruiken. Aangezien Italian voor Other komt, zal het Italiaans de rode kleur krijgen en de andere levels grijs.\n\nwordbank_demo_romance %&gt;% \n  count(language) %&gt;%\n  mutate(language = fct_reorder(language, n),\n         lang_color = language %&gt;% fct_other(keep = c(\"Italian\"))) %&gt;% \n  ggplot(aes(x = n, y = language)) +\n  geom_col(aes(fill = lang_color), show.legend = F) +\n  scale_fill_manual(values = c(\"red\", \"grey80\")) +\n  theme_minimal(13)"
  },
  {
    "objectID": "factoren.html#een-uitgewerkt-voorbeeld",
    "href": "factoren.html#een-uitgewerkt-voorbeeld",
    "title": "6  Categorische variabelen",
    "section": "6.7 Een uitgewerkt voorbeeld",
    "text": "6.7 Een uitgewerkt voorbeeld\n\nwordbank_demo_romance %&gt;% \n  filter(!is.na(caregiver_education)) %&gt;% \n  count(language, caregiver_education)\n\n# A tibble: 14 × 3\n   language              caregiver_education     n\n   &lt;fct&gt;                 &lt;fct&gt;               &lt;int&gt;\n 1 French (French)       College                45\n 2 French (French)       Graduate               98\n 3 French (French)       Secondary              46\n 4 French (French)       Some College          124\n 5 French (French)       Some Graduate         333\n 6 French (French)       Some Secondary        300\n 7 Portuguese (European) College              1031\n 8 Portuguese (European) Graduate              150\n 9 Portuguese (European) Primary               860\n10 Portuguese (European) Secondary             912\n11 Spanish (European)    College               168\n12 Spanish (European)    Graduate              288\n13 Spanish (European)    Primary                36\n14 Spanish (European)    Secondary              94\n\nlevels(wordbank_demo_romance$caregiver_education)\n\n[1] \"College\"        \"Graduate\"       \"Primary\"        \"Secondary\"     \n[5] \"Some College\"   \"Some Graduate\"  \"Some Secondary\"\n\n#edu_levels &lt;- c(\"Primary\", \"Some Secondary\", \"Secondary\", \"Some College\", \"College\", \"Some Graduate\", \"Graduate\")\nedu_levels &lt;- c(\"Primary\", \"Secondary\", \"College\", \"Graduate\")\n\nwordbank_demo_romance %&gt;% \n  filter(!is.na(caregiver_education)) %&gt;% \n#  mutate(caregiver_education = caregiver_education %&gt;% fct_relevel(edu_levels) %&gt;% fct_rev()) %&gt;%\n  mutate(caregiver_education = caregiver_education %&gt;% fct_collapse(\n    Graduate = c(\"Graduate\", \"Some Graduate\"),\n    College = c(\"College\", \"Some College\"),\n    Secondary = c(\"Secondary\", \"Some Secondary\")),\n    caregiver_education = caregiver_education %&gt;% fct_relevel(edu_levels) %&gt;% fct_rev()) %&gt;% \n  ggplot(aes(y = language, fill = caregiver_education, )) +\n  geom_bar(position = \"fill\") +\n  scale_fill_brewer(palette = \"Blues\") +\n  theme_minimal(13)"
  },
  {
    "objectID": "factoren.html#verder-leren",
    "href": "factoren.html#verder-leren",
    "title": "6  Categorische variabelen",
    "section": "6.8 Verder leren",
    "text": "6.8 Verder leren\n\nLees hoofdstuk 4 (t/m 4.5) en sectie 5.1 uit DataVis\nhoofdstuk 9 uit R4DS. Hiermee krijg je een goed beeld van hoe geoms en facets werken in ggplot2.\nHet ggplot2 cheat sheet geeft een overzicht van de mogelijkheden die dit package biedt (zie Brightspace voor een Nederlandstalige versie).\nHoofdstuk 16 uit R4DS geeft daarnaast een overzicht van het werken van factoren (zoals het veranderen van de ordening van levels).\nZie voor een overzicht van wat je allemaal kunt doen met factoren het forcats cheat sheet.\nalles over kleuren in R https://r-graph-gallery.com/ggplot2-color.html"
  },
  {
    "objectID": "numeriek.html#distributies-zichtbaar-maken",
    "href": "numeriek.html#distributies-zichtbaar-maken",
    "title": "7  Numerieke variabelen",
    "section": "7.1 Distributies zichtbaar maken",
    "text": "7.1 Distributies zichtbaar maken\nWe gaan de variabele age verder bekijken. Wat is de verdeling van leeftijden in onze dataset? We kunnen tellen hoe vaak elke leeftijd voorkomt. We gebruiken hier het commando print(n=20) om meer rijen zichtbaar te maken dan de standaard 10 rijen.\n\nwordbank_dutch_child %&gt;% \n  count(age) %&gt;% \n  print(n = 20)\n\n# A tibble: 16 × 2\n     age     n\n   &lt;dbl&gt; &lt;int&gt;\n 1    16     4\n 2    17    49\n 3    18    68\n 4    19     7\n 5    20     7\n 6    21     7\n 7    22     7\n 8    23    51\n 9    24    31\n10    25     6\n11    26     6\n12    27     5\n13    28     6\n14    29    23\n15    30    24\n16    31     2\n\n\nVoor elke unieke waarde van de variabele age krijgen we hier te zien hoe vaak deze voorkomt in de dataset.\nDit is in feite ook wat een histogram voor ons doet: het telt het aantal voorkomens waarbij het de numerieke variabele opdeelt in een aantal groepen. Die groepen worden bins genoemd. Elke staaf in het histogram beeldt een bin uit. Het standaard aantal bins voor geom_histogram() is 30 en dat levert niet altijd het beste resultaat, zoals R zelf ook aangeeft met de boodschap ‘Pick better value with `binwidth’’. Als we goed kijken naar de data dan zien we dat de staven de data op een vreemde manier indelen en ieder geval niet per maand. Dit zien we bijvoorbeeld als we kijken naar de hele getallen op de x-as. Soms staat het bijbehorende streepje midden in een staaf (bij 16), soms aan het begin (bij 20) en soms aan het eind (bij 24 en 28).\n\nwordbank_dutch_child %&gt;% \n  ggplot(aes(x = age)) +\n  geom_histogram() +\n  theme_minimal(13)\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\nHet is dus bij een histogram belangrijk om zelf te bedenken hoe je de data kunt opdelen. Met het argument bins = binnen geom_histogram() kun je aangeven in hoeveel staven je het histogram wilt opdelen. Omdat we bij het tellen hebben gezien dat er 16 verschillende leeftijden voorkomen, ligt het voor deze dataset voor de hand om een getal te nemen waar je 16 door kunt delen om een geheel getal te krijgen. We kiezen hier 16. Elke maand krijgt dan zijn eigen staaf.\n\nwordbank_dutch_child %&gt;% \n  ggplot(aes(x = age)) +\n  geom_histogram(bins = 16) +\n  theme_minimal(13)\n\n\n\n\nDe staven zien we alleen nog niet zo duidelijk, omdat zowel de fill als de color standaard op zwart staan ingesteld. We geven de randen van de staaf de kleur white zodat we de bins kunnen zien en geven de staven ook meteen een kleur:\n\nwordbank_dutch_child %&gt;% \n  ggplot(aes(x = age)) +\n  geom_histogram(bins = 16, color = \"white\", fill = \"thistle3\") +\n  theme_minimal(13)\n\n\n\n\nIn plaats van het argument bins kun je ook binwidth gebruiken, zoals R zelf al suggereerde. Met binwidth specificeer je de de stappen waarin je wilt tellen. Aangezien we hier te maken hebben met gehele getallen kiezen we voor 1, maar je zou bijvoorbeeld ook per 2 of 3 maanden kunnen tellen.\n\nwordbank_dutch_child %&gt;% \n  ggplot(aes(x = age)) +\n  geom_histogram(binwidth = 1, color = \"white\", fill = \"thistle3\") +\n  theme_minimal(13)\n\n\n\n\nDit histogram geeft met logische bins een goed beeld van de verdeling van de data. We zien dat een aantal leeftijden veel meer voorkomt in de data dan andere. Door de plaatsing van de getallen op de x-as is het alleen niet meteen duidelijk om welke leeftijden het gaat. Sommige streepjes staan midden in een staaf (bijv. 20 en 25), andere staan tussen staven in (bijv. 17.5). De nummering op de x-as passen we aan met scale_x_continuous() (voor de y-as is er scale_y_continuous en er zijn ook varianten voor discrete assen). Het argument breaks specificeert waar we getallen willen. Dit kun je volledig handmatig doen door een vector van getallen te specificeren met c(). Om typewerk te besparen doen we het hier met seq() waarbij we aangeven dat we de labels bij 16 willen laten beginnen en laten doorlopen tot en met 32 in stapjes van 2 (dus 16, 18, 20, …).\n\nwordbank_dutch_child %&gt;% \n  ggplot(aes(x = age)) +\n  geom_histogram(binwidth = 1, color = \"white\", fill = \"thistle3\") +\n  scale_x_continuous(breaks = seq(16, 32, 2)) +\n  theme_minimal(13)\n\n\n\n\nHet blijft bij histogrammen opletten waar elke staaf voor staat. We hebben de getallen nu midden in de staaf staan, maar vaak zie je het ook links of juist rechts van de staaf.\n\n7.1.1 Density\nIn plaats van een histogram kunnen we de verdeling ook zichtbaar maken met een density plot. We hoeven hiervoor alleen een ander geom te specificeren. We gebruiken geom_density() en we geven aan dat we de lijn en opvulling van de grafiek in dezelfde kleur willen, met alpha = .5 geven we aan dat we de opvulling enigszins transparant willen maken.\n\nwordbank_dutch_child %&gt;% \n  ggplot(aes(x = age)) +\n  geom_density(color = \"thistle3\", fill = \"thistle3\", alpha = .5) +\n  theme_minimal(13)\n\n\n\n\nHetzelfde kunnen we doen voor de variabele comprehension.\n\nwordbank_dutch_child %&gt;% \n  ggplot(aes(x = comprehension)) +\n  geom_density(color = \"bisque3\", fill = \"bisque3\", alpha = .5) +\n  theme_minimal(13)\n\n\n\n\nDe reden dat we de opvulling transparant maken is dat we dat mooier vinden, maar vooral ook dat het mogelijk maakt om meerdere variabelen in een grafiek zichtbaar te maken. We kunnen bijvoorbeeld proberen production toe te voegen om zo de verdelingen te vergelijken.\nDe manier waarop onze dataset is vormgeven met een aparte kolom voor comprehension en een voor production maakt dit wel wat uitdagender. Aangezien we in ggplot() de variabele comprehension al op x hebben afgebeeld, kunnen we daar production niet meer toevoegen. De enige optie die we hebben is om gebruik te maken van het feit dat we binnen het geom een nieuwe mapping kunnen maken in de aes() van het geom. We voegen dus een nieuw geom_density() toe met een eigen kleur. Omdat dit geom later wordt toegevoegd, wordt het over het eerdere heen getekend. De transparantiewaarde met alpha komt hier dus goed van pas.\n\nwordbank_dutch_child %&gt;% \n  ggplot(aes(x = comprehension)) +\n  geom_density(color = \"bisque3\", fill = \"bisque3\", alpha = .5) +\n  geom_density(aes(x = production), color = \"deepskyblue4\", fill = \"deepskyblue4\", alpha = .4) +\n  theme_minimal(13)\n\n\n\n\nDeze grafiek laat de densities van beiden variabelen zien, maar heeft zijn problemen. De x-as zegt nog steeds ‘comprehension’ en het wordt niet duidelijk welke kleur bij welke variabele hoort. Het aanpassen van het label van de x-as via labs() gaat dit niet volledig oplossen.\nWe kunnen proberen om de mapping van comprehension naar de x-as te verschuiven van ggplot() naar de aes() van de eerste aanroep van `geom_density()’, maar ook dit verandert niets.\n\nwordbank_dutch_child %&gt;% \n  ggplot() +\n  geom_density(aes(x = comprehension), color = \"bisque3\", fill = \"bisque3\", alpha = .5) +\n  geom_density(aes(x = production), color = \"deepskyblue4\", fill = \"deepskyblue4\", alpha = .4) +\n  theme_minimal(13)\n\n\n\n\nHet probleem zit dieper. Wanneer we de kleur willen laten variëren op basis van een variabele, dan moeten de waardes van die variabele in dezelfde kolom staan. Dat is hier niet het geval. We hebben per kind een aparte kolom voor comprehension en een voor production. Het zijn twee aparte variabelen. De dataset staat in wat we noemen wide format.\n\nwordbank_dutch_child %&gt;% \n  print(n = 2)\n\n# A tibble: 303 × 4\n  child_id   age comprehension production\n  &lt;fct&gt;    &lt;dbl&gt;         &lt;dbl&gt;      &lt;dbl&gt;\n1 76526       18           162         37\n2 76527       18           405         28\n# ℹ 301 more rows\n\n\nDit formaat is handig als we de variabelen apart willen laten zien, maar niet als we ze eigenlijk als waardes van één variabele willen behandelen. We moeten dan dus een kolom aanmaken waarin we per kind twee rijen krijgen, een met de waarde voor comprehension en een voor production. Dit noemen we long format. We gaan hiervoor een nieuwe variabele aanmaken die we skill noemen. Dit doen we met de functie pivot_longer() (zoals je misschien al had geraden is er ook de tegenhanger pivot_wider()). In het argument cols geven we aan welke variabelen we willen samenvoegen tot een nieuwe variabele (de kolomnamen worden de namen van de levels). Met names_to geven we de naam van de nieuwe variabele aan en met values_to geven we aan in welke variabele de waarden de oorspronkelijke variabelen terecht gaan komen. Het eerste kind (met id 76526) scoorde 162 op comprehension en 37 op production. Deze waardes zullen op twee rijen komen in de nieuwe variabele number_of_words.\n\ndutch_child_long &lt;- wordbank_dutch_child %&gt;% \n  pivot_longer(cols = c(comprehension, production), \n               names_to = \"skill\", \n               values_to = \"number_of_words\")\n\ndutch_child_long %&gt;% \n  print(n = 4)\n\n# A tibble: 606 × 4\n  child_id   age skill         number_of_words\n  &lt;fct&gt;    &lt;dbl&gt; &lt;chr&gt;                   &lt;dbl&gt;\n1 76526       18 comprehension             162\n2 76526       18 production                 37\n3 76527       18 comprehension             405\n4 76527       18 production                 28\n# ℹ 602 more rows\n\n\nWe zien nu dat ieder kind twee rijen in de dataset heeft. De lengte van de dataset is dan ook verdubbeld van 303 naar 606. In de eerste twee rijen zien we de scores van 162 en 37 voor kind met id 76526 terug en die zijn in de kolom skill gelabelled als comprehension en production. We zetten de nieuwe variabele skill nog even om naar een factor:\n\ndutch_child_long &lt;- dutch_child_long %&gt;% \n  mutate(skill = as.factor(skill))\n\nNu kunnen we de grafiek maken zoals we hem wilde waarbij we de nieuwe variabele skill afbeelden op de kleur en fill van de density plots. We krijgen hiermee meteen een legenda die aangeeft welke skill bij welke kleur hoort. We hebben nu ook maar één aanroep van geom_density() nodig.\n\ndutch_child_long %&gt;% \n  ggplot(aes(x = number_of_words)) +\n  geom_density(aes(color = skill, fill = skill), alpha = .3) +\n  scale_fill_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  scale_color_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  labs(x = \"number of words\") +\n  theme_minimal(13)\n\n\n\n\nFiguur 7.1: Overlappende density plot op basis van data in long format\n\n\n\n\nDe grafiek laat nu duidelijk zien dat er een verschil in verdeling is tussen begrip en productie. Kinderen kennen meer woorden dan ze gebruiken.\nAls we geen overlap willen van de density plots, maar ze wel in één figuur willen laten zien kunnen we nu ook facet_wrap() gebruiken waarbij we de grafiek splitsen op skill. We krijgen dan een aparte grafiek voor comprehension en production. Omdat deze levels al benoemd zijn in de titels van de aparte plots, is de legenda overbodig. We halen de legenda weg met show.legend = F. De alpha-waarde verhogen we weer iets, aangezien de densities niet meer overlappen.\n\ndutch_child_long %&gt;% \n  ggplot(aes(x = number_of_words)) +\n  geom_density(aes(color = skill, fill = skill), alpha = .5, show.legend = F) +\n  facet_wrap(~ skill) +\n  scale_fill_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  scale_color_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  labs(x = \"number of words\") +\n  theme_minimal(13)\n\n\n\n\nWe gebruiken deze grafiek om nog wat extra opties te laten zien om het uiterlijk van grafieken naar je hand te zetten. We gaan hier de titel van de facet wat duidelijker maken door het lettertype te vergroten en dik te drukken. Deze aanpassing doen we weer binnen theme(). Met strip.text kunnen we de titel aanpassen. We verhogen de grootte naar 18 en zetten de titel in bold.\n\ndutch_child_long %&gt;% \n  ggplot(aes(x = number_of_words)) +\n  geom_density(aes(color = skill, fill = skill), alpha = .5, show.legend = F) +\n  facet_wrap(~ skill) +\n  scale_fill_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  scale_color_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  labs(x = \"number of words\") +\n  theme_minimal(13) +\n  theme(strip.text = element_text(size = 18, face = \"bold\"))\n\n\n\n\nFacets kunnen handig zijn om inzicht te krijgen in hoe een variabele zich gedraagt op niveaus van een andere variabelen. Aangezien age een discrete numerieke variabele is, kunnen we per maand een aparte density plot maken. Bij continue variabelen is dat lastiger, aangezien het dan minder duidelijk is waar je de grenzen moet leggen. We kiezen ervoor om de woordproductie per maand te laten zien. Aangezien we nu in long format zitten betekent dat we de data moeten filteren op skill. Zo zie je dat het ene formaat handig kan zijn voor de ene soort visualisatie en het andere voor een andere. Het is dus handig als je makkelijk kunt switchen tussen formaten met de pivot_-functies.\n\ndutch_child_long %&gt;%\n  filter(skill == \"production\") %&gt;% \n  ggplot(aes(x = number_of_words)) +\n  geom_density(color = \"deepskyblue4\", fill = \"deepskyblue4\", alpha = .5, show.legend = F) +\n  facet_wrap(~ age) +\n  labs(x = \"number of words\",\n       title = \"Distribution by age\") +\n  theme_minimal(13) +\n  theme(strip.text = element_text(size = 15, face = \"bold\"))\n\n\n\n\nWe zien in de plot een duidelijke ontwikkeling. Aan het begin en het eind zijn er duidelijk pieken en zitten de kinderen allemaal in hetzelfde gebied. Tussen de 20 en 27 maanden is er meer variatie. Sommige kinderen produceren al veel woorden terwijl anderen nog wat lagere aantallen laten zien.\n\n\n7.1.2 boxplots\nEen derde optie om verdelingen zichtbaar te maken zijn boxplots. We zetten onze eerdere density plot Figuur 7.1 om in een boxplot door geom_density() te vervangen door geom_boxplot().\n\ndutch_child_long %&gt;% \n  ggplot(aes(x = number_of_words, color = skill, fill = skill)) +\n  geom_boxplot(alpha = .3) +\n  scale_fill_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  scale_color_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  labs(x = \"number of words\") +\n  theme_minimal(13)\n\n\n\n\nNet zoals het histogram komt het boxplot met een aantal eigenaardigheden. Zo zien we in bovenstaande figuur getallen staan op de y-as. Het lijkt erop dat de levels van de variabele skill ieder een waarde hebben gekregen (rond 0.2 en -0.2). Die getallen willen we weghalen, aangezien ze betekenisloos zijn. De oplossing daarvoor is simpel. We voegen y = skill toe aan de aes()-mapping (hier in ggplot()). Om te zorgen dat de levels niet dubbel worden gecodeerd, halen we meteen de legenda weg.\n\ndutch_child_long %&gt;% \n  ggplot(aes(x = number_of_words, y = skill, color = skill, fill = skill)) +\n  geom_boxplot(width = .4, alpha = .3, show.legend = F) +\n  scale_fill_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  scale_color_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  labs(x = \"number of words\") +\n  theme_minimal(13)\n\n\n\n\nHet toevoegen van een y-variabele helpt ons ook als we maar één variabele willen afbeelden in de boxplot. Wanneer we dit niet doen krijgen we weer getallen op de y-as.\n\ndutch_child_long %&gt;% \n  filter(skill == \"production\") %&gt;% #ontdubbelen van de data, elk kind staat er nu 2 keer in\n  ggplot(aes(x = age)) +\n  geom_boxplot(color = \"thistle3\", fill = \"thistle3\", width = .4, alpha = .5) +\n  theme_minimal(13)\n\n\n\n\nMet een omweg kunnen we van deze getallen afkomen. We voegen een dummy-variabele toe op y met y = factor(0) en we specificeren vervolgens in theme() met element_blank() dat we geen tekst op de y-as willen.\n\ndutch_child_long %&gt;% \n  filter(skill == \"production\") %&gt;% #ontdubbelen van de data, elk kind staat er nu 2 keer in\n  ggplot(aes(x = age, y = factor(0))) +\n  geom_boxplot(color = \"thistle3\", fill = \"thistle3\", width = .4, alpha = 0.5) +\n  labs(y = NULL) +\n  theme_minimal(13) +\n  theme(axis.text.y = element_blank())\n\n\n\n\nBoxplots zijn ideaal om outliers zichtbaar te maken. Dit zijn punten die meer dan \\(1.5 \\times IQR\\) onder het eerste kwartiel of boven het derde kwartiel liggen. In de variabelen in onze dataset zitten geen outliers. Voor de oefening voegen we daarom twee outliers toe. We maken hiervoor eerst een datatabel aan met verzonnen data van twee kinderen.\n\noutlier_cases &lt;- tribble(~child_id, ~age, ~skill, ~number_of_words,\n                   99999, 38, \"production\", 999,\n                   99999, 42, \"production\", 999)\n\noutlier_cases &lt;- outlier_cases %&gt;% \n  mutate(child_id = as.factor(child_id))\n\nMet add_case() voegen we deze twee observaties toe aan onze datatabel. In geom_boxplot() specificeren we met outlier.color en outlier.alpha de kleur en transparantie van de punten waarmee de outliers worden getoond.\n\ndutch_child_long %&gt;% \n  filter(skill == \"production\") %&gt;%\n  add_case(outlier_cases) %&gt;% \n  ggplot(aes(x = age, y = factor(0))) +\n  geom_boxplot(color = \"thistle3\", \n               fill = \"thistle3\",\n               width = .4,\n               alpha = 0.5,\n               outlier.color = \"red\",\n               outlier.alpha = .5) +\n  labs(y = NULL) +\n  theme_minimal(13) +\n  theme(axis.text.y = element_blank())"
  },
  {
    "objectID": "numeriek.html#beschrijvende-statistieken-berekenen",
    "href": "numeriek.html#beschrijvende-statistieken-berekenen",
    "title": "7  Numerieke variabelen",
    "section": "7.2 Beschrijvende statistieken berekenen",
    "text": "7.2 Beschrijvende statistieken berekenen\nR bieden verschillende functies waarmee we beschrijvende statistieken kunnen berekenen. De onderstaande tabel geeft een overzicht van veelgebruikte functies.\n\nOverzicht van functies waarmee beschrijvende statistieken kunnen worden berekend\n\n\n\n\n\n\n\nfunctienaam\nwerking\nwerkt met summarize()\n\n\n\n\nrange()\nbepaalt het bereik van een variabele (geeft minimale en maximale waarde)\nnee\n\n\nmin()\nbepaalt de minimale waarde van een variabele\nja\n\n\nmax()\nbepaalt de maximale waarde van een variabele\nja\n\n\nmean()\nberekent het gemiddelde van een variabele\nja\n\n\nmedian()\nberekent de mediaan van een variabele\nja\n\n\nsd()\nberekent de standaarddeviatie van een variabele\nja\n\n\nvar()\nberekent de variantie van een variabele\nja\n\n\nIQR()\nbepaalt de interkwartielafstand (IQR) van een variabele\nja\n\n\nquantile()\nbepaalt de kwantielen van een variabele, hiervoor moet je met het argument probs = aangeven welke kwantielen je wilt\nnee (alleen wanneer er maar een kwantiel wordt opgevraagd)\n\n\nsummary()\ngeeft een aantal beschrijvende statistieken van een variabele (min, max, 1e en 3e kwartiel, mediaan, gemiddelde)\nnee\n\n\n\nDe meeste van deze functies kunnen gecombineerd worden met summarize() (of summarise()), de Tidyverse-functie die je moet gebruiken om beschrijvende statistieken te berekenen. De functies die hier niet mee combineren kun je gebruiken met de $-notatie om er een variabele uit te lichten.\n\nsummary(wordbank_dutch_child$age)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n  16.00   18.00   23.00   22.01   24.00   31.00 \n\n\nEen alternatief hiervoor is de functie with() waarin je de naam van de datatabel waarin de variabele zit meegeeft:\n\nwith(wordbank_dutch_child,\n     quantile(age, probs = c(0, .25, .50, .75, 1)))\n\n  0%  25%  50%  75% 100% \n  16   18   23   24   31 \n\n\nMet summarize() kun je meerdere beschrijvende statistieken tegelijk laten berekenen. Je kunt hierbij zelf een naam geven aan de te berekenen maat. Deze naam komt voor het =-teken.\n\nwordbank_dutch_child %&gt;% \n  summarize(mean_age = mean(age),\n            sd_age = sd(age),\n            mean_comprehension = mean(comprehension),\n            median_comprehension = median(comprehension))\n\n# A tibble: 1 × 4\n  mean_age sd_age mean_comprehension median_comprehension\n     &lt;dbl&gt;  &lt;dbl&gt;              &lt;dbl&gt;                &lt;dbl&gt;\n1     22.0   4.47               412.                  402\n\n\nDe functie summarize() kun je combineren met group_by() om beschrijvende statistieken per level van een (andere) variabele te berekenen.\n\nwordbank_dutch_child %&gt;%\n  group_by(age) %&gt;% \n  summarize(mean_comprehension = mean(comprehension),\n            mean_production = mean(production)) %&gt;% \n  print(n = 4)\n\n# A tibble: 16 × 3\n    age mean_comprehension mean_production\n  &lt;dbl&gt;              &lt;dbl&gt;           &lt;dbl&gt;\n1    16               125.            32.5\n2    17               243.            50.5\n3    18               282.            65.2\n4    19               257.            83  \n# ℹ 12 more rows\n\n\nIn long format kunnen we group_by ook gebruiken om beschrijvende statistieken voor combinaties van variabelen te berekenen:\n\ndutch_child_long %&gt;%\n  group_by(age, skill) %&gt;% \n  summarize(mean_number_words = mean(number_of_words)) %&gt;% \n  print(n = 4)\n\n`summarise()` has grouped output by 'age'. You can override using the `.groups`\nargument.\n\n\n# A tibble: 32 × 3\n# Groups:   age [16]\n    age skill         mean_number_words\n  &lt;dbl&gt; &lt;fct&gt;                     &lt;dbl&gt;\n1    16 comprehension             125. \n2    16 production                 32.5\n3    17 comprehension             243. \n4    17 production                 50.5\n# ℹ 28 more rows\n\n\nHet package skimr biedt een functie skim() die je in een keer een overzicht geeft van allerlei statistieken, waaronder ook aantal observaties en missing data, gesorteerd voor categorische en numerieke variabele apart. Hiervoor moet je het package skim natuurlijk wel geïnstalleerd hebben en aanroepen.\n\nlibrary(skimr)\n\n\nwordbank_dutch_child %&gt;% \n  skim()\n\n\n\n\n\nName\nPiped data\n\n\nNumber of rows\n303\n\n\nNumber of columns\n4\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nfactor\n1\n\n\nnumeric\n3\n\n\n________________________\n\n\n\nGroup variables\nNone\n\n\n\nData summaryVariable type: factor\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nordered\nn_unique\ntop_counts\n\n\n\n\nchild_id\n0\n1\nFALSE\n210\n766: 3, 766: 3, 766: 3, 766: 3\n\n\n\nVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nage\n0\n1\n22.01\n4.47\n16\n18.0\n23\n24.0\n31\n▇▁▆▁▃\n\n\ncomprehension\n0\n1\n412.39\n188.30\n17\n266.0\n402\n588.5\n703\n▃▆▆▅▇\n\n\nproduction\n0\n1\n237.49\n219.71\n0\n44.5\n146\n431.5\n696\n▇▂▂▂▂\n\n\n\n\n\nDe functie produceert zelfs een klein histogram om de verdeling van numerieke variabelen weer te geven. Door de naam van een variabele in te vullen in skim() krijg je alleen het overzicht voor die variabele. Ook deze functie kun je gebruiken in combinatie met group_by():\n\ndutch_child_long %&gt;%\n  group_by(skill) %&gt;% \n  skim(number_of_words)\n\n\n\n\n\nName\nPiped data\n\n\nNumber of rows\n606\n\n\nNumber of columns\n4\n\n\n_______________________\n\n\n\nColumn type frequency:\n\n\n\nnumeric\n1\n\n\n________________________\n\n\n\nGroup variables\nskill\n\n\n\nData summaryVariable type: numeric\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nskim_variable\nskill\nn_missing\ncomplete_rate\nmean\nsd\np0\np25\np50\np75\np100\nhist\n\n\n\n\nnumber_of_words\ncomprehension\n0\n1\n412.39\n188.30\n17\n266.0\n402\n588.5\n703\n▃▆▆▅▇\n\n\nnumber_of_words\nproduction\n0\n1\n237.49\n219.71\n0\n44.5\n146\n431.5\n696\n▇▂▂▂▂"
  },
  {
    "objectID": "numeriek.html#centrummaten-zichtbaar-maken",
    "href": "numeriek.html#centrummaten-zichtbaar-maken",
    "title": "7  Numerieke variabelen",
    "section": "7.3 Centrummaten zichtbaar maken",
    "text": "7.3 Centrummaten zichtbaar maken\nBerekende beschrijvende statistieken van numerieke variabelen kunnen we zichtbaar maken met ggplot. We gebruiken hiervoor geom_point() i.p.v. een staafdiagram. Dit vanwege de within-the-bar-bias en omdat we later ook de ruwe datapunten zichtbaar willen maken. We berekenen als voorbeeld eerst het gemiddelde aantal begrepen en geproduceerde woorden per leeftijd:\n\ndutch_means &lt;- dutch_child_long %&gt;% \n  group_by(age, skill) %&gt;% \n  summarize(mean_number_words = mean(number_of_words))\n\n`summarise()` has grouped output by 'age'. You can override using the `.groups`\nargument.\n\ndutch_means\n\n# A tibble: 32 × 3\n# Groups:   age [16]\n     age skill         mean_number_words\n   &lt;dbl&gt; &lt;fct&gt;                     &lt;dbl&gt;\n 1    16 comprehension             125. \n 2    16 production                 32.5\n 3    17 comprehension             243. \n 4    17 production                 50.5\n 5    18 comprehension             282. \n 6    18 production                 65.2\n 7    19 comprehension             257. \n 8    19 production                 83  \n 9    20 comprehension             414. \n10    20 production                188. \n# ℹ 22 more rows\n\n\nVervolgens plotten we deze met behulp van geom_point() waarbij we de twee typen skills weer hun eigen kleur geven.\n\ndutch_means %&gt;% \n  ggplot(aes(x = age, y = mean_number_words, color = skill)) +\n  geom_point(size = 3, alpha = .7) +\n  labs(y = \"mean number of words\",\n       x = \"age in months\",\n       title = \"Word comprehension and production by age\") +\n  scale_color_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  theme_minimal(14)\n\n\n\n\nFiguur 7.2: Gemiddelde begrip en productie van woorden in een dotplot.\n\n\n\n\nBovenstaande grafiek is niet (of moeilijk) te maken met wide format, aangezien we een variabele (skill) willen afbeelden op de kleur van de punten. Het wide format is wel geschikt om ruwe data te plotten. Die gaan we nu toevoegen."
  },
  {
    "objectID": "numeriek.html#de-data-zichtbaar-maken",
    "href": "numeriek.html#de-data-zichtbaar-maken",
    "title": "7  Numerieke variabelen",
    "section": "7.4 De data zichtbaar maken",
    "text": "7.4 De data zichtbaar maken\nCentrummaten geven maar een erg beperkt beeld van de data. We willen daarom naast de centrummaat (hier het gemiddelde) ook iets van de spreiding in de data laten zien. We doen dat door van elk kind de geobserveerde waarde te plotten. Op basis van deze geobserveerde waardes hebben we het gemiddelde per leeftijd berekend.\nWe gebruiken als basis de code voor Figuur 7.2. Om de grafiek overzichtelijk te houden voegen we alleen de datapunten voor production toe. We voegen aan deze grafiek de observaties per kind een tweede aanroep van geom_point() toe (regel 4) waarbij we de waardes uit een andere datatabel (wordbank_dutch_child) halen dan waar we de gemiddelden uit halen (dutch_means). De volgorde van de twee aanroepen van geom_point() is hier belangrijk. Om de gemiddelden over de individuele punten heen te plotten gebruiken we de eerste aanroep voor de individuele punten en de tweede aanroep voor de gemiddelden. We voegen aan het tweede geom explicet de dataset toe met het argument data = (anders zou de dataset van ggplot() woren overgenomen) en we maken ook een nieuwe aes() aan (regel 4). De individuele punten willen we zichtbaar houden en daarom zetten we alpha wat lager en om de punten te onderscheiden van de punten die het gemiddelde weergeven maken we de observaties van individuele kinderen grijs. We lichten de betekenis van de twee punten toe door een caption toe te voegen aan de figuur onder labs() (regel 9).\n\ndutch_means %&gt;%\n  filter(skill == \"production\") %&gt;% \n  ggplot(aes(x = age, y = mean_number_words )) +\n  geom_point(data = wordbank_dutch_child, aes(x = age, y = production), color = \"grey80\", alpha = .4) +\n  geom_point(color = \"deepskyblue4\", size = 3, alpha = .5) +\n  labs(y = \"mean number of words\",\n       x = \"age in months\",\n       title = \"Word production by age\",\n       caption = \"large circles show mean per age group\\nsmall circles show scores of individual children\") +\n  theme_minimal(14)\n\n\n\n\nWat valt op? We zien dat er veel variatie in aantal kinderen per leeftijd zit en dat er veel variatie in de spreiding om het gemiddelde per leeftijd zit. Bij de leeftijd van 23 is deze spreiding bijvoorbeeld enorm en bij 19 maanden heel beperkt, terwijl bij 26 maanden de individuele observaties erg ver van het gemiddelde afliggen. Het toevoegen van de individuele datapunten maakt meteen duidelijk dat het gemiddelde niet altijd een goede weergave van de onderliggende data is. Je zou nu zelf een vergelijkbare grafiek kunnen maken voor woordbegrip."
  },
  {
    "objectID": "numeriek.html#rainclouds",
    "href": "numeriek.html#rainclouds",
    "title": "7  Numerieke variabelen",
    "section": "7.5 rainclouds?",
    "text": "7.5 rainclouds?\n\nlibrary(see)\n\nWarning: package 'see' was built under R version 4.3.3\n\n\n\ndutch_child_long %&gt;% \n  ggplot(aes(y = number_of_words, x = skill, fill = skill)) +\n  geom_violindot(fill_dots = \"black\", dots_size = 200, alpha = .3) +\n  scale_fill_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  scale_color_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  labs(y = \"number of words\") +\n  coord_flip() +\n  theme_minimal(13) +\n  theme(legend.position = \"none\")\n\n\n\n\n\nlibrary(ggrain)\n\nWarning: package 'ggrain' was built under R version 4.3.2\n\n\nRegistered S3 methods overwritten by 'ggpp':\n  method                  from   \n  heightDetails.titleGrob ggplot2\n  widthDetails.titleGrob  ggplot2\n\n\n\ndutch_child_long %&gt;% \n  ggplot(aes(y = number_of_words, x = skill, fill = skill)) +\n  geom_rain(alpha = .5) +\n  scale_fill_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  scale_color_manual(values = c(\"bisque3\", \"deepskyblue4\")) +\n  labs(y = \"number of words\") +\n  coord_flip() +\n  theme_minimal(13) +\n  theme(legend.position = \"none\")\n\n\n\n\nhttps://cran.r-project.org/web/packages/ggrain/vignettes/ggrain.html"
  },
  {
    "objectID": "numeriek.html#verder-leren",
    "href": "numeriek.html#verder-leren",
    "title": "7  Numerieke variabelen",
    "section": "7.6 Verder leren",
    "text": "7.6 Verder leren"
  },
  {
    "objectID": "practica.html#hoe-haal-je-het-meeste-uit-een-practicum",
    "href": "practica.html#hoe-haal-je-het-meeste-uit-een-practicum",
    "title": "Practica",
    "section": "Hoe haal je het meeste uit een practicum?",
    "text": "Hoe haal je het meeste uit een practicum?\nTijdens de practica lopen de docent en studentassistent rond om vragen te beantwoorden. Je haalt dus het meeste uit een practicum door vragen te stellen. Hiervoor moet je natuurlijk wel vragen hebben. Een goede voorbereiding is hierbij de sleutel. We zien maar al te vaak dat studenten onvoorbereid op het practicum komen en ter plekke de documenten openen. Het resultaat is dat ze aan het eind van het practicum nog met de eerste opdrachten bezig zijn en niet aan de latere opdrachten toekomen, die vaak moeilijker zijn. Die opdrachten moet je dan zonder hulp maken. Verstandiger is het dus om goed voorbereid op het practicum te komen. Hoe bereid je je goed voor?\n\nBestudeer de opgegeven hoofdstukken ter voorbereiding op het practicum. Zie hiervoor ook het overzicht in Tabel 1;\nMaak voor jezelf een overzicht van de functies die in de hoofdstukken worden besproken. Voeg deze toe aan je eigen codeboek;\nLees de practicumopdrachten door en bedenk welke functies je bij iedere opdracht zou kunnen gebruiken. Noteer deze bij de opdracht of in een apart document;\nMaak een scriptbestand aan voor het practicum (zie hieronder) en werk al wat code uit. Kijk tegen welke problemen je aanloopt en stel hier vragen over op het practicum.\n\n\n\n\n\n\n\n\n\n\n\nPracticum\nOnderwerp\nVoorbereiding\n\n\n\n\n1\nWerken met data in R\nhoofdstukken 1, 2 en 3\n\n\n2\nBewerken van data\nHoofdstuk 4\n\n\n3\nGrafieken maken met ggplot\nHoofdstuk 5\n\n\n\nTabel 1: voorbereiding per practicum"
  },
  {
    "objectID": "practica.html#wat-heb-je-nodig",
    "href": "practica.html#wat-heb-je-nodig",
    "title": "Practica",
    "section": "Wat heb je nodig?",
    "text": "Wat heb je nodig?\nJe werkt binnen RStudio. Zorg dat dit programma samen met R geïnstalleerd is op je computer (zie sectie 2.1). We werken voor alle practica in hetzelfde R-project OBS_practica.Rproj. Download hiervoor het bestand OBS_practica.zip van Brightspace en pak dat uit op je eigen computer. Zet deze map op een handige locatie op je computer (bijv. in de map voor de cursus OBS). Je vindt in de map de volgende bestanden:\n\nOBS_practica.Rproj: hierin staat informatie voor RStudio over wat er allemaal bij de practica hoort.\neen map datasets: hierin vind je de databestanden die bij de practica in deze cursus gebruikt worden (uitgezonderd die voor de opdrachten). Zie het bestand ReadMe.txt voor meer informatie.\neen map templates_scripts_quarto: hierin vind je drie templates die je kunt gebruiken bij het uitwerken van je code voor een practicum. Zie het bestand ReadMe.txt voor meer informatie.\nvoornaam_achternaam_script_Practicum1.R: voor Practicum 1 hebben we al een script aangemaakt waarin je de practicumopdracht kunt maken. Dit is het document waarin je verschillende commando’s kunt uitwerken en vervolgens laten uitvoeren door R. Voor de volgende practica moet je dit zelf doen door een van de templates te kopiëren uit de map templates_scripts_quarto. Verander voor je begint de naam van het bestand door je eigen voor- en achternaam en het cijfer van het betreffende practicum in te vullen (dus bijv. peter_deswart_script_Practicum1.R)."
  },
  {
    "objectID": "practica.html#aan-de-slag",
    "href": "practica.html#aan-de-slag",
    "title": "Practica",
    "section": "Aan de slag",
    "text": "Aan de slag\nJe begint elk practicum door het bestand OBS_practica.Rproj te openen (en dus niet het programma RStudio). Wen jezelf dit aan. Op deze manier heb je namelijk meteen toegang tot alle relevante bestanden. Het scheelt je een hoop foutmeldingen (en daarvan komen er nog genoeg). Om aan de slag te gaan, open je dus de aangemaakte folder voor de cursus (bijv. OBS) en dubbelklik je op OBS_practica.Rproj. RStudio opent dan en je kunt gaan werken aan de practicumopdrachten. Klik in het window rechtsonder (met de tab Files open) op voornaam_achternaam_script_Practicum1.R (dat je als het goed is al hebt aangepast naar je eigen naam). Let op: zorg dat je voor ieder practicum een nieuw script aanmaakt op basis van het templaat waarin je je eigen naam en het cijfer van het practicum aanpast. Wanneer je het script opent vanuit RStudio, zal het zichtbaar worden in een window linksboven in RStudio. In het script kun je je code gaan schrijven (denk aan de richtlijnen uit Sectie 3.3). De code kun je uitvoeren door met de cursor op de betreffende regel te gaan staan of een deel ervan te selecteren en vervolgens op ‘Run’ te klikken. Je kunt hier ook de toetscombinatie Ctrl + Enter (Cmd + enter op Mac) voor gebruiken (zie ook sectie 1.15 in het boek van Winter (2019) voor andere handige shortcuts die je kunt gebruiken). Het resultaat van de actie wordt dan zichtbaar in de R-console (linksonder in RStudio). Je kunt ook commentaar toevoegen in je script: alles op een regel na een # wordt niet door R uitgevoerd.\n\nWinter, B. (2019). Statistics for Linguists: An Introduction Using R. Routledge. https://doi.org/10.4324/9781315165547\nRStudio weet dat je met een R-script bezig bent en zal soms\n\nsuggesties geven voor te gebruiken functies;\ndingen die het herkent een kleurtje geven;\nspontaan dingen aanvullen, zoals haakjes;\nin de kantlijn een markering zetten als er iets niet lijkt te kloppen.\n\n\n\n\n\n\n\nLet op\n\n\n\nSla je script regelmatig op, zodat je geen code kwijtraakt. Klik hiervoor op het floppy-disk-symbool of gebruik de sneltoetsen Ctrl + S/cmd + S."
  },
  {
    "objectID": "_practica/practicum1.html",
    "href": "_practica/practicum1.html",
    "title": "Practicum 1",
    "section": "",
    "text": "Werken met data in R\nNu we de data beschikbaar hebben als datatabel in R, kunnen we ons gaan richten op de inhoud: hoe zien de data er precies uit?\nSoms worden variabelen door R niet herkend als het juiste type, of soms ontbreekt er informatie of wil je zelf nieuwe variabelen toevoegen. Gelukkig heb je de mogelijkheid om deze informatie in R aan te passen of toe te voegen. Let wel op dat dit goed gaat, want anders kun je bij latere analyses in de problemen komen."
  },
  {
    "objectID": "_practica/practicum1.html#leerdoelen",
    "href": "_practica/practicum1.html#leerdoelen",
    "title": "Practicum 1",
    "section": "Leerdoelen",
    "text": "Leerdoelen\n\nKennismaken met (data in) R\nInlezen van databestanden voor bewerking in R\nBewerken van variabelen in R"
  },
  {
    "objectID": "_practica/practicum1.html#voorbereiding",
    "href": "_practica/practicum1.html#voorbereiding",
    "title": "Practicum 1",
    "section": "Voorbereiding",
    "text": "Voorbereiding\nLees hoofdstukken 1 t/m 3 uit het dictaat. De benodigde R-functies zijn te vinden in het dictaat. Functies die niet in het dictaat besproken worden, worden gegeven in de opdracht. Lees ook de algemene richtlijnen voor practica door."
  },
  {
    "objectID": "_practica/practicum1.html#introductie",
    "href": "_practica/practicum1.html#introductie",
    "title": "Practicum 1",
    "section": "Introductie",
    "text": "Introductie\nEen taalwetenschapper wil weten of training met een computerprogramma helpt bij het leren van vaste uitdrukkingen door tweedetaalleerders van het Nederlands ten opzichte van een klassikale methode. Het voordeel van het computerprogramma is dat deelnemers gedetailleerde feedback krijgen, terwijl dit klassikaal een stuk moeilijker is. De onderzoeker verwacht daarom dat mensen die met het computerprogramma oefenen meer Nederlandse uitdrukkingen kennen, dan mensen die hebben gewerkt via een klassikale methode.\nOm dit te onderzoeken werden Duitse leerders van het Nederlands onderworpen aan een voormeting (pre-test) om hun kennis van Nederlandse uitdrukkingen te testen. Vervolgens werd de groep participanten in tweeën verdeeld. Groep 1 mocht oefenen met het computerprogramma, terwijl groep 2 klassikaal ging oefenen met uitdrukkingen. Na een week van oefenen werden de deelnemers opnieuw getest op hun kennis van uitdrukkingen. In deze practicumopdracht ga je werken met de data van deze onderzoeker.\n\n\n\n\n\n\nLet op\n\n\n\nSla je script regelmatig op, zodat je geen code kwijtraakt. Klik hiervoor op het floppy-disk-symbool of gebruik de sneltoetsen Ctrl + S/cmd + S.\n\n\n\n\n\n\n\n\nProbeer het eerst zelf!\n\n\n\nBij de opdrachten vind je naast een beschrijving van de vraag ook een Hint en de Code. Dit om je te helpen als je even niet verder komt. Hoe verleidelijk het ook is om meteen naar het antwoord te gaan, doe dit niet. Houd je aan de volgorde: probeer het eerst zelf, lukt dat niet gebruik de hint, mocht je dan nog vastzitten en er echt niet uitkomen ga dan pas naar het antwoord. Dit gaat je op de lange termijn ontzettend helpen."
  },
  {
    "objectID": "_practica/practicum1.html#eerste-zes-rijen-zichtbaar-maken",
    "href": "_practica/practicum1.html#eerste-zes-rijen-zichtbaar-maken",
    "title": "Practicum 1",
    "section": "Eerste zes rijen zichtbaar maken",
    "text": "Eerste zes rijen zichtbaar maken\n\nOpdrachtHintCode\n\n\nMaak de eerste zes rijen van het databestand zichtbaar om te kijken hoe de data eruitzien.\n\n\nGebruik de functie head(), zie sectie 3.2.1.\n\n\n\n# Eerste zes rijen zichtbaar maken\n head(uitdrukkingen)\n\n# A tibble: 6 × 6\n  Proefpersoon Geslacht Groep Geboortejaar PercentageCorrect_Voormeting\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;        &lt;dbl&gt;                        &lt;dbl&gt;\n1            1 M            1         1988                           20\n2            2 V            2         1992                           36\n3            3 M            1         1995                           15\n4            4 M            2         1997                           55\n5            5 V            1         1987                           43\n6            6 V            2         1999                           11\n# ℹ 1 more variable: PercentageCorrect_Nameting &lt;dbl&gt;"
  },
  {
    "objectID": "_practica/practicum1.html#aantal-rijen-en-kolommen",
    "href": "_practica/practicum1.html#aantal-rijen-en-kolommen",
    "title": "Practicum 1",
    "section": "Aantal rijen en kolommen",
    "text": "Aantal rijen en kolommen\n\nOpdrachtHintCode\n\n\nHoeveel rijen (observaties) en kolommen (variabelen) telt de dataset? Gebruik hiervoor de relevante R-functies\n\n\nGebruik de functies nrow() en ncol(), zie sectie 3.1.\n\n\n\n# Aantal rijen en kolommen vaststellen\n ncol(uitdrukkingen)\n\n[1] 6\n\n nrow(uitdrukkingen)\n\n[1] 10"
  },
  {
    "objectID": "_practica/practicum1.html#de-functie-view",
    "href": "_practica/practicum1.html#de-functie-view",
    "title": "Practicum 1",
    "section": "De functie View()",
    "text": "De functie View()\n\nOpdrachtCode\n\n\nEen andere manier om de dataset zichtbaar te maken is via de functie View().Deze functie is echter alleen te gebruiken in RStudio. Maak de dataset zichtbaar met deze functie.\n\n\n\n#Dataset zichtbaar maken\n  View(uitdrukkingen)"
  },
  {
    "objectID": "_practica/practicum1.html#namen-van-de-variabelen",
    "href": "_practica/practicum1.html#namen-van-de-variabelen",
    "title": "Practicum 1",
    "section": "Namen van de variabelen",
    "text": "Namen van de variabelen\n\nOpdrachtHintAntwoord\n\n\nDe namen van de variabelen in de aangeleverde dataset voldoen niet aan onze richtlijnen. Wat is het probleem?\n\n\nZie Secties 3.2.1.\n\n\nDe namen maken geen gebruik van snake_case. Er worden hoofdletters gebruikt en soms worden inhoudswoorden aan elkaar geschreven.\n\n\n\n\nOpdrachtHintCode\n\n\nPas de namen van de variabelen de datatabel aan zodat ze voldoen aan onze richtlijnen.\n\n\nJe kunt dit handmatig doen met de functie rename() of met de functie clean_names() uit het package janitor. Zie Sectie 3.2.1.\n\n\n\n# Aanpassen namen variabelen\nuitdrukkingen &lt;- janitor::clean_names(uitdrukkingen)\n\n\n# alternatief handmatig\nuitdrukkingen &lt;- rename(.data = uitdrukkingen,\n                        proefpersoon = Proefpersoon,\n                        geslacht = Geslacht,\n                        groep = Groep,\n                        geboortejaar = Geboortejaar,\n                        percentage_correct_voormeting = PercentageCorrect_Voormeting,\n                        percentage_correct_nameting = PercentageCorrect_Nameting\n                        )"
  },
  {
    "objectID": "_practica/practicum1.html#meetniveaus-van-de-variabelen",
    "href": "_practica/practicum1.html#meetniveaus-van-de-variabelen",
    "title": "Practicum 1",
    "section": "Meetniveaus van de variabelen",
    "text": "Meetniveaus van de variabelen\n\nOpdracht\n\n\nBeschrijf de meetniveaus van alle variabelen in het databestand en geef kort aan waarom je voor de betreffende meetniveaus gekozen hebt."
  },
  {
    "objectID": "_practica/practicum1.html#details-van-variabelen-opvragen",
    "href": "_practica/practicum1.html#details-van-variabelen-opvragen",
    "title": "Practicum 1",
    "section": "Details van variabelen opvragen",
    "text": "Details van variabelen opvragen\n\nOpdrachtHintCode\n\n\nGebruik de functie str() om de details van de variabelen in het databestand op te vragen. Op deze manier kun je zien van welk type de variabelen volgens R zijn. Kloppen deze door R toegekende typen met de meetniveaus uit de vorige vraag?\n\n\nZie Tabel 3.1. Zie ook secties 1.5-1.9 uit SfL voor de verschillende type variabelen in R.\n\n\n\n# Details variabelen opvragen\n str(uitdrukkingen)\n\nspc_tbl_ [10 × 6] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ proefpersoon                 : num [1:10] 1 2 3 4 5 6 7 8 9 10\n $ geslacht                     : chr [1:10] \"M\" \"V\" \"M\" \"M\" ...\n $ groep                        : num [1:10] 1 2 1 2 1 2 1 2 1 2\n $ geboortejaar                 : num [1:10] 1988 1992 1995 1997 1987 ...\n $ percentage_correct_voormeting: num [1:10] 20 36 15 55 43 11 18 29 25 33\n $ percentage_correct_nameting  : num [1:10] 60 46 88 75 81 55 69 45 83 78\n - attr(*, \"spec\")=\n  .. cols(\n  ..   Proefpersoon = col_double(),\n  ..   Geslacht = col_character(),\n  ..   Groep = col_double(),\n  ..   Geboortejaar = col_double(),\n  ..   PercentageCorrect_Voormeting = col_double(),\n  ..   PercentageCorrect_Nameting = col_double()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt;"
  },
  {
    "objectID": "_practica/practicum1.html#aanpassen-van-het-type-van-een-variabele",
    "href": "_practica/practicum1.html#aanpassen-van-het-type-van-een-variabele",
    "title": "Practicum 1",
    "section": "Aanpassen van het type van een variabele",
    "text": "Aanpassen van het type van een variabele\n\nOpdrachtHintCode\n\n\nVerander de variabele proefpersoon in een factor, zodat het door R als een categoriale variabele herkend wordt. Doe hetzelfde voor de variabelen groep en geslacht.\n\n\nGebruik de functie mutate() in combinatie met as.factor(), zie sectie 3.2.2.\n\n\n\n# Aanpassen datatype variabelen\nuitdrukkingen &lt;- mutate(\n  .data = uitdrukkingen,\n  proefpersoon = as.factor(proefpersoon),\n  groep = as.factor(groep),\n  geslacht = as.factor(geslacht)\n)\n      \n# Controleren\nstr(uitdrukkingen)\n\ntibble [10 × 6] (S3: tbl_df/tbl/data.frame)\n $ proefpersoon                 : Factor w/ 10 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10\n $ geslacht                     : Factor w/ 2 levels \"M\",\"V\": 1 2 1 1 2 2 2 2 1 2\n $ groep                        : Factor w/ 2 levels \"1\",\"2\": 1 2 1 2 1 2 1 2 1 2\n $ geboortejaar                 : num [1:10] 1988 1992 1995 1997 1987 ...\n $ percentage_correct_voormeting: num [1:10] 20 36 15 55 43 11 18 29 25 33\n $ percentage_correct_nameting  : num [1:10] 60 46 88 75 81 55 69 45 83 78"
  },
  {
    "objectID": "_practica/practicum1.html#toevoegen-namen-van-levels",
    "href": "_practica/practicum1.html#toevoegen-namen-van-levels",
    "title": "Practicum 1",
    "section": "Toevoegen namen van levels",
    "text": "Toevoegen namen van levels\n\nOpdrachtHintCode\n\n\nVoeg nu de bijbehorende namen van de levels aan de variabele groep toe: computer en klassikaal.\n\n\nGebruik de functie fct_recode(), zie Sectie 3.2.2.\n\n\n\n# Toevoegen van namen aan levels\nuitdrukkingen &lt;- mutate(uitdrukkingen,\n                        groep = fct_recode(groep,\n                                           computer = \"1\",\n                                           klassikaal = \"2\"\n                                           )\n                        )\n\n# Controleren\nstr(uitdrukkingen)\n\ntibble [10 × 6] (S3: tbl_df/tbl/data.frame)\n $ proefpersoon                 : Factor w/ 10 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10\n $ geslacht                     : Factor w/ 2 levels \"M\",\"V\": 1 2 1 1 2 2 2 2 1 2\n $ groep                        : Factor w/ 2 levels \"computer\",\"klassikaal\": 1 2 1 2 1 2 1 2 1 2\n $ geboortejaar                 : num [1:10] 1988 1992 1995 1997 1987 ...\n $ percentage_correct_voormeting: num [1:10] 20 36 15 55 43 11 18 29 25 33\n $ percentage_correct_nameting  : num [1:10] 60 46 88 75 81 55 69 45 83 78"
  },
  {
    "objectID": "_practica/practicum1.html#nieuwe-variabele-proportie_correct_voormeting-toevoegen",
    "href": "_practica/practicum1.html#nieuwe-variabele-proportie_correct_voormeting-toevoegen",
    "title": "Practicum 1",
    "section": "Nieuwe variabele proportie_correct_voormeting toevoegen",
    "text": "Nieuwe variabele proportie_correct_voormeting toevoegen\n\nOpdrachtHintCode\n\n\nDe variabele percentage_correct_voormeting geeft het aantal goede antwoorden op de voormeting weer als een percentage. Maak een nieuwe variabele proportie_correct_voormeting waarin het aantal goede antwoorden wordt weergegeven als een proportie. Wat is volgens R het type van deze nieuwe variabele? Leg uit waarom R voor dit type kiest.\n\n\nZowel percentage als proportie geven het deel van een geheel weer. Het verschil is dat een percentage loopt van 0-100 en een proportie van 0-1. Voor het aanmaken van nieuwe variabelen gebruiken we de functie mutate(), zie Sectie 3.2.2.\n\n\n\n# Toevoegen variabele met proportie\nuitdrukkingen &lt;- mutate(uitdrukkingen,\n                       proportie_correct_voormeting = percentage_correct_voormeting/100\n                       )\n\n# Controleren type van de variabele\nstr(uitdrukkingen)\n\ntibble [10 × 7] (S3: tbl_df/tbl/data.frame)\n $ proefpersoon                 : Factor w/ 10 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10\n $ geslacht                     : Factor w/ 2 levels \"M\",\"V\": 1 2 1 1 2 2 2 2 1 2\n $ groep                        : Factor w/ 2 levels \"computer\",\"klassikaal\": 1 2 1 2 1 2 1 2 1 2\n $ geboortejaar                 : num [1:10] 1988 1992 1995 1997 1987 ...\n $ percentage_correct_voormeting: num [1:10] 20 36 15 55 43 11 18 29 25 33\n $ percentage_correct_nameting  : num [1:10] 60 46 88 75 81 55 69 45 83 78\n $ proportie_correct_voormeting : num [1:10] 0.2 0.36 0.15 0.55 0.43 0.11 0.18 0.29 0.25 0.33"
  },
  {
    "objectID": "_practica/practicum1.html#nieuwe-variabele-verschil_metingen-toevoegen",
    "href": "_practica/practicum1.html#nieuwe-variabele-verschil_metingen-toevoegen",
    "title": "Practicum 1",
    "section": "Nieuwe variabele verschil_metingen toevoegen",
    "text": "Nieuwe variabele verschil_metingen toevoegen\n\nOpdrachtHintCode\n\n\nMaak nu een nieuwe variabele in het databestand met de naam verschil_metingen. Deze variabele moet het verschil weergeven tussen de nameting en de voormeting.\n\n\nOok hierbij kun je de functie mutate() gebruiken, zie Sectie 3.2.2.\n\n\n\n# Variabele verschil_metingen aanmaken\nuitdrukkingen &lt;- mutate(uitdrukkingen,\n                       verschil_metingen = percentage_correct_nameting - percentage_correct_voormeting\n                       )"
  },
  {
    "objectID": "_practica/practicum1.html#nieuwe-variabele-leeftijd-toevoegen",
    "href": "_practica/practicum1.html#nieuwe-variabele-leeftijd-toevoegen",
    "title": "Practicum 1",
    "section": "Nieuwe variabele leeftijd toevoegen",
    "text": "Nieuwe variabele leeftijd toevoegen\n\nOpdrachtHintCode\n\n\nEen van de variabelen in het databestand is geboortejaar. Voeg een nieuwe variabele leeftijd toe aan het databestand. Het experiment is afgenomen in 2017. Bereken automatisch de leeftijd op basis van het geboortejaar van de participanten met behulp van R.\n\n\nEn ook dit kan met de functie mutate(), zie Sectie 3.2.2.\n\n\n\n# Toevoegen variabele leeftijd\n uitdrukkingen &lt;- mutate(uitdrukkingen,\n                         leeftijd = 2017 - geboortejaar\n                         )"
  },
  {
    "objectID": "_practica/practicum1.html#een-grafiek-maken",
    "href": "_practica/practicum1.html#een-grafiek-maken",
    "title": "Practicum 1",
    "section": "Een grafiek maken",
    "text": "Een grafiek maken\nLaten we de functionaliteit van het tidyverse meteen ook maar gebruiken om een grafiek te maken. We maken een grafiek waarin we het percentage correct op de nameting uitzetten tegen dat van de voormeting en we geven elk datapunt een kleur afhankelijk van de groep waartoe deze behoort. We gebruiken hiervoor ggplot2, het populairste onderdeel van tidyverse waar je in de rest van de cursus nog veel over gaat leren (vanaf Hoofdstuk 5).\n\nOpdrachtHintCode\n\n\nHieronder vind je een deel van de code om de grafiek te maken, alleen de variabelen ontbreken nog. Kopieer onderstaande code, voeg de variabelen op de juiste puntjes (…) in en voer de code uit. Bekijk het resultaat: zie je verschil tussen de twee groepen?\n\n#deel van de code voor een grafiek waarin percentage_correct_nameting wordt uitgezet tegen percentage_correct_voormeting\n\nuitdrukkingen %&gt;% \n  ggplot(aes(x = ..., \n             y = ..., \n             colour = ...)) +\n  geom_point(size = 3) +\n  theme_minimal(13)\n\n\n\nIn deze grafiek zetten we variabele Y uit tegen variabele X. De kleur willen we laten variëren per groep waartoe de leerder behoort.\n\n\n\n#code voor een grafiek waarin percentage_correct_nameting wordt uitgezet tegen percentage_correct_voormeting\n\nuitdrukkingen %&gt;% \n  ggplot(aes(x = percentage_correct_voormeting, \n             y = percentage_correct_nameting, \n             colour = groep)) +\n  geom_point(size = 3) +\n  theme_minimal(16)"
  },
  {
    "objectID": "_practica/practicum2.html",
    "href": "_practica/practicum2.html",
    "title": "Practicum 2",
    "section": "",
    "text": "Bewerken van data\nIn de volgende opgaven ga je de belangrijke Tidyverse-functies filter(), select(), mutate() en arrange() uitproberen en andere handige functies beschreven in Hoofdstuk 4. N.B. Elke opgave begint met de tibble ww zoals je dat aan het eind van de vorige opdracht hebt gemaakt. Zorg er dus voor dat je deze tibble niet verandert, tenzij dit nadrukkelijk wordt gevraagd. Voor de zekerheid kun je deze tibble ook nog onder een andere naam opslaan (bijv. ww_backup &lt;- ww). Je kunt dan altijd terug naar je oorspronkelijke dataset (via ww_backup -&gt; ww).\nWe gaan nu data toevoegen aan onze oorspronkelijke dataset ww. Deze informatie halen we uit het databestand hulpwerkwoorden.txt. Dit databestand zullen we eerst moeten inlezen en vervolgens moeten we controleren of de gegevens goed gecodeerd zijn in R. Net zoals we eerder hebben gedaan voor de dataset werkwoorden.csv.\nLaten we nu eens proberen of we relevantie informatie uit onze data kunnen halen voor het nagaan van de vermoedens van de onderzoeker (zie hiervoor de introductie). Je gebruikt hierbij o.a. de functies group_by(), summarize() en count(). Zie sectie 4.5 of het dplyr cheatsheet. Werk op basis van het data frame ww_compleet.\nVaak wil je een aantal regels van je data zichtbaar maken. Bijvoorbeeld om te controleren of het inlezen van de data goed is gegaan, zoals we aan het begin van dit practicum hebben gedaan. Je kunt hier de functies head() en tail() gebruiken voor de eerste of de laatste regels van je bestand. Soms wil je echter juist in het midden van je dataset kijken of een random aantal observaties bekijken. In dat geval kun je gebruik maken van de (varianten van de) functie slice_, zie sectie 4.2."
  },
  {
    "objectID": "_practica/practicum2.html#leerdoelen",
    "href": "_practica/practicum2.html#leerdoelen",
    "title": "Practicum 2",
    "section": "Leerdoelen",
    "text": "Leerdoelen\n\nFilteren, splitsen en sorteren van data\nSamenvoegen van datatabellen\nMaken van simpele numerieke samenvattingen van data\nAanmaken van een steekproef uit een grotere dataset\nBekend raken met de belangrijkste ‘werkwoorden’ uit het tidyverse: filter(), arrange(), select(), mutate(), summarize(), group_by() en de pipe operator %&gt;%."
  },
  {
    "objectID": "_practica/practicum2.html#voorbereiding",
    "href": "_practica/practicum2.html#voorbereiding",
    "title": "Practicum 2",
    "section": "Voorbereiding",
    "text": "Voorbereiding\nLees hoofdstuk 4 uit het dictaat. De benodigde R-functies zijn te vinden in het dictaat (zie ook eerdere hoofdstukken en practica). Functies die niet in het dictaat besproken worden, worden gegeven in de opdracht. Het dplyr cheatsheet geeft een overzicht van relevante functies. Lees ook de algemene richtlijnen voor practica door."
  },
  {
    "objectID": "_practica/practicum2.html#sec-pr2-intro",
    "href": "_practica/practicum2.html#sec-pr2-intro",
    "title": "Practicum 2",
    "section": "Introductie",
    "text": "Introductie\nEen taalwetenschapper doet onderzoek naar (on)regelmatigheid van werkwoorden in het Nederlands. In dit onderzoek is de taalwetenschapper geïnteresseerd in de relatie met etymologische leeftijd (wanneer een werkwoord is ontstaan) en met frequentie van voorkomen. Aangezien er een tendens lijkt te zijn om taal regelmatiger te maken, vermoedt de onderzoeker dat onregelmatige werkwoorden (bijv. blijken – bleek) etymologisch gezien vaker terug te voeren zijn op oudere taalstadia. Regelmatige werkwoorden (bijv. groeien – groeide) daarentegen zullen vaker recentelijker ontstaan zijn. Gezien de tendens om woorden regelmatiger te maken, vermoedt de onderzoeker daarnaast dat onregelmatige werkwoorden een hogere woordfrequentie zullen hebben. Deze hebben ze nodig om onregelmatig te blijven: wanneer taalgebruikers een werkwoord vaak horen in onregelmatige vorm, dan zal het werkwoord niet zo snel worden omgezet naar een regelmatige vorm.\nOm deze hypothesen te onderzoeken heeft de taalwetenschapper van een grote groep Nederlandse werkwoorden informatie verzameld, waaronder de etymologische leeftijd en de woordfrequentie. Voor elk werkwoord heeft hij bepaald in welk deel van de taalgeschiedenis ze ontstaan zijn. Hiertoe maakt hij onderscheid in 5 taalstadia (van oud naar jong): IndoEuropees, Germaans, WestGermaans, Duits/Nederlands, Nederlands. Van elk woord heeft hij ook de woordfrequentie bepaald door te tellen hoe vaak ze voorkomen in een groot corpus van geschreven taal. Daarnaast heeft hij van elk werkwoord de lengte in letters geteld. Deze data heeft hij opgeslagen in het databestand werkwoorden.csv. De onderzoeker is vervolgens ook voor elk werkwoord nagegaan welke type hulpwerkwoord het werkwoord neemt in de voltooide tijd. Deze informatie heeft hij opgeslagen in het databestand hulpwerkwoorden.txt.11 De data zijn afkomstig uit de dataset etymology in het package languageR.\n\n\n\n\n\n\nLet op\n\n\n\nSla je script regelmatig op, zodat je geen code kwijtraakt. Klik hiervoor op het floppy-disk-symbool of gebruik de sneltoetsen Ctrl + S/cmd + S.\n\n\n\n\n\n\n\n\nProbeer het eerst zelf!\n\n\n\nBij de opdrachten vind je naast een beschrijving van de vraag ook een Hint en de Code. Dit om je te helpen als je even niet verder komt. Hoe verleidelijk het ook is om meteen naar het antwoord te gaan, doe dit niet. Houd je aan de volgorde: probeer het eerst zelf, lukt dat niet gebruik de hint, mocht je dan nog vastzitten en er echt niet uitkomen ga dan pas naar het antwoord. Dit gaat je op de lange termijn ontzettend helpen."
  },
  {
    "objectID": "_practica/practicum2.html#sec-read",
    "href": "_practica/practicum2.html#sec-read",
    "title": "Practicum 2",
    "section": "Databestand inlezen",
    "text": "Databestand inlezen\n\nOpdrachtHintCode\n\n\nLees het databestand werkwoorden.csv in met de bijpassende tidyverse-functie, geef de tibble de naam ww en maak de eerste zes rijen van de data zichtbaar om te kijken of het inlezen goed is gegaan.\n\n\nHet databestand werkwoorden.csv een puntkomma als scheidingsteken (open het maar eens). Zie verder Hoofdstuk 3. Het zichtbaar maken van de eerste zes rijen heb je vorige week ook geoefend.\n\n\n\n#N.B. in het eerste deel van de uitwerkingen maken we nog geen gebruik van de pipe-operator\n# Aanroepen package tidyverse (indien nog niet gedaan)\nlibrary(tidyverse)\n\n# Inlezen data onder naam 'ww'\n ww &lt;- read_csv2(\"datasets/werkwoorden.csv\")\n\n# N.B. hierboven wordt een relatief pad gebruikt naar het bestand. \n# Een absoluut pad zou ook werken (zie hoofdstuk 2)\n    \n    \n# Eerste zes rijen zichtbaar maken\n head(ww)\n\n# A tibble: 6 × 5\n  Werkwoord Frequentie Regelmatigheid Lengte EtyLeeftijd \n  &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;       \n1 blijken         9.88 irregular           5 Germanic    \n2 gloeien         6.91 regular             5 Germanic    \n3 glimmen         7.03 irregular           4 Germanic    \n4 rijzen          7.37 irregular           4 Germanic    \n5 werpen          8.49 irregular           4 Germanic    \n6 delven          6.17 irregular           4 WestGermanic\n\n\n\n\n\n\nOpdrachtHintCode\n\n\nPas de namen van de variabelen de datatabel aan zodat ze voldoen aan onze richtlijnen.\n\n\nJe kunt dit handmatig doen met de functie rename() of met de functie clean_names() uit het package janitor. Zie Sectie 3.2.1.\n\n\n\n# Aanpassen variabelennamen\n  ww &lt;- janitor::clean_names(ww)\n\n# Controleren of het goed is gegaan\n names(ww)\n\n[1] \"werkwoord\"      \"frequentie\"     \"regelmatigheid\" \"lengte\"        \n[5] \"ety_leeftijd\""
  },
  {
    "objectID": "_practica/practicum2.html#aantal-observaties-en-variabelen",
    "href": "_practica/practicum2.html#aantal-observaties-en-variabelen",
    "title": "Practicum 2",
    "section": "Aantal observaties en variabelen",
    "text": "Aantal observaties en variabelen\n\nOpdrachtHintCode\n\n\nHoeveel observaties (rijen) en variabelen (kolommen) telt de dataset?\n\n\nVorige week hebben we hiervoor de functies nrow() en ncol() geleerd.\n\n\n\n# Aantal observaties (rijen) en variabelen (kolommen)\n  nrow(ww); ncol(ww)\n\n[1] 285\n\n\n[1] 5\n\n #alternatief printen van tibble naar de console: \n   ww\n\n# A tibble: 285 × 5\n   werkwoord frequentie regelmatigheid lengte ety_leeftijd\n   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;       \n 1 blijken         9.88 irregular           5 Germanic    \n 2 gloeien         6.91 regular             5 Germanic    \n 3 glimmen         7.03 irregular           4 Germanic    \n 4 rijzen          7.37 irregular           4 Germanic    \n 5 werpen          8.49 irregular           4 Germanic    \n 6 delven          6.17 irregular           4 WestGermanic\n 7 snikken         6.72 regular             4 Germanic    \n 8 laten          11.1  irregular           4 Germanic    \n 9 snijden         7.89 irregular           5 Germanic    \n10 schrikken       8.20 irregular           6 DutchGerman \n# ℹ 275 more rows\n\n   print(ww)\n\n# A tibble: 285 × 5\n   werkwoord frequentie regelmatigheid lengte ety_leeftijd\n   &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;           &lt;dbl&gt; &lt;chr&gt;       \n 1 blijken         9.88 irregular           5 Germanic    \n 2 gloeien         6.91 regular             5 Germanic    \n 3 glimmen         7.03 irregular           4 Germanic    \n 4 rijzen          7.37 irregular           4 Germanic    \n 5 werpen          8.49 irregular           4 Germanic    \n 6 delven          6.17 irregular           4 WestGermanic\n 7 snikken         6.72 regular             4 Germanic    \n 8 laten          11.1  irregular           4 Germanic    \n 9 snijden         7.89 irregular           5 Germanic    \n10 schrikken       8.20 irregular           6 DutchGerman \n# ℹ 275 more rows"
  },
  {
    "objectID": "_practica/practicum2.html#sec-meet",
    "href": "_practica/practicum2.html#sec-meet",
    "title": "Practicum 2",
    "section": "Meetniveaus van de variabelen",
    "text": "Meetniveaus van de variabelen\n\nOpdracht\n\n\nBeschrijf de meetniveaus van alle variabelen in het databestand en geef kort aan waarom je voor de betreffende meetniveaus gekozen hebt."
  },
  {
    "objectID": "_practica/practicum2.html#details-van-variabelen-opvragen",
    "href": "_practica/practicum2.html#details-van-variabelen-opvragen",
    "title": "Practicum 2",
    "section": "Details van variabelen opvragen",
    "text": "Details van variabelen opvragen\n\nOpdrachtHintCode\n\n\nVan welk type zijn de variabelen in de tibble volgens R? Kloppen deze door R toegekende typen met de meetniveaus uit de vorige vraag?\n\n\nOm dit te achterhalen kun je bij tibbles de functies glimpse() of str() gebruiken. Zie sectie 3.2.2.\n\n\n\n# Details variabelen opvragen. N.B. resultaten kunnen afhangen van je computerinstellingen\n glimpse(ww)\n\nRows: 285\nColumns: 5\n$ werkwoord      &lt;chr&gt; \"blijken\", \"gloeien\", \"glimmen\", \"rijzen\", \"werpen\", \"d…\n$ frequentie     &lt;dbl&gt; 9.883183, 6.908755, 7.025538, 7.373374, 8.493515, 6.173…\n$ regelmatigheid &lt;chr&gt; \"irregular\", \"regular\", \"irregular\", \"irregular\", \"irre…\n$ lengte         &lt;dbl&gt; 5, 5, 4, 4, 4, 4, 4, 4, 5, 6, 3, 5, 5, 6, 4, 4, 4, 4, 6…\n$ ety_leeftijd   &lt;chr&gt; \"Germanic\", \"Germanic\", \"Germanic\", \"Germanic\", \"German…\n\n  #alternatief:\n  str(ww)\n\nspc_tbl_ [285 × 5] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ werkwoord     : chr [1:285] \"blijken\" \"gloeien\" \"glimmen\" \"rijzen\" ...\n $ frequentie    : num [1:285] 9.88 6.91 7.03 7.37 8.49 ...\n $ regelmatigheid: chr [1:285] \"irregular\" \"regular\" \"irregular\" \"irregular\" ...\n $ lengte        : num [1:285] 5 5 4 4 4 4 4 4 5 6 ...\n $ ety_leeftijd  : chr [1:285] \"Germanic\" \"Germanic\" \"Germanic\" \"Germanic\" ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   Werkwoord = col_character(),\n  ..   Frequentie = col_double(),\n  ..   Regelmatigheid = col_character(),\n  ..   Lengte = col_double(),\n  ..   EtyLeeftijd = col_character()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt;"
  },
  {
    "objectID": "_practica/practicum2.html#aanpassen-van-het-type-van-een-variabele",
    "href": "_practica/practicum2.html#aanpassen-van-het-type-van-een-variabele",
    "title": "Practicum 2",
    "section": "Aanpassen van het type van een variabele",
    "text": "Aanpassen van het type van een variabele\n\nOpdrachtHintCode\n\n\nPas de variabelen in het ingelezen databestand, indien nodig, zodanig aan dat ze overeenkomen met de meetniveaus zoals je die zelf eerder beschreven hebt. Let op: zorg ervoor dat de levels van etymologische leeftijd chronologisch geordend is (van oud naar jong): IndoEuropean, Germanic, WestGermanic DutchGerman, Dutch. Maak hier voor de veiligheid een nieuwe variabele van in je dataframe met de naam ety_age.\n\n\nOm een nieuwe variabele te maken gebruik je de functie mutate(). Zie Hoofdstuk 3. Zie ook practicum 1 voor het omzetten van een variabele naar een factor. Het herordenen van de levels van een factor kan met de functie fct_relevel(). Deze neemt als eerste argument de naam van de variabele waarvan je de levels wilt aanpassen en als tweede argument een vector met de namen van de levels in de juiste volgorde.\n\n\n\n# Eventueel aanpassen van variabelen, bijvoorbeeld in geval werkwoord niet herkend is als factor, maar als chr (karakters) (wederom afhankelijk van resultaat in de vorige stap):\n      ww &lt;- mutate(ww, \n                   werkwoord = as.factor(werkwoord),\n                   regelmatigheid = as.factor(regelmatigheid)\n                   )\n      \n# Omzetten ety_leeftijd naar chronologische volgorde in nieuwe variable EtyAge:\n       ww &lt;- mutate(ww, \n                    ety_age = as.factor(ety_leeftijd),\n                    ety_age = fct_relevel(ety_age, c(\"IndoEuropean\", \"Germanic\", \"WestGermanic\", \"DutchGerman\", \"Dutch\"))\n                    )\n\n# Controleren of het goed is gegaan\n str(ww)\n\ntibble [285 × 6] (S3: tbl_df/tbl/data.frame)\n $ werkwoord     : Factor w/ 285 levels \"barsten\",\"bellen\",..: 9 50 49 129 248 22 169 93 168 149 ...\n $ frequentie    : num [1:285] 9.88 6.91 7.03 7.37 8.49 ...\n $ regelmatigheid: Factor w/ 2 levels \"irregular\",\"regular\": 1 2 1 1 1 1 2 1 1 1 ...\n $ lengte        : num [1:285] 5 5 4 4 4 4 4 4 5 6 ...\n $ ety_leeftijd  : chr [1:285] \"Germanic\" \"Germanic\" \"Germanic\" \"Germanic\" ...\n $ ety_age       : Factor w/ 5 levels \"IndoEuropean\",..: 2 2 2 2 2 3 2 2 2 4 ..."
  },
  {
    "objectID": "_practica/practicum2.html#sec-filter",
    "href": "_practica/practicum2.html#sec-filter",
    "title": "Practicum 2",
    "section": "Observaties behouden op basis van waarden",
    "text": "Observaties behouden op basis van waarden\n\nOpdrachtHintCode\n\n\nBeperk de tibble ww achtereenvolgens tot:\n\neen tibble die alleen regelmatige werkwoorden bevat.\neen tibble die alleen onregelmatige werkwoorden bevat die als etymologische leeftijd Germanic hebben.\neen tibble die alleen werkwoorden bevat met een frequentie lager dan 5 of hoger dan 10.\neen tibble die alleen werkwoorden bevat met een lengte tussen de 4 en 6 letters (dus 4, 5 of 6).\n\n\n\nGebruik hiervoor de functie filter(). Zie sectie 4.2.\n\n\n\n#a.\nfilter(ww, regelmatigheid == \"regular\")\n\n# A tibble: 143 × 6\n   werkwoord frequentie regelmatigheid lengte ety_leeftijd ety_age     \n   &lt;fct&gt;          &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;       \n 1 gloeien         6.91 regular             5 Germanic     Germanic    \n 2 snikken         6.72 regular             4 Germanic     Germanic    \n 3 zetten          9.78 regular             3 WestGermanic WestGermanic\n 4 spelen          9.69 regular             5 WestGermanic WestGermanic\n 5 krabben         6.56 regular             4 Germanic     Germanic    \n 6 scheiden        7.62 regular             6 IndoEuropean IndoEuropean\n 7 voegen          8.26 regular             4 Germanic     Germanic    \n 8 doemen          6.57 regular             4 Germanic     Germanic    \n 9 snoeren         5.16 regular             5 Germanic     Germanic    \n10 schikken        7.61 regular             5 DutchGerman  DutchGerman \n# ℹ 133 more rows\n\n#b.\nfilter(ww, regelmatigheid == \"irregular\", ety_age == \"Germanic\")\n\n# A tibble: 92 × 6\n   werkwoord frequentie regelmatigheid lengte ety_leeftijd ety_age \n   &lt;fct&gt;          &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;   \n 1 blijken         9.88 irregular           5 Germanic     Germanic\n 2 glimmen         7.03 irregular           4 Germanic     Germanic\n 3 rijzen          7.37 irregular           4 Germanic     Germanic\n 4 werpen          8.49 irregular           4 Germanic     Germanic\n 5 laten          11.1  irregular           4 Germanic     Germanic\n 6 snijden         7.89 irregular           5 Germanic     Germanic\n 7 blazen          7.46 irregular           5 Germanic     Germanic\n 8 worden         12.7  irregular           4 Germanic     Germanic\n 9 smijten         6.85 irregular           5 Germanic     Germanic\n10 meten           7.37 irregular           4 Germanic     Germanic\n# ℹ 82 more rows\n\n#c.\nfilter(ww, frequentie &lt; 5 | frequentie &gt; 10)\n\n# A tibble: 45 × 6\n   werkwoord frequentie regelmatigheid lengte ety_leeftijd ety_age     \n   &lt;fct&gt;          &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;       \n 1 laten          11.1  irregular           4 Germanic     Germanic    \n 2 spreken        10.1  irregular           6 WestGermanic WestGermanic\n 3 rijgen          4.92 irregular           4 DutchGerman  DutchGerman \n 4 worden         12.7  irregular           4 Germanic     Germanic    \n 5 zien           11.5  irregular           3 Germanic     Germanic    \n 6 pluizen         4.03 irregular           5 DutchGerman  DutchGerman \n 7 hebben         13.1  irregular           3 IndoEuropean IndoEuropean\n 8 zeggen         11.8  irregular           3 Germanic     Germanic    \n 9 gaan           11.8  irregular           2 Germanic     Germanic    \n10 zwieren         4.86 regular             5 Dutch        Dutch       \n# ℹ 35 more rows\n\n  #alternatief:\n  filter(ww, xor(frequentie &lt; 5, frequentie &gt; 10))\n\n# A tibble: 45 × 6\n   werkwoord frequentie regelmatigheid lengte ety_leeftijd ety_age     \n   &lt;fct&gt;          &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;       \n 1 laten          11.1  irregular           4 Germanic     Germanic    \n 2 spreken        10.1  irregular           6 WestGermanic WestGermanic\n 3 rijgen          4.92 irregular           4 DutchGerman  DutchGerman \n 4 worden         12.7  irregular           4 Germanic     Germanic    \n 5 zien           11.5  irregular           3 Germanic     Germanic    \n 6 pluizen         4.03 irregular           5 DutchGerman  DutchGerman \n 7 hebben         13.1  irregular           3 IndoEuropean IndoEuropean\n 8 zeggen         11.8  irregular           3 Germanic     Germanic    \n 9 gaan           11.8  irregular           2 Germanic     Germanic    \n10 zwieren         4.86 regular             5 Dutch        Dutch       \n# ℹ 35 more rows\n\n#d.\nfilter(ww, lengte &gt; 3 & lengte &lt; 7)\n\n# A tibble: 239 × 6\n   werkwoord frequentie regelmatigheid lengte ety_leeftijd ety_age     \n   &lt;fct&gt;          &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;       \n 1 blijken         9.88 irregular           5 Germanic     Germanic    \n 2 gloeien         6.91 regular             5 Germanic     Germanic    \n 3 glimmen         7.03 irregular           4 Germanic     Germanic    \n 4 rijzen          7.37 irregular           4 Germanic     Germanic    \n 5 werpen          8.49 irregular           4 Germanic     Germanic    \n 6 delven          6.17 irregular           4 WestGermanic WestGermanic\n 7 snikken         6.72 regular             4 Germanic     Germanic    \n 8 laten          11.1  irregular           4 Germanic     Germanic    \n 9 snijden         7.89 irregular           5 Germanic     Germanic    \n10 schrikken       8.20 irregular           6 DutchGerman  DutchGerman \n# ℹ 229 more rows\n\n  #alternatief:\n  filter(ww, between(lengte,4,6)) #zie cheat sheet\n\n# A tibble: 239 × 6\n   werkwoord frequentie regelmatigheid lengte ety_leeftijd ety_age     \n   &lt;fct&gt;          &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;       \n 1 blijken         9.88 irregular           5 Germanic     Germanic    \n 2 gloeien         6.91 regular             5 Germanic     Germanic    \n 3 glimmen         7.03 irregular           4 Germanic     Germanic    \n 4 rijzen          7.37 irregular           4 Germanic     Germanic    \n 5 werpen          8.49 irregular           4 Germanic     Germanic    \n 6 delven          6.17 irregular           4 WestGermanic WestGermanic\n 7 snikken         6.72 regular             4 Germanic     Germanic    \n 8 laten          11.1  irregular           4 Germanic     Germanic    \n 9 snijden         7.89 irregular           5 Germanic     Germanic    \n10 schrikken       8.20 irregular           6 DutchGerman  DutchGerman \n# ℹ 229 more rows"
  },
  {
    "objectID": "_practica/practicum2.html#sec-select",
    "href": "_practica/practicum2.html#sec-select",
    "title": "Practicum 2",
    "section": "Selecteren van variabelen",
    "text": "Selecteren van variabelen\n\nOpdrachtHintCode\n\n\nBeperk de tibble ww achtereenvolgens tot:\n\neen tibble met alleen de variabelen werkwoord, regelmatigheid en ety_age.\neen tibble met alle variabelen behalve lengte.\n\n\n\nGebruik hiervoor de functie select(). Zie sectie 4.3\n\n\n\n#a.\nselect(ww, werkwoord, ety_age, regelmatigheid)\n\n# A tibble: 285 × 3\n   werkwoord ety_age      regelmatigheid\n   &lt;fct&gt;     &lt;fct&gt;        &lt;fct&gt;         \n 1 blijken   Germanic     irregular     \n 2 gloeien   Germanic     regular       \n 3 glimmen   Germanic     irregular     \n 4 rijzen    Germanic     irregular     \n 5 werpen    Germanic     irregular     \n 6 delven    WestGermanic irregular     \n 7 snikken   Germanic     regular       \n 8 laten     Germanic     irregular     \n 9 snijden   Germanic     irregular     \n10 schrikken DutchGerman  irregular     \n# ℹ 275 more rows\n\n#b.\nselect(ww, -lengte)\n\n# A tibble: 285 × 5\n   werkwoord frequentie regelmatigheid ety_leeftijd ety_age     \n   &lt;fct&gt;          &lt;dbl&gt; &lt;fct&gt;          &lt;chr&gt;        &lt;fct&gt;       \n 1 blijken         9.88 irregular      Germanic     Germanic    \n 2 gloeien         6.91 regular        Germanic     Germanic    \n 3 glimmen         7.03 irregular      Germanic     Germanic    \n 4 rijzen          7.37 irregular      Germanic     Germanic    \n 5 werpen          8.49 irregular      Germanic     Germanic    \n 6 delven          6.17 irregular      WestGermanic WestGermanic\n 7 snikken         6.72 regular        Germanic     Germanic    \n 8 laten          11.1  irregular      Germanic     Germanic    \n 9 snijden         7.89 irregular      Germanic     Germanic    \n10 schrikken       8.20 irregular      DutchGerman  DutchGerman \n# ℹ 275 more rows"
  },
  {
    "objectID": "_practica/practicum2.html#toevoegen-van-een-nieuwe-variabele",
    "href": "_practica/practicum2.html#toevoegen-van-een-nieuwe-variabele",
    "title": "Practicum 2",
    "section": "Toevoegen van een nieuwe variabele",
    "text": "Toevoegen van een nieuwe variabele\n\nOpdrachtHintCode\n\n\nVoeg een nieuwe variabele freq_int toe aan de tibble ww met daarin de frequentie van de werkwoorden afgerond op gehele getallen. Gebruik hierbij de functie round(). Zorg dat de nieuwe variabele direct volgt op de variabele frequentie.\n\n\nOm variabelen op een specifieke plek in de tibble in te voegen kun je het argument .before of .after gebruiken bij de functie mutate(). Zie sectie 3.2.2.\n\n\n\n# Toevoegen van nieuwe variabele met mutate()\n ww &lt;- mutate(ww, \n              freq_int = round(frequentie),\n              .after = frequentie)\n\n# Controleren of het goed is gegaan\n glimpse(ww)\n\nRows: 285\nColumns: 7\n$ werkwoord      &lt;fct&gt; blijken, gloeien, glimmen, rijzen, werpen, delven, snik…\n$ frequentie     &lt;dbl&gt; 9.883183, 6.908755, 7.025538, 7.373374, 8.493515, 6.173…\n$ freq_int       &lt;dbl&gt; 10, 7, 7, 7, 8, 6, 7, 11, 8, 8, 10, 7, 10, 10, 5, 7, 8,…\n$ regelmatigheid &lt;fct&gt; irregular, regular, irregular, irregular, irregular, ir…\n$ lengte         &lt;dbl&gt; 5, 5, 4, 4, 4, 4, 4, 4, 5, 6, 3, 5, 5, 6, 4, 4, 4, 4, 6…\n$ ety_leeftijd   &lt;chr&gt; \"Germanic\", \"Germanic\", \"Germanic\", \"Germanic\", \"German…\n$ ety_age        &lt;fct&gt; Germanic, Germanic, Germanic, Germanic, Germanic, WestG…"
  },
  {
    "objectID": "_practica/practicum2.html#variabelen-van-plaats-verwisselen",
    "href": "_practica/practicum2.html#variabelen-van-plaats-verwisselen",
    "title": "Practicum 2",
    "section": "Variabelen van plaats verwisselen",
    "text": "Variabelen van plaats verwisselen\n\nOpdrachtHintCode\n\n\nVerwissel de positie van de variabelen frequentie en regelmatigheid\n\n\nGebruik hiervoor de functie relocate(). Zie sectie 3.2.2.\n\n\n\n# Verwisselen van positie\nrelocate(ww, \n         frequentie, \n         .after = regelmatigheid)\n\n# A tibble: 285 × 7\n   werkwoord freq_int regelmatigheid frequentie lengte ety_leeftijd ety_age     \n   &lt;fct&gt;        &lt;dbl&gt; &lt;fct&gt;               &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;       \n 1 blijken         10 irregular            9.88      5 Germanic     Germanic    \n 2 gloeien          7 regular              6.91      5 Germanic     Germanic    \n 3 glimmen          7 irregular            7.03      4 Germanic     Germanic    \n 4 rijzen           7 irregular            7.37      4 Germanic     Germanic    \n 5 werpen           8 irregular            8.49      4 Germanic     Germanic    \n 6 delven           6 irregular            6.17      4 WestGermanic WestGermanic\n 7 snikken          7 regular              6.72      4 Germanic     Germanic    \n 8 laten           11 irregular           11.1       4 Germanic     Germanic    \n 9 snijden          8 irregular            7.89      5 Germanic     Germanic    \n10 schrikken        8 irregular            8.20      6 DutchGerman  DutchGerman \n# ℹ 275 more rows\n\n\n\n# alternatief\nrelocate(ww, \n         regelmatigheid, \n         .before = frequentie)"
  },
  {
    "objectID": "_practica/practicum2.html#de-pipe",
    "href": "_practica/practicum2.html#de-pipe",
    "title": "Practicum 2",
    "section": "De pipe",
    "text": "De pipe\n\nOpdrachtHintCode\n\n\nMaak een nieuwe tibble dutch_verbs met daarin alleen de werkwoorden die Dutch als etymologische leeftijd hebben, maar met behoud van alle andere variabelen behalve ety_leeftijd. Maak hierbij gebruik van de pipe operator %&gt;%. Hoeveel werkwoorden met deze etymologische leeftijd zijn onregelmatig?\n\n\nDit is een combinatie van twee eerdere opgaven.\n\n\n\n# Maken van tibble op basis van ww\ndutch_verbs &lt;- ww %&gt;% \n  filter(ety_leeftijd == \"Dutch\") %&gt;% \n  select(-ety_leeftijd)\n\n#zichtbaar maken van tibble\n print(dutch_verbs)\n\n# A tibble: 8 × 6\n  werkwoord frequentie freq_int regelmatigheid lengte ety_age\n  &lt;fct&gt;          &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;fct&gt;  \n1 zeuren          6.38        6 regular             4 Dutch  \n2 zwieren         4.86        5 regular             5 Dutch  \n3 zwaaien         7.76        8 regular             5 Dutch  \n4 spugen          6.08        6 irregular           5 Dutch  \n5 dreigen         7.97        8 regular             5 Dutch  \n6 hollen          6.95        7 regular             3 Dutch  \n7 duwen           8.10        8 regular             3 Dutch  \n8 splitsen        6.06        6 regular             6 Dutch"
  },
  {
    "objectID": "_practica/practicum2.html#ordenen-van-een-dataset",
    "href": "_practica/practicum2.html#ordenen-van-een-dataset",
    "title": "Practicum 2",
    "section": "Ordenen van een dataset",
    "text": "Ordenen van een dataset\n\nOpdrachtHintCode\n\n\nOrden je nieuwe tibble dutch_verbs uit de vorige vraag op basis van de frequentie van de werkwoorden, een keer met oplopende en een keer met aflopende frequentie. Wat is de hoogste frequentie bij deze groep werkwoorden?\n\n\nGebruik de functie arrange() eventueel in combinatie met desc(). Zie sectie 4.5.\n\n\n\n# Ordenen van data frame oplopend\ndutch_verbs %&gt;% arrange(frequentie)\n\n# A tibble: 8 × 6\n  werkwoord frequentie freq_int regelmatigheid lengte ety_age\n  &lt;fct&gt;          &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;fct&gt;  \n1 zwieren         4.86        5 regular             5 Dutch  \n2 splitsen        6.06        6 regular             6 Dutch  \n3 spugen          6.08        6 irregular           5 Dutch  \n4 zeuren          6.38        6 regular             4 Dutch  \n5 hollen          6.95        7 regular             3 Dutch  \n6 zwaaien         7.76        8 regular             5 Dutch  \n7 dreigen         7.97        8 regular             5 Dutch  \n8 duwen           8.10        8 regular             3 Dutch  \n\n# Ordenen van data frame aflopend\ndutch_verbs %&gt;% arrange(desc(frequentie))\n\n# A tibble: 8 × 6\n  werkwoord frequentie freq_int regelmatigheid lengte ety_age\n  &lt;fct&gt;          &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;fct&gt;  \n1 duwen           8.10        8 regular             3 Dutch  \n2 dreigen         7.97        8 regular             5 Dutch  \n3 zwaaien         7.76        8 regular             5 Dutch  \n4 hollen          6.95        7 regular             3 Dutch  \n5 zeuren          6.38        6 regular             4 Dutch  \n6 spugen          6.08        6 irregular           5 Dutch  \n7 splitsen        6.06        6 regular             6 Dutch  \n8 zwieren         4.86        5 regular             5 Dutch"
  },
  {
    "objectID": "_practica/practicum2.html#inlezen-van-databestand-hulpwerkwoorden.txt",
    "href": "_practica/practicum2.html#inlezen-van-databestand-hulpwerkwoorden.txt",
    "title": "Practicum 2",
    "section": "Inlezen van databestand hulpwerkwoorden.txt",
    "text": "Inlezen van databestand hulpwerkwoorden.txt\n\nOpdrachtHintCode\n\n\nLees het databestand hulpwerkwoorden.txt met de juiste read_-functie en geef de tibble de naam hww. Controleer of alle variabelen goed gecodeerd zijn en pas aan indien nodig.\n\n\nOpen het databestand hulpwerkwoorden.txt om te zien hoe de data zijn opgeslagen (in dit geval gescheiden door een spatie). Bedenk welke functie daarbij hoort.\n\n\n\n#inlezen hulpwerkwoorden.txt, delimiter spatie\nhww &lt;- read_delim(\"datasets/hulpwerkwoorden.txt\", delim=\" \")\n\nRows: 285 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \" \"\nchr (2): Werkwoord, Hulpwerkwoord\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n#Controleren of inlezen goed is gegaan\nhead(hww)\n\n# A tibble: 6 × 2\n  Werkwoord Hulpwerkwoord\n  &lt;chr&gt;     &lt;chr&gt;        \n1 blijken   zijn         \n2 gloeien   hebben       \n3 glimmen   zijnheb      \n4 rijzen    zijn         \n5 werpen    hebben       \n6 delven    hebben       \n\nglimpse(hww)\n\nRows: 285\nColumns: 2\n$ Werkwoord     &lt;chr&gt; \"blijken\", \"gloeien\", \"glimmen\", \"rijzen\", \"werpen\", \"de…\n$ Hulpwerkwoord &lt;chr&gt; \"zijn\", \"hebben\", \"zijnheb\", \"zijn\", \"hebben\", \"hebben\",…\n\n# Aanpassen namen\nhww &lt;- janitor::clean_names(hww)\n\n# Beide variabelen omzetten naar factor\nhww &lt;- hww %&gt;% \n  mutate(werkwoord = as.factor(werkwoord),\n         hulpwerkwoord = as.factor(hulpwerkwoord)\n         )\n\n#Controleren of het goed is gegaan\nglimpse(hww)\n\nRows: 285\nColumns: 2\n$ werkwoord     &lt;fct&gt; blijken, gloeien, glimmen, rijzen, werpen, delven, snikk…\n$ hulpwerkwoord &lt;fct&gt; zijn, hebben, zijnheb, zijn, hebben, hebben, hebben, heb…"
  },
  {
    "objectID": "_practica/practicum2.html#samenvoegen-van-de-datasets",
    "href": "_practica/practicum2.html#samenvoegen-van-de-datasets",
    "title": "Practicum 2",
    "section": "Samenvoegen van de datasets",
    "text": "Samenvoegen van de datasets\n\nOpdrachtHintCode\n\n\nWe gaan de informatie uit hww toevoegen aan ww met behulp van de functie left_join(). Deze functie wordt in SfL (Winter, 2019) beschreven onderaan p. 41. Meer achtergrondinformatie over ‘joins’ vind je in hoofdstuk 19 van R4DS of het dplyr cheatsheet. Geef dit nieuwe databestand de naam ww_compleet.\n\nWinter, B. (2019). Statistics for Linguists: An Introduction Using R. Routledge. https://doi.org/10.4324/9781315165547\n\n\nHet basisbestand waar je informatie aan gaat toevoegen komt eerst bij het aanroepen van left_join(). Om te controleren of alle informatie aanwezig is, kun je de eerste 6 rijen bekijken en kijken of het totaal aantal rijen gelijk is gebleven in verlijking met de oorspronkelijke dataset ww.\n\n\n\n# Samenvoegen ww met hww en controleren of alle informatie er is\nww_compleet &lt;- left_join(ww, hww)\n\nJoining with `by = join_by(werkwoord)`\n\nhead(ww_compleet)     \n\n# A tibble: 6 × 8\n  werkwoord frequentie freq_int regelmatigheid lengte ety_leeftijd ety_age     \n  &lt;fct&gt;          &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;       \n1 blijken         9.88       10 irregular           5 Germanic     Germanic    \n2 gloeien         6.91        7 regular             5 Germanic     Germanic    \n3 glimmen         7.03        7 irregular           4 Germanic     Germanic    \n4 rijzen          7.37        7 irregular           4 Germanic     Germanic    \n5 werpen          8.49        8 irregular           4 Germanic     Germanic    \n6 delven          6.17        6 irregular           4 WestGermanic WestGermanic\n# ℹ 1 more variable: hulpwerkwoord &lt;fct&gt;\n\nnrow(ww_compleet)\n\n[1] 285"
  },
  {
    "objectID": "_practica/practicum2.html#opslaan-van-de-nieuwe-dataset",
    "href": "_practica/practicum2.html#opslaan-van-de-nieuwe-dataset",
    "title": "Practicum 2",
    "section": "Opslaan van de nieuwe dataset",
    "text": "Opslaan van de nieuwe dataset\n\nOpdrachtHintCode\n\n\nSla de data in ww_compleet op in een csv-bestand met de naam werkwoorden_compleet.csv waarbij de waardes worden gescheiden door een puntkomma.\n\n\nZie sectie 3.2 voor informatie over het wegschrijven van data naar een bestand. Net zoals er voor het inlezen van csv-bestanden twee read_-functies bestaan, zijn er ook twee functies voor het wegschrijven naar een csv-bestand.\n\n\n\n# Wegschrijven data in ww_compleet naar werkwoorden_compleet.csv\nwrite_csv2(ww_compleet, \"datasets/werkwoorden_compleet.csv\")"
  },
  {
    "objectID": "_practica/practicum2.html#tellen-van-voorkomens",
    "href": "_practica/practicum2.html#tellen-van-voorkomens",
    "title": "Practicum 2",
    "section": "Tellen van voorkomens",
    "text": "Tellen van voorkomens\n\nOpdrachtHintCode\n\n\nLaten we eerst eens wat beter kijken naar de etymologische leeftijd van de werkwoorden. Maak een telling van de categorieën van deze variabele. Hoe vaak komt de categorie WestGermanic voor in de dataset?\n\n\nGebruik hiervoor de functie count(). Zie sectie 4.5.\n\n\n\n# Telling van etymologische leeftijd\n ww_compleet %&gt;% count(ety_leeftijd) \n\n# A tibble: 5 × 2\n  ety_leeftijd     n\n  &lt;chr&gt;        &lt;int&gt;\n1 Dutch            8\n2 DutchGerman     28\n3 Germanic       173\n4 IndoEuropean    33\n5 WestGermanic    43"
  },
  {
    "objectID": "_practica/practicum2.html#een-telling-per-groep",
    "href": "_practica/practicum2.html#een-telling-per-groep",
    "title": "Practicum 2",
    "section": "Een telling per groep",
    "text": "Een telling per groep\n\nOpdrachtHintCode\n\n\nMaak nu een telling van de etymologische leeftijd maar weergegeven per level van de factor regelmatigheid. Hoe vaak komt elke categorie van regelmatigheid voor in de tijdscategorie DutchGerman? Komt het vermoeden van de onderzoeker uit dat onregelmatige werkwoorden eerder terug te voeren zijn op oudere taalstadia dan regelmatige werkwoorden?\n\n\nCombineer de functies group_by(), summarise() en n(). Zie sectie 4.5.\n\n\n\n# Aantal voorkomens per leeftijdscategorie per regelmatigheidstype\n ww_compleet %&gt;% \n  group_by(regelmatigheid, ety_age) %&gt;%\n  summarise(\n    aantal = n()\n    )\n\n`summarise()` has grouped output by 'regelmatigheid'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 10 × 3\n# Groups:   regelmatigheid [2]\n   regelmatigheid ety_age      aantal\n   &lt;fct&gt;          &lt;fct&gt;         &lt;int&gt;\n 1 irregular      IndoEuropean     21\n 2 irregular      Germanic         92\n 3 irregular      WestGermanic     17\n 4 irregular      DutchGerman      11\n 5 irregular      Dutch             1\n 6 regular        IndoEuropean     12\n 7 regular        Germanic         81\n 8 regular        WestGermanic     26\n 9 regular        DutchGerman      17\n10 regular        Dutch             7\n\n#Alternatief met count()\n ww_compleet %&gt;% count(regelmatigheid, ety_age)\n\n# A tibble: 10 × 3\n   regelmatigheid ety_age          n\n   &lt;fct&gt;          &lt;fct&gt;        &lt;int&gt;\n 1 irregular      IndoEuropean    21\n 2 irregular      Germanic        92\n 3 irregular      WestGermanic    17\n 4 irregular      DutchGerman     11\n 5 irregular      Dutch            1\n 6 regular        IndoEuropean    12\n 7 regular        Germanic        81\n 8 regular        WestGermanic    26\n 9 regular        DutchGerman     17\n10 regular        Dutch            7"
  },
  {
    "objectID": "_practica/practicum2.html#sec-gem-groep",
    "href": "_practica/practicum2.html#sec-gem-groep",
    "title": "Practicum 2",
    "section": "Gemiddelde waarde per groep berekenen",
    "text": "Gemiddelde waarde per groep berekenen\n\nOpdrachtHintCode\n\n\nHoe zit het met het vermoeden van de onderzoeker over de frequentie van de regelmatige werkwoorden t.o.v. onregelmatige werkwoorden? Bereken hiervoor de gemiddelde frequentie voor iedere groep.\n\n\nMet de functie mean() kun je het gemiddelde van een variabele berekenen.\n\n\n\n# Gemiddelde frequentie per regelmatigheidstype       \n ww_compleet %&gt;%\n  group_by(regelmatigheid) %&gt;%\n  summarise(\n    aantal = n(),\n    mean_freq = mean(frequentie)\n    )\n\n# A tibble: 2 × 3\n  regelmatigheid aantal mean_freq\n  &lt;fct&gt;           &lt;int&gt;     &lt;dbl&gt;\n1 irregular         142      8.19\n2 regular           143      7.79\n\n\n\n\n\n\nOpdrachtHintCode\n\n\nVerandert het antwoord op de vorige vraag als je alleen kijkt naar werkwoorden die uit meer dan 5 letters bestaan?\n\n\nPerk je de dataset eerst in tot alle werkwoorden die uit meer dan 5 letters bestaan voor je gaat groeperen.\n\n\n\n#Gemiddelde frequentie per regelmatigheidstype voor werkwoorden langer dan 5 letters    \n ww_compleet %&gt;%\n  filter(lengte &gt; 5) %&gt;% \n  group_by(regelmatigheid) %&gt;%\n  summarise(\n    aantal = n(),\n    mean_freq = mean(frequentie)\n    )\n\n# A tibble: 2 × 3\n  regelmatigheid aantal mean_freq\n  &lt;fct&gt;           &lt;int&gt;     &lt;dbl&gt;\n1 irregular          18      7.29\n2 regular            17      6.84"
  },
  {
    "objectID": "_practica/practicum2.html#tellingen-en-proporties",
    "href": "_practica/practicum2.html#tellingen-en-proporties",
    "title": "Practicum 2",
    "section": "Tellingen en proporties",
    "text": "Tellingen en proporties\n\nOpdrachtHintCode\n\n\nNu we toch ook informatie over de hulpwerkwoorden beschikbaar hebben: is er eigenlijk een verschil tussen regelmatige en onregelmatige werkwoorden in hun keuze voor hulpwerkwoord? Maak hiervoor een telling per categorie regelmatigheid. Voor de uitdaging: probeer eens of je aan die telling ook een proportie per categorie regelmatigheid, afgerond op twee decimalen kunt toevoegen. Je output zou er dan bijvoorbeeld zo uitzien:\n\n\n\n\n\nregelmatigheid\nhulpwerkwoord\nn\nprop\n\n\n\n\nirregular\nhebben\n94\n0.66\n\n\nirregular\nzijn\n12\n0.08\n\n\nirregular\nzijnheb\n36\n0.25\n\n\nregular\nhebben\n118\n0.83\n\n\nregular\nzijn\n3\n0.02\n\n\nregular\nzijnheb\n22\n0.15\n\n\n\n\n\nDe kolom prop drukt hier uit hoe vaak er gekozen wordt voor een type hulpwerkwoord binnen een level van de factor regelmatigheid. Binnen een categorie tellen de proporties (door afronding) op tot (ongeveer) 1.\n\n\nBereken eerst hoe vaak elk type hulpwerkwoord voorkomt per categorie van regelmatigheid. Dit kan met count() of een combinatie van group_by en summarise(), zoals je hierboven al hebt gedaan. Voor proporties moet je die uitkomsten groeperen per level van regelmatigheid om de proporties te kunnen berekenen.\n\n\n\n#Gemiddelde frequentie per regelmatigheidstype  met count()     \n ww_tabel &lt;- ww_compleet %&gt;%\n  count(regelmatigheid, hulpwerkwoord) %&gt;%\n  group_by(regelmatigheid) %&gt;% \n  mutate(prop = round(n/sum(n), 2)\n         )\n ww_tabel\n\n# A tibble: 6 × 4\n# Groups:   regelmatigheid [2]\n  regelmatigheid hulpwerkwoord     n  prop\n  &lt;fct&gt;          &lt;fct&gt;         &lt;int&gt; &lt;dbl&gt;\n1 irregular      hebben           94  0.66\n2 irregular      zijn             12  0.08\n3 irregular      zijnheb          36  0.25\n4 regular        hebben          118  0.83\n5 regular        zijn              3  0.02\n6 regular        zijnheb          22  0.15\n\n#Alternatief: gemiddelde frequentie per regelmatigheidstype met dubbel gebruik van group_by()\nww_compleet %&gt;% group_by(regelmatigheid, hulpwerkwoord) %&gt;%\n  summarise(\n    aantal = n()\n    ) %&gt;%\n  group_by(regelmatigheid) %&gt;% \n  mutate(prop = round(aantal/sum(aantal), 2)\n         )\n\n`summarise()` has grouped output by 'regelmatigheid'. You can override using\nthe `.groups` argument.\n\n\n# A tibble: 6 × 4\n# Groups:   regelmatigheid [2]\n  regelmatigheid hulpwerkwoord aantal  prop\n  &lt;fct&gt;          &lt;fct&gt;          &lt;int&gt; &lt;dbl&gt;\n1 irregular      hebben            94  0.66\n2 irregular      zijn              12  0.08\n3 irregular      zijnheb           36  0.25\n4 regular        hebben           118  0.83\n5 regular        zijn               3  0.02\n6 regular        zijnheb           22  0.15"
  },
  {
    "objectID": "_practica/practicum2.html#data-zichtbaar-maken",
    "href": "_practica/practicum2.html#data-zichtbaar-maken",
    "title": "Practicum 2",
    "section": "Data zichtbaar maken",
    "text": "Data zichtbaar maken\n\nOpdrachtHintCode\n\n\nMaak rij 16 t/m 27 van de tibble ww_compleet zichtbaar in de console met behulp van de functie slice().\n\n\nDe functie slice(x, n) neemt naast het databestand x ook een waarde of range van waarden n als argument. Een range geef je aan met :.\n\n\n\n# Zichtbaar maken van rij 16 t/m 27 uit ww_compleet\n ww_compleet %&gt;% slice(16:27)\n\n# A tibble: 12 × 8\n   werkwoord frequentie freq_int regelmatigheid lengte ety_leeftijd ety_age     \n   &lt;fct&gt;          &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;       \n 1 krabben         6.56        7 regular             4 Germanic     Germanic    \n 2 binden          7.59        8 irregular           4 IndoEuropean IndoEuropean\n 3 worden         12.7        13 irregular           4 Germanic     Germanic    \n 4 scheiden        7.62        8 regular             6 IndoEuropean IndoEuropean\n 5 smijten         6.85        7 irregular           5 Germanic     Germanic    \n 6 voegen          8.26        8 regular             4 Germanic     Germanic    \n 7 doemen          6.57        7 regular             4 Germanic     Germanic    \n 8 meten           7.37        7 irregular           4 Germanic     Germanic    \n 9 snoeren         5.16        5 regular             5 Germanic     Germanic    \n10 schikken        7.61        8 regular             5 DutchGerman  DutchGerman \n11 stinken         6.97        7 irregular           5 Germanic     Germanic    \n12 snappen         7.03        7 regular             4 DutchGerman  DutchGerman \n# ℹ 1 more variable: hulpwerkwoord &lt;fct&gt;"
  },
  {
    "objectID": "_practica/practicum2.html#een-observatie-met-maximale-of-minimale-waarde-zichtbaar-maken",
    "href": "_practica/practicum2.html#een-observatie-met-maximale-of-minimale-waarde-zichtbaar-maken",
    "title": "Practicum 2",
    "section": "Een observatie met maximale of minimale waarde zichtbaar maken",
    "text": "Een observatie met maximale of minimale waarde zichtbaar maken\n\nOpdrachtHintCode\n\n\nWat zijn de drie werkwoorden met de hoogste frequentie in de dataset? En welke drie werkwoorden hebben de laagste frequentie?\n\n\nGebruik hiervoor de functie slice_max() (of slice_min()). Zie sectie 4.2.\n\n\n\n# Vinden van de drie werkwoorden met de hoogste frequentie\n ww_compleet %&gt;% slice_max(frequentie, n = 3)\n\n# A tibble: 3 × 8\n  werkwoord frequentie freq_int regelmatigheid lengte ety_leeftijd ety_age     \n  &lt;fct&gt;          &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;       \n1 hebben          13.1       13 irregular           3 IndoEuropean IndoEuropean\n2 worden          12.7       13 irregular           4 Germanic     Germanic    \n3 kunnen          12.3       12 irregular           3 Germanic     Germanic    \n# ℹ 1 more variable: hulpwerkwoord &lt;fct&gt;\n\n# Vinden van de drie werkwoorden met de laagste frequentie\n ww_compleet %&gt;% slice_min(frequentie, n = 3)\n\n# A tibble: 3 × 8\n  werkwoord frequentie freq_int regelmatigheid lengte ety_leeftijd ety_age     \n  &lt;fct&gt;          &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;       \n1 pluizen         4.03        4 irregular           5 DutchGerman  DutchGerman \n2 prijzen         4.16        4 regular             5 WestGermanic WestGermanic\n3 spruiten        4.42        4 irregular           6 WestGermanic WestGermanic\n# ℹ 1 more variable: hulpwerkwoord &lt;fct&gt;"
  },
  {
    "objectID": "_practica/practicum2.html#een-simple-random-sample-maken",
    "href": "_practica/practicum2.html#een-simple-random-sample-maken",
    "title": "Practicum 2",
    "section": "Een simple random sample maken",
    "text": "Een simple random sample maken\n\nOpdrachtHintCode\n\n\nMaak een simple random sample van tien werkwoorden uit de dataset ww_compleet en schrijf deze weg in een tibble met de naam ww_sample.\n\n\nGebruik hiervoor de functie slice_sample(). Zie sectie 4.2.\n\n\n\n# Een random sample van 10 werkwoorden uit ww_compleet\n ww_sample &lt;- ww_compleet %&gt;% slice_sample(n = 10)\n\n# N.B. deze functie zal iedere keer een ander resultaat geven. Als je steeds hetzelfde sample wilt dan moet je vooraf een random seed aanmaken met de functie `set.seed()`. Wanneer je in deze functie steeds hetzelfde getal kiest, zul je steeds dezelfde resultaten krijgen. Handig voor de reproduceerbaarheid.\n set.seed(329)\n ww_compleet %&gt;% slice_sample(n = 10)\n\n# A tibble: 10 × 8\n   werkwoord frequentie freq_int regelmatigheid lengte ety_leeftijd ety_age     \n   &lt;fct&gt;          &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;       \n 1 voelen         10.3        10 regular             4 WestGermanic WestGermanic\n 2 breien          6.56        7 regular             4 Germanic     Germanic    \n 3 gaan           11.8        12 irregular           2 Germanic     Germanic    \n 4 mijden          5.61        6 irregular           4 WestGermanic WestGermanic\n 5 krimpen         6.35        6 irregular           5 Germanic     Germanic    \n 6 leven          10.2        10 regular             4 Germanic     Germanic    \n 7 spruiten        4.42        4 irregular           6 WestGermanic WestGermanic\n 8 stelen          7.39        7 irregular           5 Germanic     Germanic    \n 9 gooien          8.43        8 regular             4 DutchGerman  DutchGerman \n10 zien           11.5        11 irregular           3 Germanic     Germanic    \n# ℹ 1 more variable: hulpwerkwoord &lt;fct&gt;"
  },
  {
    "objectID": "_practica/practicum2.html#een-stratified-sample-maken",
    "href": "_practica/practicum2.html#een-stratified-sample-maken",
    "title": "Practicum 2",
    "section": "Een stratified sample maken",
    "text": "Een stratified sample maken\n\nOpdracht AHintCode\n\n\nMaak een stratified sample waarbij je uit elke groep van de variabele regelmatigheid random tien werkwoorden trekt. Rangschik de samples op basis van de frequentie van de werkwoorden.\n\n\nJe kunt de strata maken met behulp van de functie group_by(). Zie sectie 4.5.\n\n\n\n# Een stratified sample maken met 10 werkwoorden per groep\n set.seed(18537) #N.B. om het reproduceerbaar te maken kun je beter weer eerst een random seed aanmaken.\n ww_compleet %&gt;% \n  group_by(regelmatigheid) %&gt;% \n  slice_sample(n = 10) %&gt;% \n  arrange(frequentie)\n\n# A tibble: 20 × 8\n# Groups:   regelmatigheid [2]\n   werkwoord frequentie freq_int regelmatigheid lengte ety_leeftijd ety_age     \n   &lt;fct&gt;          &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;           &lt;dbl&gt; &lt;chr&gt;        &lt;fct&gt;       \n 1 hikken          4.76        5 regular             3 Germanic     Germanic    \n 2 schaven         4.80        5 regular             6 Germanic     Germanic    \n 3 snuiten         5.16        5 irregular           5 Germanic     Germanic    \n 4 splijten        5.52        6 irregular           6 Germanic     Germanic    \n 5 slijten         5.74        6 irregular           5 Germanic     Germanic    \n 6 vreten          6.32        6 irregular           5 WestGermanic WestGermanic\n 7 schelden        6.49        6 irregular           6 Germanic     Germanic    \n 8 breien          6.56        7 regular             4 Germanic     Germanic    \n 9 zoenen          6.65        7 regular             4 DutchGerman  DutchGerman \n10 zenden          7.47        7 irregular           4 Germanic     Germanic    \n11 danken          7.71        8 regular             4 Germanic     Germanic    \n12 eisen           7.73        8 regular             3 IndoEuropean IndoEuropean\n13 varen           7.84        8 irregular           4 Germanic     Germanic    \n14 stoppen         8.45        8 regular             4 WestGermanic WestGermanic\n15 drukken         8.79        9 regular             4 Germanic     Germanic    \n16 hoeven          9.23        9 regular             4 Germanic     Germanic    \n17 willen         11.2        11 irregular           3 IndoEuropean IndoEuropean\n18 staan          11.3        11 irregular           3 Germanic     Germanic    \n19 maken          11.4        11 regular             4 WestGermanic WestGermanic\n20 kunnen         12.3        12 irregular           3 Germanic     Germanic    \n# ℹ 1 more variable: hulpwerkwoord &lt;fct&gt;\n\n\n\n\n\n\nOpdracht BHintCode\n\n\nBereken voor je sample uit de vorige opdracht de gemiddelde frequentie voor iedere groep. Hoe representatief is jouw sample voor de hele dataset?\n\n\nJe hebt eerder dezelfde berekening gemaakt voor de hele dataset. Vergelijk je resultaten met die gegevens.\n\n\n\n# Eerst sample maken, indien je dat nog niet had opgeslagen onder een andere naam\n set.seed(18537)\n ww_compleet %&gt;% \n  group_by(regelmatigheid) %&gt;% \n  slice_sample(n = 10) %&gt;% #en vervolgens de gemiddelden berekenen\n   summarise(\n     aantal = n(),\n     mean_freq = mean(frequentie)\n     )\n\n# A tibble: 2 × 3\n  regelmatigheid aantal mean_freq\n  &lt;fct&gt;           &lt;int&gt;     &lt;dbl&gt;\n1 irregular          10      7.93\n2 regular            10      7.60\n\n\n\n\n\n\nDat was het voor deze keer. De functies die je hebt geleerd zullen nog vaak van pas komen. Volgende week gaan we ons verdiepen in het maken van grafieken in R."
  },
  {
    "objectID": "_practica/practicum3.html",
    "href": "_practica/practicum3.html",
    "title": "Practicum 3",
    "section": "",
    "text": "Grafieken maken met ggplot2\nIn deze opdracht maken we de grafiek na uit opgave 11 in hoofdstuk 2 van IMS, zie Figuur 1.1. Hierin is voor een groot aantal landen de levensverwachting (life expectancy) uitgezet tegen het percentage internetgebruikers in het land (percent internet users). De data zijn afkomstig uit een databestand van de CIA en zijn in het R-project bijgeleverd als cia_factbook.csv.\nIn deze opdracht maken we de grafiek na uit opgave 15 in hoofdstuk 1 van IMS, zie Figuur 2.1. Hierin wordt het aantal meisjes getoond die de naam Fiona hebben gekregen. Het gaat om kinderen geboren in het Verenigd Koninkrijk sinds 2000. De data zijn afkomstig uit het package ukbabynames. Dit package moet je geïnstalleerd hebben en aanroepen voor je de opdrachten kunt maken.\nTot nu toe hebben we R-code steeds in een R-script gemaakt. De output werd steeds zichtbaar in R Console of het Plots-window in RStudio. Hoewel dit een handige manier is om analyses uit te werken, is het wat minder handig om analyses te delen met anderen (mede-onderzoekers of je docent). Als je bijvoorbeeld de plaatjes die je hebt gemaakt wilt delen met iemand dan zul je die apart moeten opslaan of naar een ander bestand (bijv. Word) moeten kopiëren. Dit werkt op zich prima, maar het kan wat onhandig zijn wanneer je bijvoorbeeld nog kleine dingetjes wilt veranderen (bijv. de naam van de x-as toch aanpassen). In dat geval moet je het plaatje weer opnieuw kopiëren naar het andere bestand. Er is gelukkig een handiger alternatief en dat is het werken met een Quarto (of R Markdown) document. In zo’n document komt je output (bijv. een grafiek) direct onder je code te staan en kun je daarnaast ook nog gewone tekst typen, wanneer je bijvoorbeeld antwoord op een vraag wilt geven of een toelichting wilt schrijven bij wat je ziet in de data. Het document kun je vervolgens omzetten naar bijvoorbeeld een html-bestand of een pdf-bestand. De practicumopdracht die je nu leest is bijvoorbeeld op deze manier gemaakt. In het tweede deel van dit practicum ga je zelf proberen om zo’n Quarto-document te maken. We gebruiken hiervoor je uitwerkingen van Opdracht 2 van dit practicum over de naam Fiona.\nOp Brightspace vind je een video met een korte inleiding over het werken met Quarto. Je werkt vervolgens je eigen Quarto-document uit. Download hiervoor het bestand Practicum3.qmd van Brightspace en zet het in de map van je R-project. Open het bestand en bewerk het. Doorloop hierbij de volgende stappen:\nGelukt? Mooi! Vanaf nu maken we uitwerkingen niet meer in een script maar in een Quarto-bestand.\nJe vindt een bestand Practicum3_uitwerking.qmd op Brightspace met een voorbeelduitwerking.\nDat was het voor deze keer. Volgende week gaan we ons nog verder verdiepen in het maken van grafieken in R."
  },
  {
    "objectID": "_practica/practicum3.html#leerdoelen",
    "href": "_practica/practicum3.html#leerdoelen",
    "title": "Practicum 3",
    "section": "Leerdoelen",
    "text": "Leerdoelen\n\nBegrijpen van de opbouw van grafieken gemaakt met ggplot2;\nAanpassen van bestaande grafieken met ggplot2;\nMaken van nieuwe grafieken met ggplot2;\nKennismaken met de mogelijkheden van Quarto."
  },
  {
    "objectID": "_practica/practicum3.html#voorbereiding",
    "href": "_practica/practicum3.html#voorbereiding",
    "title": "Practicum 3",
    "section": "Voorbereiding",
    "text": "Voorbereiding\nLees hoofdstuk 5 uit het dictaat. De benodigde R-functies zijn te vinden in het dictaat (zie ook eerdere hoofdstukken en practica). Functies die niet in het dictaat besproken worden, worden gegeven in de opdracht. Het ggplot2 cheatsheet geeft een overzicht van de mogelijkheden die ggplot2 biedt.\nDe werking van Quarto zullen we toelichten in een video op Brightspace. Zie hiervoor ook hoofdstuk 28 uit Wickham et al. (2023). Bekijk voor je begint ook nog een keer de algemene richtlijnen voor practica.\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2de dr.). O’Reilly. https://r4ds.hadley.nz/"
  },
  {
    "objectID": "_practica/practicum3.html#sec-intro",
    "href": "_practica/practicum3.html#sec-intro",
    "title": "Practicum 3",
    "section": "Introductie",
    "text": "Introductie\nIn de opdrachten van dit practicum ga je een aantal grafieken uit het boek IMS aanpassen of vanaf nul proberen na te maken. Hierdoor raak je bekend met de (on)mogelijkheden van ggplot2. Bij elke grafiek hoort een aparte dataset. Bij elke opdracht is aangegeven of de data bijgeleverd zijn in een databestand of dat je een package moet installeren en aanroepen. Probeer bij elke dataset/grafiek eerst goed voor jezelf helder te hebben met wat voor soort data je te maken hebt (wat is het onderwerp van de dataset, welke variabelen zijn er, wat zijn de meetniveaus).\n\n\n\n\n\n\nLet op\n\n\n\nSla je script regelmatig op, zodat je geen code kwijtraakt. Klik hiervoor op het floppy-disk-symbool of gebruik de sneltoetsen Ctrl + S/cmd + S.\n\n\n\n\n\n\n\n\nProbeer het eerst zelf!\n\n\n\nBij sommige opdrachten vind je naast een beschrijving van de vraag ook een Hint en de Code. Dit om je te helpen als je even niet verder komt. Hoe verleidelijk het ook is om meteen naar het antwoord te gaan, doe dit niet. Houd je aan de volgorde: probeer het eerst zelf, lukt dat niet gebruik de hint, mocht je dan nog vastzitten en er echt niet uitkomen ga dan pas naar het antwoord. Dit gaat je op de lange termijn ontzettend helpen."
  },
  {
    "objectID": "_practica/practicum3.html#het-inlezen-van-de-data",
    "href": "_practica/practicum3.html#het-inlezen-van-de-data",
    "title": "Practicum 3",
    "section": "Het inlezen van de data",
    "text": "Het inlezen van de data\n\n\n\n\n\n\nLet op\n\n\n\nBij dit practicum maken we gebruik van een aantal packages. Installeer de volgende packages (als je dat niet al eerder hebt gedaan) en roep ze aan: tidyverse, scales en ukbabynames.\n\n\n\n\n\n\nOpdrachtHintCode\n\n\nLees het databestand cia_factbook.csv in met de juiste tidyverse-functie en noem de tibble cia_factbook. Bekijk de variabelen en pas indien nodig hun meetniveau aan.\n\n\nDit heb je in het vorige practicum ook gedaan. Zie dus het practicum van vorige week.\n\n\n\n# inlezen data\ncia_factbook &lt;- read_csv(\"datasets/cia_factbook.csv\")\n\nRows: 234 Columns: 12\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (2): country, continent\ndbl (10): area, birth_rate, death_rate, infant_mortality_rate, internet_user...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n# omzetten relevante variabelen naar factor\ncia_factbook &lt;- cia_factbook %&gt;% \n  mutate(country = as.factor(country),\n         continent = as.factor(continent)\n         )"
  },
  {
    "objectID": "_practica/practicum3.html#ggplot2-code-beter-begrijpen",
    "href": "_practica/practicum3.html#ggplot2-code-beter-begrijpen",
    "title": "Practicum 3",
    "section": "ggplot2-code beter begrijpen",
    "text": "ggplot2-code beter begrijpen\n\nOpdrachtHintCode\n\n\nMet onderstaande code kun je Figuur 1.1 ruwweg namaken (de kleuren zullen anders zijn). Kopieer de code naar je script en voer de code vervolgens uit. Geef in het script in eigen woorden aan wat elke stap in de code doet. Dit kun je doen door aan het eind van elke regel een comment te plaatsen, voorafgegaan door #. Dit is hier al voorgedaan voor regel 10 in de code. Je kunt de hashtag # ook gebruiken om te achterhalen wat een deel van de code precies doet. Door # voor code te zetten wordt deze niet uitgevoerd. N.B. zorg dan wel dat je de code t/m de laatste bijbehorende + uitzet, anders zal R gaan klagen.\n\n#code om figuur bij opgave 11 van hoofdstuk 2 uit IMS te maken\ncia_factbook %&gt;% \n  ggplot(aes(y = life_exp_at_birth,\n             x = internet_users/population\n             )) +\n  geom_point() +\n  scale_x_continuous(\n    labels = label_percent(scale = 100),\n    limits = c(0, 1)) +\n  theme_bw() +  #past de achtergrond aan naar wit met zwart raster i.p.v. grijs met wit\n  labs(\n      x = \"Percent internet users\",\n      y = \"Life expectancy\",\n      title = \"Life expectancy vs. percent internet users\", \n      subtitle = \"Data from 2014 from the CIA Factbook\"\n      )\n\nWarning: Removed 27 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\nVoer eerst alle code uit en kijk naar grafiek. Schakel dan steeds een stukje code uit met # en kijk goed wat er verandert in hoe de grafiek eruit ziet. Zie verder Hoofdstuk 5.\n\n\n\n#code om figuur bij opgave 11 van hoofdstuk 2 uit IMS te maken\ncia_factbook %&gt;%                              #data naar ggplot sturen\n  ggplot(aes(y = life_exp_at_birth,           #mapt variabele naar y-as\n             x = internet_users/population    #mapt variabele naar x-as, N.B. op basis van twee variabelen uit de data\n         )) +\n  geom_point() +                              #voegt de punten in de grafiek toe\n  scale_x_continuous(                         #met deze code wordt de x-as aangepast naar een percentage met bijbehorend %\n      labels = label_percent(scale = 100),    #scale =100 zorgt dat de percentagens tot 100 lopen\n      limits = c(0, 1)) +                     #zorgt dat de x-as loopt van 0 t/m 100 (is 1 x 100 (scale))\n  theme_bw() +                              #past de achtergrond aan naar wit met zwart raster i.p.v. grijs met wit\n  labs(                                     #hier worden namen voor assen gegeven en (onder)titel van de grafiek\n      x = \"Percent internet users\",\n      y = \"Life expectancy\",\n      title = \"Life expectancy vs. percent internet users\", \n      subtitle = \"Data from 2014 from the CIA Factbook\"\n    )\n\nWarning: Removed 27 rows containing missing values or values outside the scale range\n(`geom_point()`)."
  },
  {
    "objectID": "_practica/practicum3.html#interpreteren-van-een-waarschuwing",
    "href": "_practica/practicum3.html#interpreteren-van-een-waarschuwing",
    "title": "Practicum 3",
    "section": "Interpreteren van een waarschuwing",
    "text": "Interpreteren van een waarschuwing\n\nOpdrachtHintCode\n\n\nToen je de code bij de vorige vraag uitvoerde, kreeg je waarschijnlijk onderstaande waarschuwing. Leg uit wat R je hier vertelt en waarom deze waarschuwing ontstaat.\nWarning message: Removed 27 rows containing missing values (geom_point).\n\n\nBekijk de data van de drie variabelen die in de grafiek worden gebruikt eens goed. Wat valt je op?\n\n\nEr zijn 27 landen waarvoor er geen data (NA) beschikbaar zijn voor minstens een van de drie variabelen die gebruikt worden om de grafiek te maken. Dat kun je nagaan met onderstaande code. Deze 27 landen worden door ggplot2 uit de grafiek gelaten, aangezien de benodigde waarden hiervoor niet bepaald kunnen worden.\n\ncia_factbook %&gt;% filter(is.na(life_exp_at_birth)|is.na(internet_users)|is.na(population))\n\n\n\n\n\n\n\n\n\n\n\n\ncountry\nlife_exp_at_birth\ninternet_users\npopulation\n\n\n\n\nAlgeria\n76.39\nNA\n38813722\n\n\nAngola\n55.29\nNA\n19088106\n\n\nNigeria\n52.62\nNA\n177155754\n\n\nSouth Sudan\nNA\nNA\n11562695\n\n\nWestern Sahara\n62.27\nNA\n554795\n\n\nKorea, North\n69.81\nNA\n24851627\n\n\nBenin\n61.07\nNA\n10160556\n\n\nSvalbard\nNA\nNA\n1872\n\n\nMontenegro\nNA\n280000\n650036\n\n\nFalkland Islands (Islas Malvinas)\nNA\n2900\n3361\n\n\nTurks and Caicos Islands\n79.55\nNA\n49070\n\n\nIsle of Man\n80.98\nNA\n86866\n\n\nNorthern Mariana Islands\n77.64\nNA\n51483\n\n\nPalau\n72.60\nNA\n21186\n\n\nCuracao\n77.98\nNA\n146836\n\n\nNiue\nNA\n1100\n1190\n\n\nSaint Pierre and Miquelon\n80.26\nNA\n5716\n\n\nAmerican Samoa\n74.91\nNA\n54517\n\n\nChristmas Island\nNA\n464\n1530\n\n\nPitcairn Islands\nNA\nNA\n48\n\n\nNorfolk Island\nNA\nNA\n2210\n\n\nSint Maarten\n77.61\nNA\n39689\n\n\nNauru\n66.40\nNA\n9488\n\n\nTokelau\nNA\n800\n1337\n\n\nHoly See (Vatican City)\nNA\nNA\n842\n\n\nUnited States Pacific Island Wildlife Refuges\nNA\nNA\nNA\n\n\nSaint Barthelemy\nNA\nNA\n7267"
  },
  {
    "objectID": "_practica/practicum3.html#kleur-van-datapunten-aanpassen",
    "href": "_practica/practicum3.html#kleur-van-datapunten-aanpassen",
    "title": "Practicum 3",
    "section": "Kleur van datapunten aanpassen",
    "text": "Kleur van datapunten aanpassen\n\nOpdrachtHintCode\n\n\nGeef de datapunten in de grafiek een blauwe kleur. Je kunt het commando colours() gebruiken om te zien welke kleuren standaard beschikbaar zijn in R.\n\n\nZie Sectie 5.2.\n\n\n\n#punten blauw maken\ncia_factbook %&gt;% \n  ggplot(aes(y = life_exp_at_birth,\n             x = internet_users/population  #N.B. je kunt NIET hier de mapping colour = \"steelblue2\" toevoegen\n             )) +\n  geom_point(colour = \"steelblue2\") + #kleur van de punten aangepast naar \"steelblue2\"\n  scale_x_continuous(\n    labels = label_percent(scale = 100),\n    limits = c(0, 1)) +\n  theme_bw() + \n  labs(    \n      x = \"Percent internet users\",\n      y = \"Life expectancy\",\n      title = \"Life expectancy vs. percent internet users\", \n      subtitle = \"Data from 2014 from the CIA Factbook\"\n      )\n\nWarning: Removed 27 rows containing missing values or values outside the scale range\n(`geom_point()`)."
  },
  {
    "objectID": "_practica/practicum3.html#datapunten-doorzichtig-maken",
    "href": "_practica/practicum3.html#datapunten-doorzichtig-maken",
    "title": "Practicum 3",
    "section": "Datapunten doorzichtig maken",
    "text": "Datapunten doorzichtig maken\n\nOpdrachtHintCode\n\n\nEen aantal datapunten in de grafiek ligt over elkaar heen. Maak deze datapunten zichtbaar door alle datapunten enigszins transparant te maken.\n\n\nHiervoor gebruik je de setting alpha. Zie Sectie 5.2.\n\n\n\n#punten transparant maken\ncia_factbook %&gt;% \n  ggplot(aes(y = life_exp_at_birth,\n             x = internet_users/population  \n             )) +\n  geom_point(colour = \"steelblue2\", \n             alpha = .8) + #transparantie ingesteld met alpha, lager getal is meer transparant\n  scale_x_continuous(\n    labels = label_percent(scale = 100),\n    limits = c(0, 1)) +\n  theme_bw() +  \n  labs(\n      x = \"Percent internet users\",\n      y = \"Life expectancy\",\n      title = \"Life expectancy vs. percent internet users\", \n      subtitle = \"Data from 2014 from the CIA Factbook\"\n      )\n\nWarning: Removed 27 rows containing missing values or values outside the scale range\n(`geom_point()`)."
  },
  {
    "objectID": "_practica/practicum3.html#de-kleur-van-datapunten-variëren-op-basis-van-een-variabele",
    "href": "_practica/practicum3.html#de-kleur-van-datapunten-variëren-op-basis-van-een-variabele",
    "title": "Practicum 3",
    "section": "De kleur van datapunten variëren op basis van een variabele",
    "text": "De kleur van datapunten variëren op basis van een variabele\n\nOpdrachtHintCode\n\n\nGeef de datapunten nu een kleur op basis van het continent waartoe ze behoren. Zie je een patroon in de data?\n\n\nHiervoor zet je de kleur dus niet vast op een waarde, maar maak je een mapping aan van een variabele. Zie Sectie 5.1.\n\n\n\n#punten kleuren op basis van continent\ncia_factbook %&gt;% \n  ggplot(aes(y = life_exp_at_birth,\n             x = internet_users/population  #Je kunt eventueel ook hier de mapping colour=continent toevoegen\n             )) +\n  geom_point(aes(colour = continent), #Dit is een mapping naar een variabele, je moet dus aes() toevoegen.\n             alpha = .8) + \n  scale_x_continuous(\n    labels = label_percent(scale = 100),\n    limits = c(0, 1)) +\n  theme_bw() +  \n  labs(\n      x = \"Percent internet users\",\n      y = \"Life expectancy\",\n      title = \"Life expectancy vs. percent internet users\", \n      subtitle = \"Data from 2014 from the CIA Factbook\"\n      )\n\nWarning: Removed 27 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\nZie je een patroon in de data? De datapunten van sommige continenten clusteren heel duidelijk (bijv. Afrika en Europa). Er lijkt een lichte trend te zijn dat hoe meer internetgebruikers hoe hoger de levensverwachting."
  },
  {
    "objectID": "_practica/practicum3.html#een-trendlijn-toevoegen",
    "href": "_practica/practicum3.html#een-trendlijn-toevoegen",
    "title": "Practicum 3",
    "section": "Een trendlijn toevoegen",
    "text": "Een trendlijn toevoegen\n\nOpdrachtHintCode\n\n\nVoeg nu voor de hele dataset één zwarte trendlijn toe. Behoud voor de datapunten de kleuren per continent. Wat kun je uit deze trendlijn concluderen?\n\n\nGebruik hiervoor geom_smooth(). Zie Sectie 5.2.\n\n\n\n#een trendlijn voor hele dataset\ncia_factbook %&gt;% \n  ggplot(aes(y = life_exp_at_birth,  \n             x = internet_users/population  #niet hier de mapping 'colour = continent' toevoegen, dan krijg je aparte lijnen per continent\n             )) +\n  geom_point(aes(colour = continent), \n             alpha = .8) + \n  geom_smooth(color = \"black\") +          #toevoegen van trendlijn met geom_smooth()\n  scale_x_continuous(\n    labels = label_percent(scale = 100),\n    limits = c(0, 1)) +\n  theme_bw() +  \n  labs(\n      x = \"Percent internet users\",\n      y = \"Life expectancy\",\n      title = \"Life expectancy vs. percent internet users\", \n      subtitle = \"Data from 2014 from the CIA Factbook\"\n      )\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\nWarning: Removed 27 rows containing non-finite outside the scale range\n(`stat_smooth()`).\n\n\nWarning: Removed 27 rows containing missing values or values outside the scale range\n(`geom_point()`)."
  },
  {
    "objectID": "_practica/practicum3.html#sec-zichtbaar",
    "href": "_practica/practicum3.html#sec-zichtbaar",
    "title": "Practicum 3",
    "section": "Het zichtbaar maken van de datapunten",
    "text": "Het zichtbaar maken van de datapunten\n\nOpdrachtHintCode\n\n\nMet onderstaande code kun je de aanzet maken voor de grafiek. Als je deze uitvoert, krijg je een lege plot (zie Figuur 2.2). Pas de code zodanig aan dat de datapunten zichtbaar worden. De lijnen en kleuren per land voegen we later toe.\n\nukbabynames %&gt;%\n  filter(..., ..., ...) %&gt;%\n  ggplot() +\n  labs(\n        title = \"Number of baby girls named Fiona\",\n        x = \"Year\",\n        y = \"Number of babies\",\n        color = \"Nation\", linetype = \"Nation\"\n      ) +\n  theme_bw() +\n  theme(\n        legend.position = c(0.8, 0.7),\n        legend.background = element_rect(color = \"white\")\n        )\n\n\n\nLet op dat je de data eerst inperkt tot meisjes met de naam Fiona die in of na 2000 geboren zijn.\n\n\n\n#1. bekijken van de data, geen aanpassingen nodig\n  head(ukbabynames)\n\n# A tibble: 6 × 6\n   year sex   name        n  rank nation         \n  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;          \n1  1996 F     SOPHIE   7087     1 England & Wales\n2  1996 F     CHLOE    6824     2 England & Wales\n3  1996 F     JESSICA  6711     3 England & Wales\n4  1996 F     EMILY    6415     4 England & Wales\n5  1996 F     LAUREN   6299     5 England & Wales\n6  1996 F     HANNAH   5916     6 England & Wales\n\n  glimpse(ukbabynames)\n\nRows: 565,817\nColumns: 6\n$ year   &lt;dbl&gt; 1996, 1996, 1996, 1996, 1996, 1996, 1996, 1996, 1996, 1996, 199…\n$ sex    &lt;chr&gt; \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\", \"F\"…\n$ name   &lt;chr&gt; \"SOPHIE\", \"CHLOE\", \"JESSICA\", \"EMILY\", \"LAUREN\", \"HANNAH\", \"CHA…\n$ n      &lt;dbl&gt; 7087, 6824, 6711, 6415, 6299, 5916, 5866, 5828, 5206, 4948, 464…\n$ rank   &lt;dbl&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, …\n$ nation &lt;chr&gt; \"England & Wales\", \"England & Wales\", \"England & Wales\", \"Engla…\n\n#2. datapunten filteren en zichtbaar maken: toevoegen mapping en geom_point()\n  ukbabynames %&gt;%\n    filter(name == \"Fiona\", sex == \"F\", year &gt;= 2000) %&gt;%\n    ggplot(aes(x = year, y = n)) +\n      geom_point() +        #hier worden de punten toegevoegd\n      labs(\n        title = \"Number of baby girls named Fiona\",\n        x = \"Year\",\n        y = \"Number of babies\",\n        color = \"Nation\", linetype = \"Nation\"\n      ) +\n      theme_bw() +\n      theme(\n        legend.position = c(0.8, 0.7),\n        legend.background = element_rect(color = \"white\")\n      )\n\nWarning: A numeric `legend.position` argument in `theme()` was deprecated in ggplot2\n3.5.0.\nℹ Please use the `legend.position.inside` argument of `theme()` instead.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFiguur 2.2: een nog lege grafiek"
  },
  {
    "objectID": "_practica/practicum3.html#lijnen-toevoegen-per-groep",
    "href": "_practica/practicum3.html#lijnen-toevoegen-per-groep",
    "title": "Practicum 3",
    "section": "Lijnen toevoegen per groep",
    "text": "Lijnen toevoegen per groep\n\nOpdrachtHintCode\n\n\nVoeg nu de lijnen toe. Zorg dat er aparte lijnen komen voor ieder land. Hiervoor gebruik je de aes-mapping group =.\n\n\nBedenk welk geom je hiervoor nodig hebt. Zie eventueel het ggplot2 cheatsheet voor een overzicht.\n\n\n\n#lijnen toevoegen via geom_line()\n  ukbabynames %&gt;%\n    filter(name == \"Fiona\", sex == \"F\", year &gt;= 2000) %&gt;%\n    ggplot(aes(x = year, y = n, group = nation)) +\n      geom_line() +                 #hier wordt een lijn toegevoegd\n      geom_point() +\n      labs(\n        title = \"Number of baby girls named Fiona\",\n        x = \"Year\",\n        y = \"Number of babies\",\n        color = \"Nation\", linetype = \"Nation\"\n      ) +\n      theme_bw() +\n      theme(\n        legend.position = c(0.8, 0.7),\n        legend.background = element_rect(color = \"white\")\n      )"
  },
  {
    "objectID": "_practica/practicum3.html#de-kleur-en-lijnsoort-aanpassen-per-groep",
    "href": "_practica/practicum3.html#de-kleur-en-lijnsoort-aanpassen-per-groep",
    "title": "Practicum 3",
    "section": "De kleur en lijnsoort aanpassen per groep",
    "text": "De kleur en lijnsoort aanpassen per groep\n\nOpdrachtHintCode\n\n\nZorg tot slot dat de datapunten en lijnen per land een kleur krijgen en dat het type lijn per land verschilt. Wat kun je op basis van deze grafiek concluderen?\n\n\nBedenk om welke aesthetics het gaat. Zie hiervoor het ggplot2 cheatsheet.\n\n\n\n#lijnen en punten een kleur geven, lijntype aanpassen\n#het lijntype pas je aan met de aes-mapping 'linetype'\n  ukbabynames %&gt;%\n    filter(name == \"Fiona\", sex == \"F\", year &gt;= 2000) %&gt;%\n    ggplot(aes(x = year, y = n, group = nation, colour = nation, linetype = nation)) + #door toevoeging van colour en linetype is group = nation nu overbodig. Deze kun je verwijderen.\n    geom_line() +\n    geom_point() +\n    labs(\n      title = \"Number of baby girls named Fiona\",\n      x = \"Year\",\n      y = \"Number of babies\",\n      color = \"Nation\", linetype = \"Nation\"\n    ) +\n    theme_bw() +\n    theme(\n      legend.position = c(0.8, 0.7),\n      legend.background = element_rect(color = \"white\")\n    )  \n\n\n\n\nWat kun je op basis van deze grafiek concluderen? Aan het begin van deze eeuw was de naam Fiona veel populairder in Schotland dan in Noord-Ierland. De afname is in Schotland veel sterker geweest."
  },
  {
    "objectID": "_practica/practicum3.html#code-annoteren",
    "href": "_practica/practicum3.html#code-annoteren",
    "title": "Practicum 3",
    "section": "Code annoteren",
    "text": "Code annoteren\n\nOpdrachtHintCode\n\n\nBekijk de code in de uitwerking van de vorige opdracht en kopieer deze. Geef vervolgens in de code aan wat de bijdrage is van de code in regels 12, 16 en 17.\n\n\nSchakel steeds een stukje code uit met # en kijk goed wat er verandert in hoe de grafiek eruit ziet.\n\n\n\n#lijnen en punten een kleur geven, lijntype aanpassen\n#het lijntype pas je aan met de aes-mapping 'linetype'\n  ukbabynames %&gt;%\n    filter(name == \"Fiona\", sex == \"F\", year &gt;= 2000) %&gt;%\n    ggplot(aes(x = year, y = n, group = nation, colour=nation, linetype=nation)) + \n    geom_line() +\n    geom_point() +\n    labs(\n      title = \"Number of baby girls named Fiona\",\n      x = \"Year\",\n      y = \"Number of babies\", \n      color = \"Nation\", linetype = \"Nation\"               #zorgt dat er een legenda verschijnt met Nation als titel i.p.v. nation\n    ) +\n    theme_bw() +\n    theme(\n      legend.position = c(0.8, 0.7),                      #bepaalt positionering van de legenda\n      legend.background = element_rect(color = \"white\")   #zet achtergrondkleur legenda op wit\n    )"
  },
  {
    "objectID": "_practica/practicum3.html#sec-fiona-extra",
    "href": "_practica/practicum3.html#sec-fiona-extra",
    "title": "Practicum 3",
    "section": "Meer data zichtbaar maken",
    "text": "Meer data zichtbaar maken\n\nOpdrachtHintCode\n\n\nMaak tot slot ook de datapunten van voor 2000 zichtbaar. Wat valt je op?\n\n\nKijk nog eens terug naar het begin van deze opdracht: hoe heb je toen bepaald welke datapunten zichtbaar werden?\n\n\n\n#datapunten van voor 2000 zichtbaar maken via filter, verwijderen van 'year &gt;= 2000'\n  ukbabynames %&gt;%\n    filter(name == \"Fiona\", sex == \"F\") %&gt;%\n    ggplot(aes(x = year, y = n, group = nation, colour = nation, linetype = nation)) +\n    geom_line() +\n    geom_point() +\n    labs(\n      title = \"Number of baby girls named Fiona\",\n      x = \"Year\",\n      y = \"Number of babies\",\n      color = \"Nation\", linetype = \"Nation\"\n    ) +\n    theme_bw() +\n    theme(\n      legend.position = c(0.8, 0.7),\n      legend.background = element_rect(color = \"white\")\n    )    \n\n\n\n\nWat valt op? Blijkbaar zijn er geen gegevens voor Noord-Ierland van voor 1997. Voor de Schotse data zien we dat de populariteit van de naam Fiona behoorlijk is teruggelopen sinds halverwege de jaren 70."
  }
]
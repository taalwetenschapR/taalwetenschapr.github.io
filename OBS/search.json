[
  {
    "objectID": "data.html#sec-datatabellen",
    "href": "data.html#sec-datatabellen",
    "title": "3  Data in R",
    "section": "3.1 Datatabellen en vectoren",
    "text": "3.1 Datatabellen en vectoren\nWe kunnen data in R in verschillende formaten tegenkomen. Tijdens deze cursus krijgen we vooral te maken met datatabellen en vectoren. Een datatabel wordt in tidyverse een tibble genoemd en gaat in R ook wel door het leven onder de naam data.frame.1 Een datatabel bestaat uit rijen (de observaties) en kolommen (de variabelen) en doet daarmee erg denken aan een gewone tabel of spreadsheet zoals je dat misschien wel kent uit bijvoorbeeld Excel.1 Het tidyverse is voor een groot deel ontwikkeld door de Nieuw-Zeelander Hadley Wickham. Het woord tibble schijnt te verwijzen naar de manier waarop in Nieuw-Zeeland table wordt uitgesproken.\nHieronder vind je een voorbeeld van een tibble met data uit het package wordbankr. Dit package geeft toegang tot Wordbank een grote database met daarin informatie over hoe de woordenschat van kinderen zich ontwikkelt in verschillende talen.22 Voor een uitgebreide beschrijving van deze data, zie de website van het Wordbank Project: https://wordbank.stanford.edu/\nDe data in deze database zijn verzameld aan de hand van de MacArthur-Bates Communicative Development Inventory (MB-CDI), een vragenlijst waarin ouders aangeven welke woorden hun kind op welke leeftijd kent. Informatie over alle beschikbare versies van deze vragenlijst in verschillende talen hebben we opgeslagen in de tibble met de naam wordbank_datasets.\n\n\n\n\nwordbank_datasets\n\n# A tibble: 89 × 8\n   instrument_id language            form  form_type age_min age_max has_grammar\n           &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1             1 British Sign Langu… WG    WG              8      36           0\n 2             2 Cantonese           WS    WS             16      30           0\n 3             3 Croatian            WG    WG              8      16           0\n 4             4 Croatian            WS    WS             16      30           0\n 5             5 Danish              WG    WG              8      20           0\n 6             6 Danish              WS    WS             16      36           1\n 7             7 English (American)  WG    WG              8      18           0\n 8             8 English (American)  WS    WS             16      30           1\n 9             9 French (Quebecois)  WG    WG              8      16           0\n10            10 French (Quebecois)  WS    WS             16      30           1\n# ℹ 79 more rows\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\nJe kunt de inhoud van een datatabel bekijken door de naam van de tabel uit te voeren. Bij een tibble krijg je standaard de eerste tien rijen te zien. Het aantal kolommen (variabelen) dat je te zien krijgt is afhankelijk van de grootte van je scherm. Bovenaan de tibble kun je zien om hoeveel rijen en kolommen het gaat (hier 89 x 8). Onderaan wordt je verteld hoeveel rijen en welke variabelen er niet getoond zijn (hier bijvoorbeeld 79 rijen). Je kunt het aantal rijen en variabelen ook zichtbaar maken met de functies nrow() en ncol() respectievelijk.\n\nnrow(wordbank_datasets)\n\n[1] 89\n\nncol(wordbank_datasets)\n\n[1] 8\n\n\nWil je de gehele datatabel zien (afgeraden bij heel grote bestanden) dan kun je de functie View() gebruiken. Er zal dan een tabblad geopend worden in RStudio waarin je de datatabel kunt bekijken.\n\nView(wordbank_datasets)\n\nDe weergave van de tibble in R vertelt je ook iets over de manier waarop R de variabelen uit de tibble ziet. Onder de namen van de variabelen (de bovenste regel) vind je namelijk tussen vishaken &lt;&gt; het type dat R heeft toegekend op basis van de datapunten in de variabele. Zo heeft de variabele language het type chr voor character (tekst) toegewezen gekregen en de variabele age_min het type int voor integer (geheel getal). Tabel 3.1 geeft een overzicht van een aantal veel voorkomende datatypes van variabelen in R.\n\n\n\n\n\n\n\n\n\n\n\n\nsoort\nnaam in R\nafkorting in R\nvoorbeeld\nmeetniveau\n\n\n\n\ntekst, string\ncharacter\nchar, chr\n“a”, “woord”\nnominaal\n\n\nboolean, waarheidswaarde\nlogical\nlogi, lgl\nTRUE, FALSE\nnominaal\n\n\nfactor\nfactor\nfct\nDuits, Engels\nnominaal\n\n\ngeordende factor\nordered factor\nord\nlaag, hoog\nordinaal\n\n\ngetal\nnumeric, double\nnum, dbl\n1, 2.5, 3.14\nnumeriek\n\n\ngeheel getal\ninteger\nint\n1, 2, 100\nnumeriek\n\n\n\nTabel 3.1: een aantal veel voorkomende datatypes in R\nNaast de datatabel zijn vectoren een veel voorkomende dataformaat in R. Een vector is een geordend rijtje van elementen van hetzelfde type. Een variabele uit een datatabel kunnen we bijvoorbeeld omzetten naar een vector met de functie pull().\n\nlanguages &lt;- pull(wordbank_datasets, language)\n\nBovenstaande code wijst door het gebruik van de operator &lt;- de inhoud van de variabele language toe aan een vector met de naam languages. Je kunt hier zelf vrijwel elke naam kiezen. Het is verstandig om namen te kiezen die betekenisvol zijn voor jezelf (ook nog als je je code een tijd later weer leest) of voor iemand anders die je code bekijkt. Namen als dataset1, datasetdef en datasetechtdefinitief zijn dus niet zo handig. Daarnaast is het voor de leesbaarheid fijn om consistent te zijn: gebruik alleen kleine letters (snake case) en scheid inhoudswoorden met een underscore _, dus bijv. wordbank_datasets.\nHet resultaat van het uitvoeren van pull() is een vector met de naam languages met daarin de 89 namen van talen. Deze vector zal in RStudio in het venster rechtsboven onder het tabblad Environment verschijnen onder het kopje Values. In de Environment vind je een overzicht van alle datatabellen en vectoren die voor R toegankelijk zijn. Je kunt de namen van deze databronnen gebruiken in de code die je schrijft. Zo kunnen we de naam languages nu gebruiken als argument van functies. Laten we eerst kijken wat er in de vector zit. Hiervoor typen we alleen de naam van de vector:\n\nlanguages\n\n [1] \"British Sign Language\"  \"Cantonese\"              \"Croatian\"              \n [4] \"Croatian\"               \"Danish\"                 \"Danish\"                \n [7] \"English (American)\"     \"English (American)\"     \"French (Quebecois)\"    \n[10] \"French (Quebecois)\"     \"German\"                 \"Hebrew\"                \n[13] \"Hebrew\"                 \"Italian\"                \"Italian\"               \n[16] \"Mandarin (Beijing)\"     \"Mandarin (Beijing)\"     \"Mandarin (Beijing)\"    \n[19] \"Norwegian\"              \"Norwegian\"              \"Russian\"               \n[22] \"Russian\"                \"Slovak\"                 \"Slovak\"                \n[25] \"Spanish (Mexican)\"      \"Spanish (Mexican)\"      \"Swedish\"               \n[28] \"Swedish\"                \"Turkish\"                \"Turkish\"               \n[31] \"English (British)\"      \"English (British)\"      \"American Sign Language\"\n[34] \"American Sign Language\" \"American Sign Language\" \"American Sign Language\"\n[37] \"Greek (Cypriot)\"        \"Kigiriama\"              \"Kigiriama\"             \n[40] \"Kiswahili\"              \"Kiswahili\"              \"Czech\"                 \n[43] \"English (Australian)\"   \"English (British)\"      \"Latvian\"               \n[46] \"Latvian\"                \"Korean\"                 \"Korean\"                \n[49] \"French (French)\"        \"French (French)\"        \"Spanish (European)\"    \n[52] \"Spanish (European)\"     \"Portuguese (European)\"  \"Portuguese (European)\" \n[55] \"Mandarin (Taiwanese)\"   \"Mandarin (Taiwanese)\"   \"English (Irish)\"       \n[58] \"Irish\"                  \"Finnish\"                \"Dutch\"                 \n[61] \"Dutch\"                  \"Dutch\"                  \"Dutch\"                 \n[64] \"Dutch\"                  \"Dutch\"                  \"Dutch\"                 \n[67] \"Hungarian\"              \"Spanish (Argentinian)\"  \"American Sign Language\"\n[70] \"Spanish (Chilean)\"      \"Spanish (Peruvian)\"     \"Spanish (Peruvian)\"    \n[73] \"Persian\"                \"Persian\"                \"Finnish\"               \n[76] \"English (American)\"     \"English (American)\"     \"English (British)\"     \n[79] \"Arabic (Saudi)\"         \"Arabic (Saudi)\"         \"Arabic (Saudi)\"        \n[82] \"Estonian\"               \"Catalan\"                \"Korean\"                \n[85] \"Finnish\"                \"Finnish\"                \"Catalan\"               \n[88] \"Japanese\"               \"Japanese\"              \n\n\nHet gaat hier om een opsomming van alle talen die voorkomen in de dataset wordbank_datasets. Het aantal elementen in de vector kunnen we vaststellen met de functie length() en het datatype van de vector met de functie class()\n\nlength(languages)\n\n[1] 89\n\nclass(languages)\n\n[1] \"character\"\n\n\nHet gaat hier dus om een character vector die bestaat uit 89 elementen. Het type (de class) van de vector wordt toegepast op alle elementen in de vector ook als er oorspronkelijk elementen in zijn gestopt van een verschillend type (bijv. woorden en getallen). Dit zien we bijvoorbeeld als we aan R vragen wat het type is van onze eerder met de functie c() gemaakte vector.\n\nek_1988 &lt;- c(\"Nederland\", 1988, \"plek 1\")\nclass(ek_1988)\n\n[1] \"character\"\n\n\nOndanks dat we een getal hebben toegevoegd aan onze vector is het type van de vector als geheel toch character. Wanneer we de vector laten zien, dan valt ook op dat er rond het oorspronkelijk getal 1988 nu aanhalingstekens staan. Het wordt door R dus gezien als een woord.\n\nek_1988\n\n[1] \"Nederland\" \"1988\"      \"plek 1\""
  },
  {
    "objectID": "data.html#sec-data-inlezen",
    "href": "data.html#sec-data-inlezen",
    "title": "3  Data in R",
    "section": "3.2 Data inlezen",
    "text": "3.2 Data inlezen\nData om te analyseren zijn vaak opgeslagen in databestanden. Deze bestanden kunnen een verschillend formaat (extensie) hebben. Veel voorkomende formaten (in deze cursus) zijn tekstbestanden (.txt) en csv-bestanden (.csv). CSV staat voor ‘comma separated values’ en geeft aan dat de waarden van variabelen (‘de cellen’ in een spreadsheet) van elkaar gescheiden zijn door scheidingstekens. Zoals de naam doet vermoeden is de komma hier het te verwachten scheidingsteken, maar verwarrend genoeg kan dit ook een puntkomma zijn (zie Figuur 3.1). Welk scheidingsteken wordt gebruikt hangt onder anderen af van de instellingen van je computer. Het is dus van belang om goed te bekijken met wat voor een bestand je te maken hebt voor je het gaat inlezen en ook na het inlezen goed te controleren of dit goed is gegaan.\n\n\n\nFiguur 3.1: CSV-bestand met puntkomma als scheidingsteken\n\n\nExterne databestanden zul je eerst moeten inlezen in R voor je ermee kunt gaan werken. Hiervoor bestaan gelukkig verschillende functies in R, gespecificeerd voor het soort bestand waarmee je werkt. Die functies beginnen doorgaans met read. Binnen het tidyverse gebruiken we read-functies gevolgd door een underscore (read_). Deze functies lezen een specifiek soort databestand in als een tibble. Zo is er voor csv-bestanden een functie read_csv voor bestanden met een komma als scheidingsteken en een read_csv2 voor bestanden met een puntkomma als scheidingsteken. De functie read_delim() (voor read in delimited data file) is de algemene functie om databestanden in te lezen, waaronder tekstbestanden, en read_csv() en read_csv2() zijn specifieke versies hiervan waarbij het type delimiter (het scheidingsteken) is vastgelegd (dus read_csv() is onderliggend read_delim(file = , delim = \",\")). Type maar eens ‘read_’ in je R-script en RStudio zal automatisch alle opties geven zowel binnen baseR als binnen het tidyverse (zie Figuur 3.2). Aan jou de taak om de juiste functie te vinden bij je databestand. Wanneer je werkt in een R-project zal de read_()-functie gaan zoeken in de map van het R-project (zie box Waar staat je databestand? verderop).\nSoms is het handig om een in R-gecreëerde dataset op te slaan naar een databestand, zodat je het later of in een ander programma kunt gebruiken. Het opslaan van databestanden in R is eenvoudig. Er bestaat voor elke read_-functie namelijk een tegenhanger die begint met write_, bijv. write_csv. Wanneer je werkt in een R-project, hoef je de locatie wederom niet te specificeren. RStudio slaat het bestand automatisch op in de map van je project.\n\n\n\nFiguur 3.2: automatische aanvulopties in RStudio\n\n\nHet is belangrijk om altijd goed te controleren of het inlezen van je databestand is gelukt. Heb je inderdaad het aantal observaties en kolommen (variabelen) dat je verwacht. Zo niet, dan is er iets misgegaan. In onderstaand voorbeeld lezen we bijvoorbeeld het databestand wordbank_datasets.csv in met de functie read_csv2(), terwijl de datapunten niet gescheiden zijn door een puntkomma, maar door een komma (en dus read_csv() nodig is). Het resultaat laat zien dat we in plaats van 8 variabelen (en dus 8 kolommen), maar 1 variabele (1 kolom) hebben waarin alle informatie is samengepropt.\n\nwordbank_datasets &lt;- read_csv2(file = \"_datasets/wordbank_datasets.csv\")\n\nℹ Using \"','\" as decimal and \"'.'\" as grouping mark. Use `read_delim()` for more control.\n\n\nRows: 89 Columns: 1\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \";\"\nchr (1): instrument_id,language,form,form_type,age_min,age_max,has_grammar,u...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nwordbank_datasets\n\n# A tibble: 89 × 1\n   instrument_id,language,form,form_type,age_min,age_max,has_grammar,unilemma_…¹\n   &lt;chr&gt;                                                                        \n 1 1,British Sign Language,WG,WG,8,36,0,0.95                                    \n 2 2,Cantonese,WS,WS,16,30,0,0.95                                               \n 3 3,Croatian,WG,WG,8,16,0,1                                                    \n 4 4,Croatian,WS,WS,16,30,0,1                                                   \n 5 5,Danish,WG,WG,8,20,0,1                                                      \n 6 6,Danish,WS,WS,16,36,1,0.93                                                  \n 7 7,English (American),WG,WG,8,18,0,1                                          \n 8 8,English (American),WS,WS,16,30,1,1                                         \n 9 9,French (Quebecois),WG,WG,8,16,0,1                                          \n10 10,French (Quebecois),WS,WS,16,30,1,0.99                                     \n# ℹ 79 more rows\n# ℹ abbreviated name:\n#   ¹​`instrument_id,language,form,form_type,age_min,age_max,has_grammar,unilemma_coverage`\n\n\nDit moeten we herstellen voordat we verdergaan met de data-analyse. Bezuinig niet op de controle van deze stap. Je loopt anders geheid vast.\n\nwordbank_datasets &lt;- read_csv(file = \"_datasets/wordbank_datasets.csv\")\n\nRows: 89 Columns: 8\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (3): language, form, form_type\ndbl (5): instrument_id, age_min, age_max, has_grammar, unilemma_coverage\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nwordbank_datasets\n\n# A tibble: 89 × 8\n   instrument_id language            form  form_type age_min age_max has_grammar\n           &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1             1 British Sign Langu… WG    WG              8      36           0\n 2             2 Cantonese           WS    WS             16      30           0\n 3             3 Croatian            WG    WG              8      16           0\n 4             4 Croatian            WS    WS             16      30           0\n 5             5 Danish              WG    WG              8      20           0\n 6             6 Danish              WS    WS             16      36           1\n 7             7 English (American)  WG    WG              8      18           0\n 8             8 English (American)  WS    WS             16      30           1\n 9             9 French (Quebecois)  WG    WG              8      16           0\n10            10 French (Quebecois)  WS    WS             16      30           1\n# ℹ 79 more rows\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\n\n\n\n\n\n\nWaar staat je databestand?\n\n\n\nOm databestanden te kunnen inlezen in R, moet je normaal gesproken eerst de computer vertellen waar deze te vinden zijn. Wanneer de databestanden onderdeel zijn van een R-project, weet RStudio al waar het die bestanden moet vinden. RStudio kijkt namelijk automatisch in de map van je project. Dat is een groot voordeel van werken met een R-project. Je kunt dan werken met een relatief pad. In bovenstaand voorbeeld staan de databestanden binnen de map van het R-project in een map _datasets en door dit voor de naam van het bestand te plakken _datasets/wordbank_datasets.csv gaat R in de map van het R-project zoeken naar bestanden in de map _datasets. Wanneer je problemen ondervindt met relatieve paden kun je ook kiezen voor een absoluut pad. Hierbij geeft je de hele naam van de locatie op je computer, bijv. C://Peter/OBS/_datasets/wordbank_datasets.csv.\n\n\n\n\n\n\n3.2.1 Variabelennamen aanpassen\nWanneer je het databestand goed hebt ingelezen is het eerste wat je moet doen de namen van de variabelen controleren. Zoals eerder gemeld, hanteren we voor variabelennamen snake_case: alleen kleine letters en scheiding van inhoudswoorden met een underscore _, dus bijv. wordbank_datasets. Dit is echter niet de enige manier waarop variabelennamen voorkomen. In de praktijk kun je echt vanalles verwachten. Zie bijvoorbeeld hieronder, waar we de namen van twee variabelen uit onze datatabel wordbank_datasets ter illustratie hebben aangepast. We gebruiken hier de functie head() om alleen een deel van de rijen zichtbaar te maken (hier maar 1):\n\nhead(wordbank_datasets_slechte_namen, n = 1) \n\n# A tibble: 1 × 8\n  InstrumentID language            form  `form type` age_min age_max has_grammar\n         &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt; &lt;chr&gt;         &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1            1 British Sign Langu… WG    WG                8      36           0\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\nWe kunnen ook de functie names() gebruiken:\n\nnames(wordbank_datasets_slechte_namen)\n\n[1] \"InstrumentID\"      \"language\"          \"form\"             \n[4] \"form type\"         \"age_min\"           \"age_max\"          \n[7] \"has_grammar\"       \"unilemma_coverage\"\n\n\nWe zien twee variabelen die een afwijkende naam hebben. InstrumentID gebruikt hoofdletters en geen _ om inhoudswoorden (instrument en id) te scheiden en form type heeft een spatie i.p.v. een underscore. Dat laatste is zeker iets om te vermijden, want dat kan allerlei ongemak opleveren. We kunnen deze namen handmatig aanpassen met de functie rename():\n\nrename(.data = wordbank_datasets_slechte_namen,\n       instrument_id = InstrumentID,\n       form_type = `form type`)\n\n# A tibble: 89 × 8\n   instrument_id language            form  form_type age_min age_max has_grammar\n           &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1             1 British Sign Langu… WG    WG              8      36           0\n 2             2 Cantonese           WS    WS             16      30           0\n 3             3 Croatian            WG    WG              8      16           0\n 4             4 Croatian            WS    WS             16      30           0\n 5             5 Danish              WG    WG              8      20           0\n 6             6 Danish              WS    WS             16      36           1\n 7             7 English (American)  WG    WG              8      18           0\n 8             8 English (American)  WS    WS             16      30           1\n 9             9 French (Quebecois)  WG    WG              8      16           0\n10            10 French (Quebecois)  WS    WS             16      30           1\n# ℹ 79 more rows\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\nBij rename() geven we als eerste argument .data de naam van de datatabel mee waarin we namen willen veranderen en vervolgens, gescheiden door komma’s de namen van de variabelen die we willen hernoemen. Hierbij geef je (verwarrend genoeg) eerst de nieuwe naam van de variabele en dan de oude naam. Variabelennamen met een spatie erin moet je tussen backticks ` ` zetten.\nWe zijn er nu nog niet. Met bovenstaande code hebben we de namen nog niet blijvend veranderd. Ze zijn alleen veranderd in de print out die je te zien krijgt in R. Dit kunnen we zien als we de datatabel nogmaals naar het scherm printen:\n\nwordbank_datasets_slechte_namen\n\n# A tibble: 89 × 8\n   InstrumentID language           form  `form type` age_min age_max has_grammar\n          &lt;dbl&gt; &lt;chr&gt;              &lt;chr&gt; &lt;chr&gt;         &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1            1 British Sign Lang… WG    WG                8      36           0\n 2            2 Cantonese          WS    WS               16      30           0\n 3            3 Croatian           WG    WG                8      16           0\n 4            4 Croatian           WS    WS               16      30           0\n 5            5 Danish             WG    WG                8      20           0\n 6            6 Danish             WS    WS               16      36           1\n 7            7 English (American) WG    WG                8      18           0\n 8            8 English (American) WS    WS               16      30           1\n 9            9 French (Quebecois) WG    WG                8      16           0\n10           10 French (Quebecois) WS    WS               16      30           1\n# ℹ 79 more rows\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\nHier zien we nog steeds de oude namen. Om de namen blijvend te veranderen moeten we de verandering toewijzen aan de datatabel zelf met de operator &lt;- die we eerder hebben gezien:\n\nwordbank_datasets_slechte_namen &lt;- rename(.data = wordbank_datasets_slechte_namen,\n       instrument_id = InstrumentID,\n       form_type = `form type`)\n\nnames(wordbank_datasets_slechte_namen)\n\n[1] \"instrument_id\"     \"language\"          \"form\"             \n[4] \"form_type\"         \"age_min\"           \"age_max\"          \n[7] \"has_grammar\"       \"unilemma_coverage\"\n\n\nDe functie rename() is goed te gebruiken als je maar een beperkt aantal namen moet aanpassen. Wanneer er echter veel (meer dan 3) namen moeten worden aangepast is het een beetje omslachtig. In dat geval kun je beter de functie clean_names() uit het package janitor gebruiken. Je kunt hiervoor het package als geheel laden of de functie aanroepen met janitor::clean_names(). Ook hier geldt dat je de output van deze functie weer moet toewijzen aan een datatabel om de verandering blijvend door te voeren. In onderstaand voorbeeld hebben we gekozen om de oorspronkelijk naam voor de datatabel (wordbank_datasets) weer te gebruiken, aangezien de slechte namen zijn aangepast.\n\nwordbank_datasets &lt;- janitor::clean_names(wordbank_datasets_slechte_namen)\n\nnames(wordbank_datasets)\n\n[1] \"instrument_id\"     \"language\"          \"form\"             \n[4] \"form_type\"         \"age_min\"           \"age_max\"          \n[7] \"has_grammar\"       \"unilemma_coverage\"\n\n\n\n\n3.2.2 Type van variabelen aanpassen\nNu de variabelen allemaal een eigen kolom en een goede naam hebben, moeten we nog controleren of ze ook van het juiste type zijn. Bij het inlezen van de data doet R een educated guess naar het type van de variabelen op basis van de data die in de variabelen zitten. Zitten er getallen in dan zal het gaan voor dbl (of num, int) en wanneer er alleen tekst in zit dan voor char. In de meeste gevallen gaat dit goed, maar niet altijd.\nEr is één ding om goed op te letten en dat is het feit dat we in statistische analyse categorische variabelen doorgaans factoren noemen. Factoren zijn categorische variabelen die een beperkt aantal terugkerende waarden kunnen aannemen. Die waarden noemen we levels. In R krijgen factoren het datatype factor.\nNeem als voorbeeld de variabele language uit onze datatabel wordbank_datasets, die we eerder ook als vector languages hebben opgeslagen. In deze variabelen staan de talen van alle vragenlijsten die in de wordbank zitten opgesomd. We zien dat sommige talen meerdere keren voorkomen. Bij de eerste 10 observaties komen 4 talen 2 keer voor (Croatian, Danish, English (American) en French (Quebecois)):\n\nwordbank_datasets\n\n# A tibble: 89 × 8\n   instrument_id language            form  form_type age_min age_max has_grammar\n           &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt; &lt;chr&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1             1 British Sign Langu… WG    WG              8      36           0\n 2             2 Cantonese           WS    WS             16      30           0\n 3             3 Croatian            WG    WG              8      16           0\n 4             4 Croatian            WS    WS             16      30           0\n 5             5 Danish              WG    WG              8      20           0\n 6             6 Danish              WS    WS             16      36           1\n 7             7 English (American)  WG    WG              8      18           0\n 8             8 English (American)  WS    WS             16      30           1\n 9             9 French (Quebecois)  WG    WG              8      16           0\n10            10 French (Quebecois)  WS    WS             16      30           1\n# ℹ 79 more rows\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\nMet de functie dinstinct() voor datatabellen of unique voor vectoren kunnen we laten zien dat er in de 89 observaties in de data 42 verschillende talen voorkomen:\n\ndistinct(.data = wordbank_datasets, language)\n\n# A tibble: 42 × 1\n   language             \n   &lt;chr&gt;                \n 1 British Sign Language\n 2 Cantonese            \n 3 Croatian             \n 4 Danish               \n 5 English (American)   \n 6 French (Quebecois)   \n 7 German               \n 8 Hebrew               \n 9 Italian              \n10 Mandarin (Beijing)   \n# ℹ 32 more rows\n\nunique(languages)\n\n [1] \"British Sign Language\"  \"Cantonese\"              \"Croatian\"              \n [4] \"Danish\"                 \"English (American)\"     \"French (Quebecois)\"    \n [7] \"German\"                 \"Hebrew\"                 \"Italian\"               \n[10] \"Mandarin (Beijing)\"     \"Norwegian\"              \"Russian\"               \n[13] \"Slovak\"                 \"Spanish (Mexican)\"      \"Swedish\"               \n[16] \"Turkish\"                \"English (British)\"      \"American Sign Language\"\n[19] \"Greek (Cypriot)\"        \"Kigiriama\"              \"Kiswahili\"             \n[22] \"Czech\"                  \"English (Australian)\"   \"Latvian\"               \n[25] \"Korean\"                 \"French (French)\"        \"Spanish (European)\"    \n[28] \"Portuguese (European)\"  \"Mandarin (Taiwanese)\"   \"English (Irish)\"       \n[31] \"Irish\"                  \"Finnish\"                \"Dutch\"                 \n[34] \"Hungarian\"              \"Spanish (Argentinian)\"  \"Spanish (Chilean)\"     \n[37] \"Spanish (Peruvian)\"     \"Persian\"                \"Arabic (Saudi)\"        \n[40] \"Estonian\"               \"Catalan\"                \"Japanese\"              \n\n\nWanneer de variable language als type character wordt gezien dan missen we de overeenkomsten tussen deze terugkerende talen. Door er een factor van te maken waarin elke taal een level is maken we dit juist zichtbaar. Dit biedt later allerlei voordelen bij het maken van grafieken, zoals het makkelijker kunnen herordenen van levels, en het doen van statistische analyses. Het is dus verstandig om categorische variabelen om te zetten naar type factor.\nJe kunt een variabele omzetten naar een factor met de functie as.factor().3 Deze zal de levels ordenen op alfabet. Om deze aanpassing te kunnen doen gebruiken we de veelgebruikte functie mutate() waarbij we weer de naam van de variabele eerst noemen en na de = wat we erin willen stoppen. Ook hier geldt weer: om de verandering blijvend te maken moeten we deze toewijzen aan de datatabel met &lt;-.3 Er bestaat ook een tidyverse-variant as_factor(). Deze functie zet variabelen ook om naar een factor, maar gebruikt de eerste observatie in de data als het eerste level.\n\nwordbank_datasets &lt;-\n  mutate(.data = wordbank_datasets,\n         language = as.factor(language))\n\nOm een snelle blik te werpen op hoe R de variabelen in onze datatabel ziet, kunnen we de functie str() voor structure gebruiken (het tidyverse-alternatief is glimpse()).44 De functie str() gebruikt types uit base R (dus bijv. num), terwijl glimpse() types uit het tidyverse gebruikt (dus &lt;dbl&gt;).\n\nstr(wordbank_datasets)\n\ntibble [89 × 8] (S3: tbl_df/tbl/data.frame)\n $ instrument_id    : num [1:89] 1 2 3 4 5 6 7 8 9 10 ...\n $ language         : Factor w/ 42 levels \"American Sign Language\",..: 3 4 6 6 8 8 10 10 17 17 ...\n $ form             : chr [1:89] \"WG\" \"WS\" \"WG\" \"WS\" ...\n $ form_type        : chr [1:89] \"WG\" \"WS\" \"WG\" \"WS\" ...\n $ age_min          : num [1:89] 8 16 8 16 8 16 8 16 8 16 ...\n $ age_max          : num [1:89] 36 30 16 30 20 36 18 30 16 30 ...\n $ has_grammar      : num [1:89] 0 0 0 0 0 1 0 1 0 1 ...\n $ unilemma_coverage: num [1:89] 0.95 0.95 1 1 1 0.93 1 1 1 0.99 ...\n\n\nWe zien dat language nu een factor is met 42 levels (zoveel talen als we hadden geteld) en het eerste level is American Sign Language, de naam die als eerste in het alfabet komt. Deze omzetting naar een factor zouden we ook moeten uitvoeren voor de andere variabelen van type character (form en form_type). Ook de variabele instrument_id komt hiervoor in aanmerking, want de getallen die hier zijn gebruikt als id voor de vragenlijst moeten we niet zien als getallen, maar als namen. Deze omzettingen kunnen we in een keer doen binnen de functie mutate() door de variabelen te scheiden met een komma. Voor de overzichtelijkheid van de code zetten we iedere omzetting op een eigen regel.\n\nwordbank_datasets &lt;-\n  mutate(.data = wordbank_datasets,\n         form = as.factor(form),\n         form_type = as.factor(form_type),\n         instrument_id = as.factor(instrument_id)\n         )\n\nstr(wordbank_datasets)\n\ntibble [89 × 8] (S3: tbl_df/tbl/data.frame)\n $ instrument_id    : Factor w/ 89 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10 ...\n $ language         : Factor w/ 42 levels \"American Sign Language\",..: 3 4 6 6 8 8 10 10 17 17 ...\n $ form             : Factor w/ 24 levels \"CDITwo\",\"FormA\",..: 17 22 17 22 17 22 17 22 17 22 ...\n $ form_type        : Factor w/ 2 levels \"WG\",\"WS\": 1 2 1 2 1 2 1 2 1 2 ...\n $ age_min          : num [1:89] 8 16 8 16 8 16 8 16 8 16 ...\n $ age_max          : num [1:89] 36 30 16 30 20 36 18 30 16 30 ...\n $ has_grammar      : num [1:89] 0 0 0 0 0 1 0 1 0 1 ...\n $ unilemma_coverage: num [1:89] 0.95 0.95 1 1 1 0.93 1 1 1 0.99 ...\n\n\nLet dus goed op: getallen zijn niet altijd getallen, maar kunnen ook als namen voor levels van een categorische variabele zijn gebruikt. Stel we maken een datatabel woordfrequenties aan met daarin de variabele frequentie van een aantal woorden. De woordfrequentie is door de onderzoeker gecodeerd als 1, 2 en 3 wat staat voor respectievelijk ‘laag frequent’, ‘midden frequent’ en ‘hoog frequent’.\n\nwoordfrequenties &lt;- tibble(frequentie = c(1,3,1,1,2))\n\nwoordfrequenties\n\n# A tibble: 5 × 1\n  frequentie\n       &lt;dbl&gt;\n1          1\n2          3\n3          1\n4          1\n5          2\n\n\nOmdat de waarden van de variabele frequentie getallen zijn, denkt R dat we hier te maken hebben met een numerieke variabele. We kunnen dit weer omzetten met de functie as.factor(), vervolgens kunnen we met de functie recode() de levels van deze factor expliciete namen geven. Wanneer we de datatabel nu weer bekijken dan zien we in plaats van getallen de namen van de levels. Dat maakt het inzichtelijker voor gebruikers van de data.\n\nwoordfrequenties &lt;- mutate(woordfrequenties,\n                           frequentie = as.factor(frequentie),\n                           frequentie = fct_recode(frequentie, \n                                                   laag = \"1\", \n                                                   midden = \"2\", \n                                                   hoog = \"3\")\n                           )\n\nwoordfrequenties\n\n# A tibble: 5 × 1\n  frequentie\n  &lt;fct&gt;     \n1 laag      \n2 hoog      \n3 laag      \n4 laag      \n5 midden    \n\n\nDe functie mutate() komen we nog vaak tegen. We kunnen deze bijvoorbeeld ook gebruiken om een nieuwe variabele aan te maken uit bestaande variabelen. Zo zouden we de variabele age_range kunnen aanmaken die het leeftijdsbereik uitdrukt als het verschil tussen de minimumleeftijd (age_min) en de maximumleeftijd (age_max):\n\nwordbank_datasets &lt;-\n  mutate(wordbank_datasets,\n         age_range = age_max - age_min)\n\nrelocate(.data = wordbank_datasets,\n         age_range,\n         .after = age_max)\n\n# A tibble: 89 × 9\n   instrument_id language  form  form_type age_min age_max age_range has_grammar\n   &lt;fct&gt;         &lt;fct&gt;     &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;\n 1 1             British … WG    WG              8      36        28           0\n 2 2             Cantonese WS    WS             16      30        14           0\n 3 3             Croatian  WG    WG              8      16         8           0\n 4 4             Croatian  WS    WS             16      30        14           0\n 5 5             Danish    WG    WG              8      20        12           0\n 6 6             Danish    WS    WS             16      36        20           1\n 7 7             English … WG    WG              8      18        10           0\n 8 8             English … WS    WS             16      30        14           1\n 9 9             French (… WG    WG              8      16         8           0\n10 10            French (… WS    WS             16      30        14           1\n# ℹ 79 more rows\n# ℹ 1 more variable: unilemma_coverage &lt;dbl&gt;\n\n\nWe maken hier met relocate() de nieuwe variabele zichtbaar direct achter de variabele age_max in de datatabel. Wanneer we dit niet doen dan zou deze achteraan komen."
  },
  {
    "objectID": "data.html#sec-voorbeeldscript",
    "href": "data.html#sec-voorbeeldscript",
    "title": "3  Data in R",
    "section": "3.3 Voorbeeldscript",
    "text": "3.3 Voorbeeldscript\nWanneer je begint met coderen is het vooral belangrijk dat je code werkt. Hoe je code precies tot het resultaat komt is nog van ondergeschikt belang. Het kan altijd eleganter of sneller. Toch is het verstandig om je vanaf het begin af aan een aantal zaken aan te leren die je code leesbaarder maken. Hier een aantal richtlijnen:\nGoede code gebruikt:\n\nduidelijke namen voor datatabellen en vectoren, waarbij we gebruik maken van snake_case (dus age_range en niet AgeRange);\nspaties om operatoren, zoals = en , (dus x = y en x, y i.p.v x=y en x,y);\nnieuwe regels om de lengte van code te beperken, bijvoorbeeld door na een , of &lt;- een return te geven;\ninspringing om aan te geven dat code op de huidige regel nog bij een vorige regel hoort en bijvoorbeeld argumenten van een functie op hetzelfde niveau te zetten.\n\nEen goed script:\n\nheeft een heldere opbouw met eerst het aanroepen van packages, dan het inlezen van de data, het bewerken van variabelen en dan de overige dingen die je gaat doen;\ngebruikt witregels om codeblokjes te maken van regels code die bij elkaar horen en deze te scheiden van andere code met een andere functie;\nheeft een goede toelichting op de werking van een blokje code, hierbij gebruik je # aan het begin van de regel. Je kunt # ook gebruiken om op een regel commentaar toe te voegen. R negeert alles wat na een # staat en probeert dit dus niet uit te voeren.\n\nHieronder een voorbeeldscript gebaseerd op de code uit dit hoofdstuk:\n\n# Aanroepen benodigde packages\nlibrary(tidyverse)\n\n# Bekijken dataset\nwordbank_datasets\n\n# Aanpassen type van variabelen\nwordbank_datasets &lt;-\n  mutate(.data = wordbank_datasets,\n         language = as.factor(language),\n         form = as.factor(form),\n         form_type = as.factor(form_type),\n         instrument_id = as.factor(instrument_id)\n         )\n\n# Aanmaken aparte vector met alle talen in de dataset\nlanguages &lt;- pull(wordbank_datasets, language)"
  },
  {
    "objectID": "data.html#omgaan-met-errors",
    "href": "data.html#omgaan-met-errors",
    "title": "3  Data in R",
    "section": "3.4 Omgaan met errors",
    "text": "3.4 Omgaan met errors\nR neemt alles wat je typt heel letterlijk. Je zult dus heel precies moeten werken, anders geeft R je een foutmelding. In onderstaand voorbeeld zijn we bijvoorbeeld de ‘s’ vergeten aan het eind van ‘dataset’. We vragen R dus om wordbank_dataset te laten zien, terwijl we wordbank_datasets bedoelen. Het is een klein verschil, maar voor R voldoende om een error te geven.\n\nwordbank_dataset\n\nError in eval(expr, envir, enclos): object 'wordbank_dataset' not found\n\n\nErrors horen bij coderen. Ze kunnen ontstaan door typefouten of door het verkeerd gebruik van de regels van de taal (bijv. het vergeten van een argument dat nodig is om een functie uit te kunnen voeren). Errors kunnen heel frustrerend zijn en soms ook veel tijd kosten om op te lossen. Probeer rustig te blijven, haal diep adem en probeer uit te vinden waar R over klaagt. Vaak zit er in de error-melding wel een aanwijzing wat er mis is. Wanneer R meldt ‘object nog found’ dan gaat het meestal of om een typefout in de naam van het object dat je wilt gebruiken of om een variabele in een datatabel, terwijl je R nog niet hebt verteld in een specifieke datatabel te zoeken.\nNaast errors geeft R ook waarschuwingen (warnings). De ernst daarvan is vaak wat moeilijker te bepalen. Soms kun je die voorbij laten gaan, maar soms moet je er ook echt iets mee. Ook voor warnings geldt dat het verstandig is om ze goed te bekijken, want vaak staat er een aanwijzing in. In onderstaand voorbeeld proberen we met de functie mean() het gemiddelde van te berekenen van een vector die niet uit getallen bestaat. De functie mean() vraagt echter om getallen. R wijst ons hierop in de warning en geeft ook aan wat het resultaat hiervan is: je krijgt ontbrekende data NAs (voor not available).\n\nmean(languages)\n\nWarning in mean.default(languages): argument is not numeric or logical:\nreturning NA\n\n\n[1] NA\n\n\nZoals gezegd, errors horen bij coderen. Je moet er simpelweg mee leren leven. Laat je niet gek maken en weet dat je niet alleen bent. De kans is groot dat iemand anders dezelfde error ook heeft gehad en er al een oplossing voor heeft gevonden. Stel dus vragen of kopieer je error-melding naar Google om uit te vinden wat het probleem nu eigenlijk is en welke oplossingen er bestaan. Websites als stackoverflow bieden vaak hulp."
  },
  {
    "objectID": "data.html#verder-leren",
    "href": "data.html#verder-leren",
    "title": "3  Data in R",
    "section": "Verder leren",
    "text": "Verder leren\n\nIn Hoofdstuk 1 van SfL (Winter, 2019) wordt de basis van R (base R) verder uitgelegd. Ter voorbereiding op het eerste practicum is het prettig om vast wat commando’s te proberen uit dit hoofdstuk. Werk verder in het script dat je in het vorige hoofdstuk hebt aangemaakt.5 Werk nu hoofdstuk 1 door t/m sectie 1.8. Typ de commando’s in de grijze vakken over en voer ze uit. In sectie 1.2 doe je dit direct in de R-console, vanaf sectie 1.3 (en in alle volgende practica!) in een script. Zie sectie 1.15 voor handige shortcuts die je hierbij kunt gebruiken. Controleer steeds weer of je dezelfde output krijgt als in het boek.\n\n\nWinter, B. (2019). Statistics for Linguists: An Introduction Using R. Routledge. https://doi.org/10.4324/9781315165547\n5 Je kunt eventueel ook https://rdrr.io/snippets gebruiken voor het uitvoeren van R-code, mocht de installatie op je eigen computer niet werken. We kunnen dan tijdens een practicum proberen R en RStudio werkend te krijgen op je computer.Nu zou je in staat moeten zijn Practicum 1 te maken."
  },
  {
    "objectID": "_practica/practicum1.html",
    "href": "_practica/practicum1.html",
    "title": "Practicum 1",
    "section": "",
    "text": "Werken met data in R\nNu we de data beschikbaar hebben als datatabel in R, kunnen we ons gaan richten op de inhoud: hoe zien de data er precies uit?\nSoms worden variabelen door R niet herkend als het juiste type, of soms ontbreekt er informatie of wil je zelf nieuwe variabelen toevoegen. Gelukkig heb je de mogelijkheid om deze informatie in R aan te passen of toe te voegen. Let wel op dat dit goed gaat, want anders kun je bij latere analyses in de problemen komen."
  },
  {
    "objectID": "_practica/practicum1.html#leerdoelen",
    "href": "_practica/practicum1.html#leerdoelen",
    "title": "Practicum 1",
    "section": "Leerdoelen",
    "text": "Leerdoelen\n\nKennismaken met (data in) R\nInlezen van databestanden voor bewerking in R\nBewerken van variabelen in R"
  },
  {
    "objectID": "_practica/practicum1.html#voorbereiding",
    "href": "_practica/practicum1.html#voorbereiding",
    "title": "Practicum 1",
    "section": "Voorbereiding",
    "text": "Voorbereiding\nLees hoofdstukken 1 t/m 3 uit het dictaat. De benodigde R-functies zijn te vinden in het dictaat. Functies die niet in het dictaat besproken worden, worden gegeven in de opdracht. Lees ook de algemene richtlijnen voor practica door."
  },
  {
    "objectID": "_practica/practicum1.html#introductie",
    "href": "_practica/practicum1.html#introductie",
    "title": "Practicum 1",
    "section": "Introductie",
    "text": "Introductie\nEen taalwetenschapper wil weten of training met een computerprogramma helpt bij het leren van vaste uitdrukkingen door tweedetaalleerders van het Nederlands ten opzichte van een klassikale methode. Het voordeel van het computerprogramma is dat deelnemers gedetailleerde feedback krijgen, terwijl dit klassikaal een stuk moeilijker is. De onderzoeker verwacht daarom dat mensen die met het computerprogramma oefenen meer Nederlandse uitdrukkingen kennen, dan mensen die hebben gewerkt via een klassikale methode.\nOm dit te onderzoeken werden Duitse leerders van het Nederlands onderworpen aan een voormeting (pre-test) om hun kennis van Nederlandse uitdrukkingen te testen. Vervolgens werd de groep participanten in tweeën verdeeld. Groep 1 mocht oefenen met het computerprogramma, terwijl groep 2 klassikaal ging oefenen met uitdrukkingen. Na een week van oefenen werden de deelnemers opnieuw getest op hun kennis van uitdrukkingen. In deze practicumopdracht ga je werken met de data van deze onderzoeker.\n\n\n\n\n\n\nLet op\n\n\n\nSla je script regelmatig op, zodat je geen code kwijtraakt. Klik hiervoor op het floppy-disk-symbool of gebruik de sneltoetsen Ctrl + S/cmd + S.\n\n\n\n\n\n\n\n\nProbeer het eerst zelf!\n\n\n\nBij de opdrachten vind je naast een beschrijving van de vraag ook een Hint en de Code. Dit om je te helpen als je even niet verder komt. Hoe verleidelijk het ook is om meteen naar het antwoord te gaan, doe dit niet. Houd je aan de volgorde: probeer het eerst zelf, lukt dat niet gebruik de hint, mocht je dan nog vastzitten en er echt niet uitkomen ga dan pas naar het antwoord. Dit gaat je op de lange termijn ontzettend helpen."
  },
  {
    "objectID": "_practica/practicum1.html#eerste-zes-rijen-zichtbaar-maken",
    "href": "_practica/practicum1.html#eerste-zes-rijen-zichtbaar-maken",
    "title": "Practicum 1",
    "section": "Eerste zes rijen zichtbaar maken",
    "text": "Eerste zes rijen zichtbaar maken\n\nOpdrachtHintCode\n\n\nMaak de eerste zes rijen van het databestand zichtbaar om te kijken hoe de data eruitzien.\n\n\nGebruik de functie head(), zie sectie 3.2.1.\n\n\n\n# Eerste zes rijen zichtbaar maken\n head(uitdrukkingen)\n\n# A tibble: 6 × 6\n  Proefpersoon Geslacht Groep Geboortejaar PercentageCorrect_Voormeting\n         &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt;        &lt;dbl&gt;                        &lt;dbl&gt;\n1            1 M            1         1988                           20\n2            2 V            2         1992                           36\n3            3 M            1         1995                           15\n4            4 M            2         1997                           55\n5            5 V            1         1987                           43\n6            6 V            2         1999                           11\n# ℹ 1 more variable: PercentageCorrect_Nameting &lt;dbl&gt;"
  },
  {
    "objectID": "_practica/practicum1.html#aantal-rijen-en-kolommen",
    "href": "_practica/practicum1.html#aantal-rijen-en-kolommen",
    "title": "Practicum 1",
    "section": "Aantal rijen en kolommen",
    "text": "Aantal rijen en kolommen\n\nOpdrachtHintCode\n\n\nHoeveel rijen (observaties) en kolommen (variabelen) telt de dataset? Gebruik hiervoor de relevante R-functies\n\n\nGebruik de functies nrow() en ncol(), zie sectie 3.1.\n\n\n\n# Aantal rijen en kolommen vaststellen\n ncol(uitdrukkingen)\n\n[1] 6\n\n nrow(uitdrukkingen)\n\n[1] 10"
  },
  {
    "objectID": "_practica/practicum1.html#de-functie-view",
    "href": "_practica/practicum1.html#de-functie-view",
    "title": "Practicum 1",
    "section": "De functie View()",
    "text": "De functie View()\n\nOpdrachtCode\n\n\nEen andere manier om de dataset zichtbaar te maken is via de functie View().Deze functie is echter alleen te gebruiken in RStudio. Maak de dataset zichtbaar met deze functie.\n\n\n\n#Dataset zichtbaar maken\n  #View(uitdrukkingen)"
  },
  {
    "objectID": "_practica/practicum1.html#namen-van-de-variabelen",
    "href": "_practica/practicum1.html#namen-van-de-variabelen",
    "title": "Practicum 1",
    "section": "Namen van de variabelen",
    "text": "Namen van de variabelen\n\nOpdrachtHintAntwoord\n\n\nDe namen van de variabelen in de aangeleverde dataset voldoen niet aan onze richtlijnen. Wat is het probleem?\n\n\nZie Secties 3.2.1.\n\n\nDe namen maken geen gebruik van snake_case. Er worden hoofdletters gebruikt en soms worden inhoudswoorden aan elkaar geschreven.\n\n\n\n\nOpdrachtHintCode\n\n\nPas de namen van de variabelen de datatabel aan zodat ze voldoen aan onze richtlijnen.\n\n\nJe kunt dit handmatig doen met de functie rename() of met de functie clean_names() uit het package janitor. Zie Sectie 3.2.1.\n\n\n\n# Aanpassen namen variabelen\nuitdrukkingen &lt;- janitor::clean_names(uitdrukkingen)\n\n\n# alternatief handmatig\nuitdrukkingen &lt;- rename(.data = uitdrukkingen,\n                        proefpersoon = Proefpersoon,\n                        geslacht = Geslacht,\n                        groep = Groep,\n                        geboortejaar = Geboortejaar,\n                        percentage_correct_voormeting = PercentageCorrect_Voormeting,\n                        percentage_correct_nameting = PercentageCorrect_Nameting\n                        )"
  },
  {
    "objectID": "_practica/practicum1.html#meetniveaus-van-de-variabelen",
    "href": "_practica/practicum1.html#meetniveaus-van-de-variabelen",
    "title": "Practicum 1",
    "section": "Meetniveaus van de variabelen",
    "text": "Meetniveaus van de variabelen\n\nOpdracht\n\n\nBeschrijf de meetniveaus van alle variabelen in het databestand en geef kort aan waarom je voor de betreffende meetniveaus gekozen hebt."
  },
  {
    "objectID": "_practica/practicum1.html#details-van-variabelen-opvragen",
    "href": "_practica/practicum1.html#details-van-variabelen-opvragen",
    "title": "Practicum 1",
    "section": "Details van variabelen opvragen",
    "text": "Details van variabelen opvragen\n\nOpdrachtHintCode\n\n\nGebruik de functie str() om de details van de variabelen in het databestand op te vragen. Op deze manier kun je zien van welk type de variabelen volgens R zijn. Kloppen deze door R toegekende typen met de meetniveaus uit de vorige vraag?\n\n\nZie Tabel 3.1. Zie ook secties 1.5-1.9 uit SfL voor de verschillende type variabelen in R.\n\n\n\n# Details variabelen opvragen\n str(uitdrukkingen)\n\nspc_tbl_ [10 × 6] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ proefpersoon                 : num [1:10] 1 2 3 4 5 6 7 8 9 10\n $ geslacht                     : chr [1:10] \"M\" \"V\" \"M\" \"M\" ...\n $ groep                        : num [1:10] 1 2 1 2 1 2 1 2 1 2\n $ geboortejaar                 : num [1:10] 1988 1992 1995 1997 1987 ...\n $ percentage_correct_voormeting: num [1:10] 20 36 15 55 43 11 18 29 25 33\n $ percentage_correct_nameting  : num [1:10] 60 46 88 75 81 55 69 45 83 78\n - attr(*, \"spec\")=\n  .. cols(\n  ..   Proefpersoon = col_double(),\n  ..   Geslacht = col_character(),\n  ..   Groep = col_double(),\n  ..   Geboortejaar = col_double(),\n  ..   PercentageCorrect_Voormeting = col_double(),\n  ..   PercentageCorrect_Nameting = col_double()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt;"
  },
  {
    "objectID": "_practica/practicum1.html#aanpassen-van-het-type-van-een-variabele",
    "href": "_practica/practicum1.html#aanpassen-van-het-type-van-een-variabele",
    "title": "Practicum 1",
    "section": "Aanpassen van het type van een variabele",
    "text": "Aanpassen van het type van een variabele\n\nOpdrachtHintCode\n\n\nVerander de variabele proefpersoon in een factor, zodat het door R als een categoriale variabele herkend wordt. Doe hetzelfde voor de variabelen groep en geslacht.\n\n\nGebruik de functie mutate() in combinatie met as.factor(), zie sectie 3.2.2.\n\n\n\n# Aanpassen datatype variabelen\nuitdrukkingen &lt;- mutate(\n  .data = uitdrukkingen,\n  proefpersoon = as.factor(proefpersoon),\n  groep = as.factor(groep),\n  geslacht = as.factor(geslacht)\n)\n      \n# Controleren\nstr(uitdrukkingen)\n\ntibble [10 × 6] (S3: tbl_df/tbl/data.frame)\n $ proefpersoon                 : Factor w/ 10 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10\n $ geslacht                     : Factor w/ 2 levels \"M\",\"V\": 1 2 1 1 2 2 2 2 1 2\n $ groep                        : Factor w/ 2 levels \"1\",\"2\": 1 2 1 2 1 2 1 2 1 2\n $ geboortejaar                 : num [1:10] 1988 1992 1995 1997 1987 ...\n $ percentage_correct_voormeting: num [1:10] 20 36 15 55 43 11 18 29 25 33\n $ percentage_correct_nameting  : num [1:10] 60 46 88 75 81 55 69 45 83 78"
  },
  {
    "objectID": "_practica/practicum1.html#toevoegen-namen-van-levels",
    "href": "_practica/practicum1.html#toevoegen-namen-van-levels",
    "title": "Practicum 1",
    "section": "Toevoegen namen van levels",
    "text": "Toevoegen namen van levels\n\nOpdrachtHintCode\n\n\nVoeg nu de bijbehorende namen van de levels aan de variabele groep toe: computer en klassikaal.\n\n\nGebruik de functie fct_recode(), zie Sectie 3.2.2.\n\n\n\n# Toevoegen van namen aan levels\nuitdrukkingen &lt;- mutate(uitdrukkingen,\n                        groep = fct_recode(groep,\n                                           computer = \"1\",\n                                           klassikaal = \"2\"\n                                           )\n                        )\n\n# Controleren\nstr(uitdrukkingen)\n\ntibble [10 × 6] (S3: tbl_df/tbl/data.frame)\n $ proefpersoon                 : Factor w/ 10 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10\n $ geslacht                     : Factor w/ 2 levels \"M\",\"V\": 1 2 1 1 2 2 2 2 1 2\n $ groep                        : Factor w/ 2 levels \"computer\",\"klassikaal\": 1 2 1 2 1 2 1 2 1 2\n $ geboortejaar                 : num [1:10] 1988 1992 1995 1997 1987 ...\n $ percentage_correct_voormeting: num [1:10] 20 36 15 55 43 11 18 29 25 33\n $ percentage_correct_nameting  : num [1:10] 60 46 88 75 81 55 69 45 83 78"
  },
  {
    "objectID": "_practica/practicum1.html#nieuwe-variabele-proportie_correct_voormeting-toevoegen",
    "href": "_practica/practicum1.html#nieuwe-variabele-proportie_correct_voormeting-toevoegen",
    "title": "Practicum 1",
    "section": "Nieuwe variabele proportie_correct_voormeting toevoegen",
    "text": "Nieuwe variabele proportie_correct_voormeting toevoegen\n\nOpdrachtHintCode\n\n\nDe variabele percentage_correct_voormeting geeft het aantal goede antwoorden op de voormeting weer als een percentage. Maak een nieuwe variabele proportie_correct_coormeting waarin het aantal goede antwoorden wordt weergegeven als een proportie. Wat is volgens R het type van deze nieuwe variabele? Leg uit waarom R voor dit type kiest.\n\n\nZowel percentage als proportie geven het deel van een geheel weer. Het verschil is dat een percentage loopt van 0-100 en een proportie van 0-1. Voor het aanmaken van nieuwe variabelen gebruiken we de functie mutate(), zie Sectie 3.2.2.\n\n\n\n# Toevoegen variabele met proportie\nuitdrukkingen &lt;- mutate(uitdrukkingen,\n                       proportie_correct_voormeting = percentage_correct_voormeting/100\n                       )\n\n# Controleren type van de variabele\nstr(uitdrukkingen)\n\ntibble [10 × 7] (S3: tbl_df/tbl/data.frame)\n $ proefpersoon                 : Factor w/ 10 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10\n $ geslacht                     : Factor w/ 2 levels \"M\",\"V\": 1 2 1 1 2 2 2 2 1 2\n $ groep                        : Factor w/ 2 levels \"computer\",\"klassikaal\": 1 2 1 2 1 2 1 2 1 2\n $ geboortejaar                 : num [1:10] 1988 1992 1995 1997 1987 ...\n $ percentage_correct_voormeting: num [1:10] 20 36 15 55 43 11 18 29 25 33\n $ percentage_correct_nameting  : num [1:10] 60 46 88 75 81 55 69 45 83 78\n $ proportie_correct_voormeting : num [1:10] 0.2 0.36 0.15 0.55 0.43 0.11 0.18 0.29 0.25 0.33"
  },
  {
    "objectID": "_practica/practicum1.html#nieuwe-variabele-verschil_metingen-toevoegen",
    "href": "_practica/practicum1.html#nieuwe-variabele-verschil_metingen-toevoegen",
    "title": "Practicum 1",
    "section": "Nieuwe variabele verschil_metingen toevoegen",
    "text": "Nieuwe variabele verschil_metingen toevoegen\n\nOpdrachtHintCode\n\n\nMaak nu een nieuwe variabele in het databestand met de naam verschil_metingen. Deze variabele moet het verschil weergeven tussen de nameting en de voormeting.\n\n\nOok hierbij kun je de functie mutate() gebruiken, zie Sectie 3.2.2.\n\n\n\n# Variabele verschil_metingen aanmaken\nuitdrukkingen &lt;- mutate(uitdrukkingen,\n                       verschil_metingen = percentage_correct_nameting - percentage_correct_voormeting\n                       )"
  },
  {
    "objectID": "_practica/practicum1.html#nieuwe-variabele-leeftijd-toevoegen",
    "href": "_practica/practicum1.html#nieuwe-variabele-leeftijd-toevoegen",
    "title": "Practicum 1",
    "section": "Nieuwe variabele leeftijd toevoegen",
    "text": "Nieuwe variabele leeftijd toevoegen\n\nOpdrachtHintCode\n\n\nEen van de variabelen in het databestand is geboortejaar. Voeg een nieuwe variabele leeftijd toe aan het databestand. Het experiment is afgenomen in 2017. Bereken automatisch de leeftijd op basis van het geboortejaar van de participanten met behulp van R.\n\n\nEn ook dit kan met de functie mutate(), zie Sectie 3.2.2.\n\n\n\n# Toevoegen variabele leeftijd\n uitdrukkingen &lt;- mutate(uitdrukkingen,\n                         leeftijd = 2017 - geboortejaar\n                         )"
  },
  {
    "objectID": "_practica/practicum1.html#een-grafiek-maken",
    "href": "_practica/practicum1.html#een-grafiek-maken",
    "title": "Practicum 1",
    "section": "Een grafiek maken",
    "text": "Een grafiek maken\nLaten we de functionaliteit van het tidyverse meteen ook maar gebruiken om een grafiek te maken. We maken een grafiek waarin we het percentage correct op de nameting uitzetten tegen dat van de voormeting en we geven elk datapunt een kleur afhankelijk van de groep waartoe deze behoort. We gebruiken hiervoor ggplot2, het populairste onderdeel van tidyverse waar je in de rest van de cursus nog veel over gaat leren (vanaf Hoofdstuk 5).\n\nOpdrachtHintCode\n\n\nHieronder vind je een deel van de code om de grafiek te maken, alleen de variabelen ontbreken nog. Kopieer onderstaande code, voeg de variabelen op de juiste puntjes (…) in en voer de code uit. Bekijk het resultaat: zie je verschil tussen de twee groepen?\n\n#deel van de code voor een grafiek waarin percentage_correct_nameting wordt uitgezet tegen percentage_correct_voormeting\n\nuitdrukkingen %&gt;% \n  ggplot(aes(x = ..., \n             y = ..., \n             colour = ...)) +\n  geom_point(size = 3) +\n  theme_minimal(13)\n\n\n\nIn deze grafiek zetten we variabele Y uit tegen variabele X. De kleur willen we laten variëren per groep waartoe de leerder behoort.\n\n\n\n#code voor een grafiek waarin percentage_correct_nameting wordt uitgezet tegen percentage_correct_voormeting\n\nuitdrukkingen %&gt;% \n  ggplot(aes(x = percentage_correct_voormeting, \n             y = percentage_correct_nameting, \n             colour = groep)) +\n  geom_point(size = 3) +\n  theme_minimal(16)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Onderzoeksontwerp en Beschrijvende Statistiek",
    "section": "",
    "text": "Welkom\nDit is het dictaat bij de B1-cursus Onderzoeksontwerp en Beschrijvende Statistiek. Dit document geeft een beknopte inleiding in het werken met R en RStudio aan de hand van taalkundige voorbeelden. Aan het eind van elk hoofdstuk vind je onder het kopje Verder leren informatie waar je je kennis verder kunt verdiepen. De practica bij de cursus vind je onder het kopje Practica in de menubalk links."
  },
  {
    "objectID": "index.html#suggesties-voor-verbeteringen",
    "href": "index.html#suggesties-voor-verbeteringen",
    "title": "Onderzoeksontwerp en Beschrijvende Statistiek",
    "section": "Suggesties voor verbeteringen",
    "text": "Suggesties voor verbeteringen\nDit document is in ontwikkeling. Nog niet alle hoofdstukken in het linkermenu zijn op dit moment beschikbaar. Deze zullen gedurende de cursus worden toegevoegd net als de practica. Kom je dingen tegen die niet werken, niet kloppen of die onduidelijk zijn of heb je andere suggesties voor verbeteringen, laat het weten. Dit kan via het forum op Brightspace of direct bij de docent tijdens de practicumuren. Op deze manier zorgen we samen dat dit document een steeds beter leermiddel wordt."
  },
  {
    "objectID": "index.html#verantwoording",
    "href": "index.html#verantwoording",
    "title": "Onderzoeksontwerp en Beschrijvende Statistiek",
    "section": "Verantwoording",
    "text": "Verantwoording\nHet materiaal in dit dictaat is beïnvloed door een groot aantal inspiratiebronnen die ik door de afgelopen jaren heb bestudeerd. Het is niet altijd eenduidig aan te wijzen waar uitleg of voorbeelden op gebaseerd zijn, daarom hieronder een alfabetische lijst van de meest inspirerende bronnen."
  },
  {
    "objectID": "intro.html#hoe-dit-dictaat-te-gebruiken",
    "href": "intro.html#hoe-dit-dictaat-te-gebruiken",
    "title": "1  Inleiding",
    "section": "1.1 Hoe dit dictaat te gebruiken",
    "text": "1.1 Hoe dit dictaat te gebruiken\nWaarschijnlijk is het werken met een programmeertaal nieuw voor je. Dat is helemaal geen probleem. We beginnen vanaf het begin en veronderstellen geen voorkennis op dit gebied. Voor sommigen zal het leren programmeren (of beter gezegd coderen) soepel verlopen, maar misschien ben je wel iemand die er meer moeite mee heeft. Daar hoef je je geen zorgen over te maken. De leercurve kan best steil zijn. Vergelijk het met het leren van een nieuwe taal. Dat kost nu eenmaal wat tijd en kan lastig zijn. Het is belangrijk dat je hierbij actief met de stof aan de gang gaat. Maak voor jezelf een overzicht van het leermateriaal. Laat je niet te snel uit het veld slaan en stel vragen.\nAls je fit wilt worden, dan moet je zelf aan de slag in de sportschool of op het sportveld. Voor coderen geldt hetzelfde. Als je wilt leren coderen, moet je zelf aan de slag. Het alleen doorlezen van dit dictaat is hierbij niet voldoende. Probeer voorbeeldcode te ontcijferen, zodat je snapt wat elk onderdeel doet. Het helpt daarbij om de code zelf uit te voeren in R. Op die manier kun je precies zien wat er gebeurt in elke stap. Alle bestanden die in het dictaat gebruikt worden, kun je downloaden vanaf de Brightspace-pagina van deze cursus. Je kunt alle analyses dus op je eigen computer nadoen. Download hiervoor het bestand OBS_practica.zip van Brightspace en pak dat uit op je eigen computer. Zet deze map op een handige locatie op je computer (bijv. in de map voor de cursus OBS). In het volgende hoofdstuk leer je hoe je aan de slag kunt met de bestanden in deze map.\nDit dictaat biedt slechts een inleiding. Er is veel meer te leren en vertellen over R. Aan het eind van elk hoofdstuk vind je onder het kopje Verder leren informatie waar je meer je meer achtergrondkennis kunt opdoen of je kennis verder kunt verdiepen. Maak daar gebruik van. De leerdoelen aan het begin van ieder hoofdstuk kun je gebruiken om voor jezelf vast te stellen of je de stof uit het hoofdstuk voldoende onder de knie hebt."
  },
  {
    "objectID": "intro.html#generatieve-ai",
    "href": "intro.html#generatieve-ai",
    "title": "1  Inleiding",
    "section": "1.2 Generatieve AI",
    "text": "1.2 Generatieve AI\nGeneratieve AI biedt allerlei mogelijkheden. Het genereren van code is er daar een van. Het probleem is alleen dat je de gegenereerde code alleen kunt begrijpen als je zelf al iets weet over coderen. Dit noemen we ook wel de expert-paradox: je hebt (basis)kennis nodig om generatieve AI goed te kunnen gebruiken. En dan nog: ervaren coders geven aan dat wanneer je nieuwe problemen wilt analyseren generatieve AI je niet zoveel te bieden heeft. Des te meer reden dus om zelf kennis op te doen. Bovendien is het natuurlijk ook veel leuker en interessanter als je aan het eind van je opleiding naar eerlijkheid kunt zeggen dat je daadwerkelijk iets geleerd hebt en daadwerkelijk zelf iets kunt. We maken in deze cursus dus geen gebruik van generatieve AI. Misschien dat je later met de opgedane kennis ervan kunt profiteren, maar op dit moment doen we alles op eigen kracht."
  },
  {
    "objectID": "R.html#sec-RStudio",
    "href": "R.html#sec-RStudio",
    "title": "2  R en RStudio",
    "section": "2.1 Werken met R en RStudio",
    "text": "2.1 Werken met R en RStudio\nHet softwarepakket R is tegenwoordig de standaard voor data-analyse in taalkundig onderzoek. Het grote voordeel van R is dat veel professionele onderzoekers steeds weer nieuwe pakketten maken voor specifieke statistische of data-analytische functies.1 Daarnaast is het gratis te downloaden voor verschillende computerplatforms. Je kunt R downloaden als programma op je computer. Je kunt direct in het programma R werken. Als je het opent, krijg je een scherm te zien, de console, waarin je code kunt typen. Wij gebruiken echter het programma RStudio, dat een wat fijnere gebruikersinterface levert dan R zelf, en dus wat vriendelijker is voor (beginnende) gebruikers.1 Bodo Winter geeft in sectie 0.2 van Winter (2019) nog een aantal belangrijke voordelen.\nWinter, B. (2019). Statistics for Linguists: An Introduction Using R. Routledge. https://doi.org/10.4324/9781315165547\n\nOp de computers in het ESC horen R en RStudio al aanwezig te zijn. Om het op je eigen computer te installeren: ga naar https://posit.co/download/rstudio-desktop/#download en kies het installatieprogramma dat bij jouw computer past. Als je R nog niet hebt, installeer dat dan ook, vanaf die pagina of anders via https://cran.rstudio.com of http://cran.r-project.org.\nWanneer je RStudio opent, opent zich een programma met een aantal vensters (3 of 4), zoals je kunt zien in Figuur 2.1. Linksonder vind je de console van R (wanneer je vanuit het programma R zou werken, krijg je alleen dit venster te zien). Dat is waar alle code die je gaat maken zal worden uitgevoerd. Linksboven zie je een script met daarin 1 regel code. In het script kun je als in een kladblok code schrijven en die vervolgens uitproberen door deze naar de console te sturen. Dit doe je door de relevante code te selecteren en op ctrl + Enter (Cmd + Enter op een Mac) te drukken. Wanneer je je cursor op een regel hebt staan, wordt op deze manier alle code op die regel (en bijbehorende regels) uitgevoerd.\n\n\n\nFiguur 2.1: De vensters van het programma RStudio\n\n\nHet venster rechtsboven geeft een overzicht van alle data (datatabellen en vectoren, zie het volgende hoofdstuk) die voor R beschikbaar zijn om bewerkingen op uit te voeren. Dit venster is nu nog leeg. Hetzelfde geldt voor het venster rechtsonder. Dit venster kun je gebruiken om gemaakte grafieken (plots) te bekijken, inzicht te krijgen in je bestanden en ook de packages die je hebt geïnstalleerd (zie hieronder). Niet onbelangrijk: hier vind je ook de help-functie.\nOmdat het waarschijnlijker makkelijker is om een overzicht te krijgen van RStudio met bewegend beeld kun je deze video https://youtu.be/FIrsOBy5k58 bekijken voor een korte rondleiding."
  },
  {
    "objectID": "R.html#functies",
    "href": "R.html#functies",
    "title": "2  R en RStudio",
    "section": "2.2 Functies",
    "text": "2.2 Functies\nZoals gezegd is R in feite een grote verzameling functies die je kunt inzetten om data te analyseren. Functies koppelen een bepaalde input aan een bepaalde output. Neem bijvoorbeeld de functie seq(): gegeven een beginpunt, een eindpunt en een stapgrootte geeft deze functie je een reeks getallen. In onderstaand voorbeeld is het beginpunt gegeven als 1, het eindpunt als 10 en de stapgrootte als 1. Het resultaat is een reeks gehele getallen van 1 tot 10.\n\nseq(from = 1, to = 10, by = 1)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWanneer we de stapgrootte veranderen naar 2, krijgen we niet 10 getallen maar 5 (alle oneven getallen onder de 10).\n\nseq(from = 1, to = 10, by = 2)\n\n[1] 1 3 5 7 9\n\n\nVeranderen we vervolgens ook het beginpunt naar 2 dan krijgen we 5 even getallen:\n\nseq(from = 2, to = 10, by = 2)\n\n[1]  2  4  6  8 10\n\n\nDeze voorbeelden laten zien dat de uitkomst (output) van de functie dus volledig wordt bepaald door wat je erin stopt (de input). De functie seq() vraag om drie argumenten from, to en by. Ieder argument heeft in principe een vaste plek in de functie. Wanneer we die vaste volgorde aanhouden kunnen we de namen van de argumenten weglaten:\n\nseq(1, 10, 1)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nWanneer je bekend raakt met bepaalde functies, zul je er op gegeven moment waarschijnlijk voor kiezen om de namen van de argumenten weg te laten. Dit scheelt namelijk veel typewerk. Het maakt je code mogelijk wel minder leesbaar voor buitenstaanders (en voor jezelf). In dit dictaat zullen we in de meeste gevallen bij het eerste gebruik van een functie de argumenten bij naam noemen, om ze bij vervolgd gebruik weg te laten.\nWanneer we de namen wel gebruiken, kunnen we er ook voor kiezen om de argumenten in een andere volgorde neer te zetten. Door de namen weet R toch wat we bedoelen.\n\nseq(by = 1, from = 1, to = 10)\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\n\nLaten we de namen weg en gebruiken we een andere volgorde, krijgen we een andere output:\n\nseq(1, 1, 10)\n\n[1] 1\n\n\nIn dit geval interpreteert R de argumenten in de standaardvolgorde.\nHet is voor elke functie dus belangrijk om te weten wat de benodigde argumenten zijn en in welke volgorde ze worden verwacht. De argumenten staan altijd tussen () achter de functienaam en worden gescheiden door een komma. Tussen de naam van het argument en de waarde die je wilt meegeven zet je een =-teken.\n\nDe anatomie van een functie\n\n\nfunctienaam(argument1, argument2, argument3)\n\n\n\n\nseq(from = , to = , by = )\n\n\n\nWanneer je wilt achterhalen hoe de structuur van een functie in elkaar zit, kun je de help-functie in R gebruiken. Door een vraagteken voor de functienaam te zetten, verschijnt in RStudio rechtsonder informatie over de functie.\n\n?seq()\n\nJe zult zien dat veel functies naast de verplichte argumenten ook default argumenten hebben. Dit zijn argumenten die een standaardwaarde hebben en dus niet door de gebruiker hoeven te worden gegeven, maar die je eventueel wel zou kunnen aanpassen.\nNiet alle functies hebben argumenten met een naam. De functie c() waarmee we dingen kunnen samenvoegen tot een geheel is bijvoorbeeld een veelgebruikte functie zonder argumentnamen:\n\nc(\"Nederland\", 1988, \"plek 1\")\n\n[1] \"Nederland\" \"1988\"      \"plek 1\"   \n\n\nDeze functie c() kun je ook gebruiken om meerdere waarden als argument van een functie mee te geven. Neem als voorbeeld de functie round(). Deze functie rondt getallen af op een aangegeven aantal decimalen (digits). In onderstaand voorbeeld wordt er afgerond op twee decimalen:\n\nround(4.246, digits = 2)\n\n[1] 4.25\n\n\nMet c() is het mogelijk om meerdere getallen tegelijk te laten afronden (in dit geval op 1 decimaal):\n\nround(c(4.246, 5.628, 9.463), 1)\n\n[1] 4.2 5.6 9.5\n\n\n\n\n\n\n\n\ncodeboek\n\n\n\nIn deze cursus leer je werken met zo’n 100 veelgebruikte functies in R. Het is belangrijk om voor jezelf een goed overzicht te houden van deze functies. Werk hier actief aan door een eigen codeboek aan te maken."
  },
  {
    "objectID": "R.html#sec-packages",
    "href": "R.html#sec-packages",
    "title": "2  R en RStudio",
    "section": "2.3 Packages",
    "text": "2.3 Packages\nR komt standaard met een hele verzameling aan functies die je kunt gebruiken. Dit noemen we ook wel base R. Soms wil je echter meer. In dat geval kun je gebruik maken van zogenaamde aanvullende packages. Een package is een verzameling functies die meestal gemaakt zijn om één bepaalde taak goed uit te kunnen voeren, bijv. het maken van grafieken of het analyseren van teksten. Om deze te kunnen gebruiken moet je deze packages eerst installeren op je computer en vervolgens ook aanroepen in je R-sessie. Tijdens deze cursus zullen we veelvuldig gebruik maken van het package tidyverse. Dat is eigenlijk een verzameling packages die helpen bij verschillende onderdelen van data-analyse. Het tidyverse is inmiddels zo succesvol geworden dat het een soort dialect binnen de programmeertaal R is geworden. Wanneer je het package tidyverse installeert en aanroept dan roep je meteen alle packages die daaronder vallen ook aan.\nPackages installeer je met behulp van de functie install.packages(). Tussen de haken zet je de naam van het package tussen aanhalingstekens.\n\ninstall.packages(\"tidyverse\") \n\nN.B. je hoeft een package maar één keer op je computer te installeren. Zet daarom, nadat je de installatie hebt voltooid, een # voor de regel met install.packages() of verwijder de regel met deze code. Als je de regel laat staan kan dat later problemen opleveren. Door de # zal R de regel negeren wanneer je het script nog een keer uitvoert. In RStudio kun je in het window rechtsonder onder het tabblad packages zien welke packages er geïnstalleerd zijn op jouw computer. Je vindt daar ook een optie om packages te installeren.\nEen package installeer je dus maar één keer, maar om de functies in het package te kunnen gebruiken moet je het package wel elke R-sessie opnieuw activeren. Dit doe je met behulp van de functie library() waarin je de naam van het te gebruiken package invult zonder aanhalingstekens. Dit moet je dus elke keer uitvoeren aan het begin van een nieuwe R-sessie, anders zal R klagen de functies uit het package niet te kennen. Om de functies uit het tidyverse te kunnen gebruiken, type je dus:\n\nlibrary(tidyverse)\n\nJe kunt deze functie voor meerdere packages achter elkaar uitvoeren. Let hierbij wel op dat de volgorde waarin je de packages aanroept een effect kan hebben. Wanneer er in verschillende packages een functie met dezelfde naam zit, dan zal de R de functie gebruiken zoals die in het laatst aangeroepen package gedefinieerd is. De functie in het eerder aangeroepen package zal dan gemaskeerd worden. R geeft je hier ook een waarschuwing over. Wanneer je uit een geïnstalleerd package maar één specifieke functie wilt gebruiken, dan kun je dit probleem omzeilen door het package niet aan te roepen met library(), maar door de notatie packagenaam::functienaam te gebruiken:\n\njanitor::clean_names()\n\nIn het bovenstaande voorbeeld kun je de functie clean_names uit het package janitor gebruiken zonder dat alle andere functies uit het package actief worden en mogelijk functies uit andere packages maskeren. Je moet het package hiervoor natuurlijk wel geïnstalleerd hebben op je computer.\nHet is verstandig om aan het begin van elk R-script een blokje te maken waarin je alle benodigde packages aanroept met library(). Dit is vooral ook handig voor lezers van je script. Die weten dan meteen wat ze kunnen verwachten en welke packages ze eventueel nog moeten installeren."
  },
  {
    "objectID": "R.html#verder-leren",
    "href": "R.html#verder-leren",
    "title": "2  R en RStudio",
    "section": "Verder leren",
    "text": "Verder leren\n\nIn Hoofdstuk 1 van SfL (Winter, 2019) wordt de basis van R (base R) verder uitgelegd. Ter voorbereiding op het eerste practicum is het prettig om vast wat commando’s te proberen uit dit hoofdstuk. Maak hiervoor een nieuw script aan in RStudio (via het menu File &gt; New File &gt; R Script of de sneltoetsen Ctrl + Shift + N (Cmd + Shift + N op een Mac)).2 Werk om een gevoel te krijgen bij hoe R werkt, nu hoofdstuk 1 door t/m sectie 1.4. Typ de commando’s in de grijze vakken over en voer ze uit. In sectie 1.2 doe je dit direct in de R-console, vanaf sectie 1.3 (en in alle volgende practica!) in een script. Zie sectie 1.15 voor handige shortcuts die je hierbij kunt gebruiken. Controleer steeds of je dezelfde output krijgt als in het boek. Toegegeven, het letterlijk overtypen van de commando’s uit het boek voelt misschien een beetje raar, maar het is dé manier om gevoel te krijgen bij hoe R werkt en waar je op moet letten (zie ook sectie 1.16 voor belangrijke adviezen op dit gebied). In de practica krijg je nog tijd genoeg om het allemaal zelf uit te vinden.\n\n\n\n2 Je kunt eventueel ook https://rdrr.io/snippets gebruiken voor het uitvoeren van R-code, mocht de installatie op je eigen computer niet werken. We kunnen dan tijdens een practicum proberen R en RStudio werkend te krijgen op je computer."
  },
  {
    "objectID": "bewerken.html#de-pipe-operator",
    "href": "bewerken.html#de-pipe-operator",
    "title": "4  Data Bewerken",
    "section": "4.1 de pipe-operator",
    "text": "4.1 de pipe-operator\nIn het tidyverse zit een hele verzameling aan werkwoorden die je kunt gebruiken om bewerkingen op je data uit te voeren. Deze werkwoorden hebben gemeenschappelijk dat ze altijd een bewerking uitvoeren op een datatabel (tibble) en (meestal) weer een nieuwe datatabel opleveren. In het vorige hoofdstuk hebben we bijvoorbeeld distinct() gezien. Dit ‘werkwoord’ geeft van een variabele in een datatabel de unieke waarden terug.\n\ndistinct(.data = wordbank_datasets, language)\n\n# A tibble: 42 × 1\n   language             \n   &lt;fct&gt;                \n 1 British Sign Language\n 2 Cantonese            \n 3 Croatian             \n 4 Danish               \n 5 English (American)   \n 6 French (Quebecois)   \n 7 German               \n 8 Hebrew               \n 9 Italian              \n10 Mandarin (Beijing)   \n# ℹ 32 more rows\n\n\nDe datatabel waarop de bewerking wordt uitgevoerd (hier: wordbank_datasets) staat altijd als eerste argument van de functie genoemd. Om de code overzichtelijker te maken en om het mogelijk te maken om meerdere operaties na elkaar uit te voeren bestaat de pipe-operator %&gt;%. Deze operator maakt het mogelijk om de datatabel uit de functie-aanroep te halen en ervoor te zetten:\n\nwordbank_datasets %&gt;% distinct(language)\n\n# A tibble: 42 × 1\n   language             \n   &lt;fct&gt;                \n 1 British Sign Language\n 2 Cantonese            \n 3 Croatian             \n 4 Danish               \n 5 English (American)   \n 6 French (Quebecois)   \n 7 German               \n 8 Hebrew               \n 9 Italian              \n10 Mandarin (Beijing)   \n# ℹ 32 more rows\n\n\nDeze code doet hetzelfde als de eerdere variant waarbij we de datatabel nog op de eerste plek benoemden. Onderliggend is dit namelijk precies wat R voor je doet, wanneer je de pipe gebruikt:\n\n\n\nde pipe-operator\n\n\n\n\nx %&gt;% functie(y) wordt functie(.data = x, y)\n\n\n\nHet is even wennen maar de pipe operator %&gt;% is een ontzettend handige toevoeging aan je gereedschapskist. Met deze operator kun je namelijk heel makkelijk verschillende operaties aan elkaar plakken zonder dat je data tussendoor een nieuwe naam hoeft te geven. Je kunt de pipe lezen als ‘pak datatabel \\(x\\) en pas functie \\(f\\) erop toe’. Aangezien de output van de functies doorgaans een nieuwe datatabel oplevert kun je de output van een functie weer met een pipe doorzetten naar een volgende. Je kunt de pipe dan lezen als en doe dan dit. De pipe maakt het eenvoudiger om je code van links naar rechts te lezen in plaats van binnen naar buiten.\n\ndata %&gt;% functie1() %&gt;% functie2()\n\nWij schrijven de pipe als %&gt;%, omdat deze manier ook gehanteerd wordt in de overige literatuur die we gebruiken in deze cursus. De nieuwste versie van tidyverse schrijft de pipe als |&gt;. In ons geval zijn deze twee schrijfwijzen equivalent, maar wij gebruiken in het dictaat en uitwerkingen dus %&gt;%."
  },
  {
    "objectID": "bewerken.html#sec-observaties",
    "href": "bewerken.html#sec-observaties",
    "title": "4  Data Bewerken",
    "section": "4.2 Observaties uitlichten",
    "text": "4.2 Observaties uitlichten\n\n4.2.1 filter()\nHet komt vaak voor dat je maar een deel van de data wilt bekijken. De functie filter() kun je gebruiken om een selectie te maken van de observaties die je wilt gaan bekijken. In de datatabel wordbank_datasets komen bijvoorbeeld twee typen vragenlijsten voor (variabele: form_type): vragenlijsten van type WG wat staat voor Words & Gestures zijn afgenomen bij ouders van babies en vragenlijsten van type WS wat staat voor Words & Sentences zijn afgenomen bij ouders van peuters. Wanneer we onze analyse nu willen beperken tot alleen de vragenlijsten afgenomen bij babies kunnen we dit met filter() aangeven:\n\nwordbank_datasets %&gt;% \n  filter(form_type == \"WS\")\n\n# A tibble: 48 × 9\n   instrument_id language           form  form_type age_min age_max has_grammar\n   &lt;fct&gt;         &lt;fct&gt;              &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 2             Cantonese          WS    WS             16      30           0\n 2 4             Croatian           WS    WS             16      30           0\n 3 6             Danish             WS    WS             16      36           1\n 4 8             English (American) WS    WS             16      30           1\n 5 10            French (Quebecois) WS    WS             16      30           1\n 6 11            German             WS    WS             18      30           0\n 7 13            Hebrew             WS    WS             25      36           1\n 8 15            Italian            WS    WS             18      36           0\n 9 17            Mandarin (Beijing) TC    WS             17      30           0\n10 18            Mandarin (Beijing) WS    WS             16      30           0\n# ℹ 38 more rows\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\nDe conditie form_type == \"WS\" binnen filter() moeten we lezen als ‘behoud de observaties waarbij form_type gelijk is aan WS’. We zien dat 48 van de 89 vragenlijst in de oorspronkelijke dataset aan deze conditie voldoen. Wanneer we met alleen deze data willen verder werken dan zouden we ervoor kunnen kiezen om deze weg te schrijven naar een nieuwe datatabel (met de inmiddels bekende operator &lt;-).\n\nwordbank_WS &lt;- wordbank_datasets %&gt;% \n  filter(form_type == \"WS\")\n\nDe functie filter() werkt met condities waaraan voldaan moet worden. Afhankelijk van het type variabele kunnen die een andere vorm aannemen. Bij factoren zal het doorgaans gaan om het al dan niet gelijk zijn aan een bepaald level (==: gelijk aan, !=: is niet gelijk aan) waarbij de naam van het level tussen aanhalingstekens moet staan. Bij numerieke variabelen kan er ook gekeken worden of een getal groter (&gt;) of kleiner (&lt;) is dan een bepaalde waarde. Willen we bijvoorbeeld alleen kijken naar datasets waarin de babies maximaal 18 maanden oud zijn dan kunnen we de variabele age_max beperken:\n\nwordbank_datasets %&gt;% \n  filter(age_max &lt;= 18)\n\n# A tibble: 31 × 9\n   instrument_id language           form  form_type age_min age_max has_grammar\n   &lt;fct&gt;         &lt;fct&gt;              &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 3             Croatian           WG    WG              8      16           0\n 2 7             English (American) WG    WG              8      18           0\n 3 9             French (Quebecois) WG    WG              8      16           0\n 4 16            Mandarin (Beijing) IC    WG             12      16           0\n 5 21            Russian            WG    WG              8      18           0\n 6 23            Slovak             WG    WG              8      16           0\n 7 25            Spanish (Mexican)  WG    WG              8      18           0\n 8 27            Swedish            WG    WG              8      16           0\n 9 29            Turkish            WG    WG              8      16           0\n10 38            Kigiriama          WG    WG              8      15           0\n# ℹ 21 more rows\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\nDe condities in filter() moeten een waarheidswaarde (true, false) opleveren. De operatoren die hierbij gebruikt kunnen worden zie je in Tabel 4.1. Dit worden ook wel booleans genoemd.\n\n\n\n\n\n\n\n\n\n\noperator\nte lezen als\nvoorbeeld\n\n\n\n\n==\nis gelijk aan\nform_type == \"WS\"\n\n\n!=\nis niet gelijk aan\nform_type != \"WS\"\n\n\n%in%\nkomt voor in de vector\nlanguage %in% c(\"Dutch\", \"German\")\n\n\n&lt;\nkleiner dan\nage_max &lt; 19\n\n\n&lt;=\nkleiner dan of gelijk aan\nage_max &lt;= 18\n\n\n&gt;\ngroter dan\nage_min &gt; 3\n\n\n&gt;=\ngroter dan of gelijk aan\nage_min &gt;= 2\n\n\nbetween()\ntussen\nbetween(age_min, 2, 10)\n\n\nis.na()\nis een missing value\nis.na(form_type)\n\n\n!is.na()\nis geen missing value\n!is.na(form_type)\n\n\n!\nniet, keert de waarheidswaarde om\n!age_max &lt;= 18\n\n\n\nTabel 4.1: boolean operatoren in R\nHet is ook mogelijk om meerdere condities te combineren. Dat kan op dezelfde variabele of op meerdere variabelen. Hiervoor kun je de logische operatoren & ‘en (beide condities moeten waar zijn)’, | ‘of (een van beide of beiden condities moeten waar zijn)’ of xor() ‘exclusief of (een van beide maar niet beide condities moeten waar zijn)’. In plaats van & kun je de condities ook scheiden door een komma. Als we dus filteren op de WS-vragenlijsten van babies van maximaal 18 maanden, hebben we twee opties:\n\nwordbank_datasets %&gt;% \n  filter(form_type == \"WS\" & age_max &lt;= 18)\n\n# A tibble: 2 × 9\n  instrument_id language       form    form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;          &lt;fct&gt;   &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 85            Arabic (Saudi) WS      WS              8      16           1\n2 86            Arabic (Saudi) WSOther WS              8      16           1\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\nwordbank_datasets %&gt;% \n  filter(form_type == \"WS\",\n         age_max &lt;= 18)\n\n# A tibble: 2 × 9\n  instrument_id language       form    form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;          &lt;fct&gt;   &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 85            Arabic (Saudi) WS      WS              8      16           1\n2 86            Arabic (Saudi) WSOther WS              8      16           1\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\n\n\n4.2.2 slice()\nMet de verschillende slice-functies kun je bepaalde rijen zichtbaar maken op basis van hun positie in de datatabel of een minimale of maximale waarde op een variabele.\nWanneer we de eerste of laatste rijen zichtbaar willen maken gebruiken we slice_head() of slice_tail(). Het argument n geeft hierbij aan hoeveel rijen je zichtbaar wilt maken:\n\nwordbank_datasets %&gt;% \n  slice_head(n = 3)\n\n# A tibble: 3 × 9\n  instrument_id language             form  form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;                &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 1             British Sign Langua… WG    WG              8      36           0\n2 2             Cantonese            WS    WS             16      30           0\n3 3             Croatian             WG    WG              8      16           0\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\nwordbank_datasets %&gt;% \n  slice_tail(n = 2)\n\n# A tibble: 2 × 9\n  instrument_id language form  form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;    &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 93            Japanese WG    WG              8      18           1\n2 94            Japanese WS    WS             16      36           1\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\nDe functie slice() is een algemenere functie waarin je de nummers van de rijen in de datatabel als argument meegeeft:\n\nwordbank_datasets %&gt;% \n  slice(10:15)\n\n# A tibble: 6 × 9\n  instrument_id language           form  form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;              &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 10            French (Quebecois) WS    WS             16      30           1\n2 11            German             WS    WS             18      30           0\n3 12            Hebrew             WG    WG             11      25           0\n4 13            Hebrew             WS    WS             25      36           1\n5 14            Italian            WG    WG              7      24           0\n6 15            Italian            WS    WS             18      36           0\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\nMet slice_min() en slice_max() kun je de rijen selecteren met de minimale of maximale waarde op een variabele. Ook hier kun je met n aangeven hoeveel. Wanneer meerdere rijen hier dezelfde waarde hebben kun je meer rijen krijgen dan het gevraagde aantal\n\nwordbank_datasets %&gt;% \n  slice_max(age_max)\n\n# A tibble: 1 × 9\n  instrument_id language          form     form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;             &lt;fct&gt;    &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 32            English (British) TEDS Th… WS             34      47           1\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\nwordbank_datasets %&gt;% \n  slice_min(age_min,\n            n = 3)\n\n# A tibble: 41 × 9\n   instrument_id language            form  form_type age_min age_max has_grammar\n   &lt;fct&gt;         &lt;fct&gt;               &lt;fct&gt; &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 14            Italian             WG    WG              7      24           0\n 2 1             British Sign Langu… WG    WG              8      36           0\n 3 3             Croatian            WG    WG              8      16           0\n 4 5             Danish              WG    WG              8      20           0\n 5 7             English (American)  WG    WG              8      18           0\n 6 9             French (Quebecois)  WG    WG              8      16           0\n 7 19            Norwegian           WG    WG              8      20           0\n 8 21            Russian             WG    WG              8      18           0\n 9 23            Slovak              WG    WG              8      16           0\n10 25            Spanish (Mexican)   WG    WG              8      18           0\n# ℹ 31 more rows\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\nWil je random een aantal observaties uit je datatabel halen dan kun je slice_sample() gebruiken. Deze functie zal iedere keer een ander resultaat geven. Het is dan voor de reproduceerbaarheid verstandig om aan het begin van je script (of voordat je de functie aanroept) een random seed aan te maken met de functie set.seed(). Wanneer iemand anders deze functie met hetzelfde getal uitboert, zal die dezelfde resultaten krijgen. Dit geldt dus ook voor jezelf, wanneer je het script meerdere keren of op een later moment uitvoert.\n\nset.seed(25)\n\nwordbank_datasets %&gt;% \n  slice_sample(n = 3)\n\n# A tibble: 3 × 9\n  instrument_id language           form    form_type age_min age_max has_grammar\n  &lt;fct&gt;         &lt;fct&gt;              &lt;fct&gt;   &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n1 7             English (American) WG      WG              8      18           0\n2 24            Slovak             WS      WS             17      36           1\n3 65            Dutch              Swingl… WG              8      36           1\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;"
  },
  {
    "objectID": "bewerken.html#sec-selecteren",
    "href": "bewerken.html#sec-selecteren",
    "title": "4  Data Bewerken",
    "section": "4.3 Variabelen selecteren",
    "text": "4.3 Variabelen selecteren\nWe hebben nu steeds gekeken hoe je observaties (rijen) kunt uitlichten uit een dataset. Hetzelfde kunnen we ook doen met variabelen. De functie select() is hierbij de belangrijkste functie. Aan deze functie geven we de variabelen mee die we willen behouden in een vervolgstap. Stel we willen in onze dataset wordbank_datasets alleen verder met de variabelen instrument_id en language. We voegen dan deze variabelen gescheiden door een , toe aan de functie select():\n\nwordbank_datasets %&gt;% \n  select(instrument_id, language)\n\n# A tibble: 89 × 2\n   instrument_id language             \n   &lt;fct&gt;         &lt;fct&gt;                \n 1 1             British Sign Language\n 2 2             Cantonese            \n 3 3             Croatian             \n 4 4             Croatian             \n 5 5             Danish               \n 6 6             Danish               \n 7 7             English (American)   \n 8 8             English (American)   \n 9 9             French (Quebecois)   \n10 10            French (Quebecois)   \n# ℹ 79 more rows\n\n\nLet erop dat je in dit geval deze verandering alleen tijdelijk hebt gemaakt. Het is nu nog niet zo dat je de variabele definitief hebt verwijderd uit de datatabel. Om dat voor elkaar te krijgen zul je de actie toe moeten schrijven aan een naam met de operator &lt;-, zoals we al vaker hebben gezien.\nWanneer je meerdere opeenvolgende variabelen wilt toevoegen kun je gebruik maken van de operator :, die je moet lezen als ‘t/m’. Deze operator is te combineren met , als je daarnaast ook nog extra variabelen wilt toevoegen die verderop in de dataset voorkomen. Dit scheelt je typewerk.\n\nwordbank_datasets %&gt;% \n  select(instrument_id, language, form_type:has_grammar)\n\n# A tibble: 89 × 6\n   instrument_id language              form_type age_min age_max has_grammar\n   &lt;fct&gt;         &lt;fct&gt;                 &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 1             British Sign Language WG              8      36           0\n 2 2             Cantonese             WS             16      30           0\n 3 3             Croatian              WG              8      16           0\n 4 4             Croatian              WS             16      30           0\n 5 5             Danish                WG              8      20           0\n 6 6             Danish                WS             16      36           1\n 7 7             English (American)    WG              8      18           0\n 8 8             English (American)    WS             16      30           1\n 9 9             French (Quebecois)    WG              8      16           0\n10 10            French (Quebecois)    WS             16      30           1\n# ℹ 79 more rows\n\n\nSoms is het handiger om niet de variabelen die je wilt behouden, maar juist die variabelen die je niet wilt behouden te noemen. Hiervoor kun je de operator - gebruiken voor de naam van de variabele die je niet meer wilt gebruiken. Dus bijvoorbeeld om de variabele form uit te sluiten gebruiken we:\n\nwordbank_datasets %&gt;% \n  select(- form)\n\n# A tibble: 89 × 8\n   instrument_id language              form_type age_min age_max has_grammar\n   &lt;fct&gt;         &lt;fct&gt;                 &lt;fct&gt;       &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;\n 1 1             British Sign Language WG              8      36           0\n 2 2             Cantonese             WS             16      30           0\n 3 3             Croatian              WG              8      16           0\n 4 4             Croatian              WS             16      30           0\n 5 5             Danish                WG              8      20           0\n 6 6             Danish                WS             16      36           1\n 7 7             English (American)    WG              8      18           0\n 8 8             English (American)    WS             16      30           1\n 9 9             French (Quebecois)    WG              8      16           0\n10 10            French (Quebecois)    WS             16      30           1\n# ℹ 79 more rows\n# ℹ 2 more variables: unilemma_coverage &lt;dbl&gt;, age_range &lt;dbl&gt;\n\n\nDoor de pipe kunnen we select() combineren de eerder geïntroduceerde werkwoorden om de dataset tegelijkertijd ook in te perken op basis van observaties. Zo kunnen we select() combineren met filter(), bijvoorbeeld om een dataset te maken met de eerste drie variabelen met alleen vragenlijsten van type WS:\n\nwordbank_datasets %&gt;% \n  filter(form_type == \"WS\") %&gt;% \n  select(instrument_id, language)\n\n# A tibble: 48 × 2\n   instrument_id language          \n   &lt;fct&gt;         &lt;fct&gt;             \n 1 2             Cantonese         \n 2 4             Croatian          \n 3 6             Danish            \n 4 8             English (American)\n 5 10            French (Quebecois)\n 6 11            German            \n 7 13            Hebrew            \n 8 15            Italian           \n 9 17            Mandarin (Beijing)\n10 18            Mandarin (Beijing)\n# ℹ 38 more rows\n\n\nIn principe maakt het niet uit in welke volgorde we select() en filter() zetten. In sommige gevallen kan dit wel cruciaal zijn, zoals in dit voorbeeld. Als je wilt filteren op basis van een variabele (hier form_type), dan moet je natuurlijk niet eerst de dataset zo inperken dat die variabele niet meer aanwezig is, want dan krijg je een error. Denk dus altijd goed na welke gevolgen de volgorde van je functies kan hebben."
  },
  {
    "objectID": "bewerken.html#missing-values",
    "href": "bewerken.html#missing-values",
    "title": "4  Data Bewerken",
    "section": "4.4 Missing values",
    "text": "4.4 Missing values\n\n\n     instrument_id language form_type age_range\n[1,]         FALSE    FALSE     FALSE      TRUE\n[2,]         FALSE    FALSE     FALSE      TRUE\n[3,]         FALSE    FALSE     FALSE      TRUE\n\n\nOnze voorbeelddataset wordbank_datasets is een complete dataset. Voor elke observatie zijn er voor alle variabelen waarden aanwezig. Dit is lang niet altijd het geval. Vaak is het zo dat er datapunten ontbreken. Een waarde voor een bepaalde variabele kan niet beschikbaar zijn, bijvoorbeeld doordat deze niet te achterhalen was, niet is uitgevraagd of dat er iets mis is gegaan in de dataverwerking. Ontbrekende waarden noemen we ook wel missing values. Deze worden in R gemarkeerd als NA voor ‘not available’. Er is veel te vertellen over missing values. We beperken ons hier ertoe dat je je bewust moet zijn van het bestaan van missing values. Het is dus verstandig om bij elke dataset voor de relevante variabelen die je mee wilt nemen in je analyse na te gaan of er ontbrekende waarden aanwezig zijn en deze eventueel te verwijderen. op deze manier voorkom je vaak problemen die later kunnen ontstaan.\nTer illustratie hebben we een dataset wordbank_dataset_NA gemaakt waaraan observaties zijn toegevoegd met een missing value op de variabele age_range. We kunnen de functie is.na() gebruiken (zie Tabel 4.1) om deze observaties zichtbaar te maken:\n\nwordbank_dataset_NA %&gt;% \n  filter(is.na(age_range))\n\n# A tibble: 3 × 4\n  instrument_id language form_type age_range\n  &lt;fct&gt;         &lt;fct&gt;    &lt;fct&gt;         &lt;dbl&gt;\n1 999           Irish    WS               NA\n2 9999          Dutch    WS               NA\n3 99999         Croatian WG               NA\n\n\nWe zien inderdaad in de kolom age_range drie keer NA verschijnen. De ontkenning !is.na() kunnen we gebruiken in combinatie met filter() om deze observaties uit de dataset te verwijderen.\n\nwordbank_dataset_NA %&gt;% \n  filter(!is.na(age_range))\n\n# A tibble: 89 × 4\n   instrument_id language              form_type age_range\n   &lt;fct&gt;         &lt;fct&gt;                 &lt;fct&gt;         &lt;dbl&gt;\n 1 1             British Sign Language WG               28\n 2 2             Cantonese             WS               14\n 3 3             Croatian              WG                8\n 4 4             Croatian              WS               14\n 5 5             Danish                WG               12\n 6 6             Danish                WS               20\n 7 7             English (American)    WG               10\n 8 8             English (American)    WS               14\n 9 9             French (Quebecois)    WG                8\n10 10            French (Quebecois)    WS               14\n# ℹ 79 more rows\n\n\nZoals eerder gezien, kunnen we hier ook meerdere variabelenamen invoeren gescheiden door een ,. Een alternatieve functie is drop_na() die zoals de naam als zegt de observaties verwijderd die een ontbrekende waarde hebben op de variabele die als argument wordt meegegeven:\n\nwordbank_dataset_NA %&gt;% \n  drop_na(age_range)\n\n# A tibble: 89 × 4\n   instrument_id language              form_type age_range\n   &lt;fct&gt;         &lt;fct&gt;                 &lt;fct&gt;         &lt;dbl&gt;\n 1 1             British Sign Language WG               28\n 2 2             Cantonese             WS               14\n 3 3             Croatian              WG                8\n 4 4             Croatian              WS               14\n 5 5             Danish                WG               12\n 6 6             Danish                WS               20\n 7 7             English (American)    WG               10\n 8 8             English (American)    WS               14\n 9 9             French (Quebecois)    WG                8\n10 10            French (Quebecois)    WS               14\n# ℹ 79 more rows\n\n\nZoals altijd, om deze wijziging blijvend te maken moeten we de datatabel weer toeschrijven aan een naam met &lt;-."
  },
  {
    "objectID": "bewerken.html#sec-tellingen",
    "href": "bewerken.html#sec-tellingen",
    "title": "4  Data Bewerken",
    "section": "4.5 Simpele tellingen",
    "text": "4.5 Simpele tellingen\nWanneer je begint te werken met een dataset wil je allereerst een goed beeld krijgen van de data. Nadat je eventueel de naam en het type van een of meerdere variabelen hebt aangepast (zie Hoofdstuk 3), is het handig om tellingen te maken van relevante variabelen. Dit geeft je een idee van wat je kan verwachten en of er bijvoorbeeld dubbelingen in de data zitten. We kunnen hiervoor de functie count() gebruiken. We geven als argument de naam van de variabele mee waarin we geïnteresseerd zijn, in dit geval language. Deze functie geeft een tabel waarin het aantal voorkomens staat vermeld in de kolom n.\n\nwordbank_dataset_NA %&gt;% \n  count(language)\n\n# A tibble: 42 × 2\n   language                   n\n   &lt;fct&gt;                  &lt;int&gt;\n 1 American Sign Language     5\n 2 Arabic (Saudi)             3\n 3 British Sign Language      1\n 4 Cantonese                  1\n 5 Catalan                    2\n 6 Croatian                   3\n 7 Czech                      1\n 8 Danish                     2\n 9 Dutch                      8\n10 English (American)         4\n# ℹ 32 more rows\n\n\nWe kunnen de tellingen in n met arrange() ordenen van klein naar groot …\n\nwordbank_dataset_NA %&gt;% \n  count(language) %&gt;% \n  arrange(n)\n\n# A tibble: 42 × 2\n   language                  n\n   &lt;fct&gt;                 &lt;int&gt;\n 1 British Sign Language     1\n 2 Cantonese                 1\n 3 Czech                     1\n 4 English (Australian)      1\n 5 English (Irish)           1\n 6 Estonian                  1\n 7 German                    1\n 8 Greek (Cypriot)           1\n 9 Hungarian                 1\n10 Spanish (Argentinian)     1\n# ℹ 32 more rows\n\n\n… of met toevoeging van desc() van groot naar klein:\n\nwordbank_dataset_NA %&gt;% \n  count(language) %&gt;% \n  arrange(desc(n))\n\n# A tibble: 42 × 2\n   language                   n\n   &lt;fct&gt;                  &lt;int&gt;\n 1 Dutch                      8\n 2 American Sign Language     5\n 3 English (American)         4\n 4 English (British)          4\n 5 Finnish                    4\n 6 Arabic (Saudi)             3\n 7 Croatian                   3\n 8 Korean                     3\n 9 Mandarin (Beijing)         3\n10 Catalan                    2\n# ℹ 32 more rows\n\n\nDe functie count() is zelfs ook toe te passen op numerieke variabelen\n\nwordbank_dataset_NA %&gt;% \n  count(age_range) %&gt;% \n  arrange(desc(n))\n\n# A tibble: 16 × 2\n   age_range     n\n       &lt;dbl&gt; &lt;int&gt;\n 1        20    20\n 2         8    16\n 3        14    13\n 4        28     8\n 5        10     7\n 6         7     6\n 7        12     5\n 8        18     4\n 9        13     3\n10        NA     3\n11        19     2\n12         4     1\n13         9     1\n14        11     1\n15        15     1\n16        17     1\n\n\nWe zien in bovenstaande output dat missing values ook worden geteld. Zoals eerder gezegd, het is dus verstandig deze eerst te verwijderen:\n\nwordbank_dataset_NA %&gt;% \n  drop_na(age_range) %&gt;% \n  count(age_range) %&gt;% \n  arrange(desc(n))\n\n# A tibble: 15 × 2\n   age_range     n\n       &lt;dbl&gt; &lt;int&gt;\n 1        20    20\n 2         8    16\n 3        14    13\n 4        28     8\n 5        10     7\n 6         7     6\n 7        12     5\n 8        18     4\n 9        13     3\n10        19     2\n11         4     1\n12         9     1\n13        11     1\n14        15     1\n15        17     1\n\n\nSoms wil je al iets meer de diepte in met je analyse. Stel je wilt kijken naar voorkomens van een variabele binnen verschillende niveaus van een andere variabele. Je kunt dan gebruikmaken van group_by(). Wanneer we de variabele form_type meegeven als argument dan krijgen we tellingen die weergeven hoe vaak elke taal voorkomt per type vragenlijst (‘WG’ en ‘WS’):\n\nwordbank_dataset_NA %&gt;% \n  group_by(form_type) %&gt;% \n  count(language)\n\n# A tibble: 72 × 3\n# Groups:   form_type [2]\n   form_type language                   n\n   &lt;fct&gt;     &lt;fct&gt;                  &lt;int&gt;\n 1 WG        American Sign Language     2\n 2 WG        Arabic (Saudi)             1\n 3 WG        British Sign Language      1\n 4 WG        Catalan                    1\n 5 WG        Croatian                   2\n 6 WG        Danish                     1\n 7 WG        Dutch                      5\n 8 WG        English (American)         2\n 9 WG        English (British)          2\n10 WG        Finnish                    2\n# ℹ 62 more rows\n\n\nJe kunt bovenstaand resultaat ook krijgen door beide variabelen mee te geven aan group_by:\n\nwordbank_dataset_NA %&gt;% \n  group_by(form_type, language) %&gt;% \n  count()\n\n# A tibble: 72 × 3\n# Groups:   form_type, language [72]\n   form_type language                   n\n   &lt;fct&gt;     &lt;fct&gt;                  &lt;int&gt;\n 1 WG        American Sign Language     2\n 2 WG        Arabic (Saudi)             1\n 3 WG        British Sign Language      1\n 4 WG        Catalan                    1\n 5 WG        Croatian                   2\n 6 WG        Danish                     1\n 7 WG        Dutch                      5\n 8 WG        English (American)         2\n 9 WG        English (British)          2\n10 WG        Finnish                    2\n# ℹ 62 more rows\n\n\nWanneer je iets anders dan tellingen wilt in combinatie met group_by(), bijvoorbeeld een gemiddelde berekenen, dan moet je deze functie combineren met summarize() (of summarise()). Binnen summarize() geef je dan aan wat je wilt dat R voor je berekent. Als we bijvoorbeeld de gemiddelde age_range per type vragenlijst willen bepalen, kunnen we de volgende code gebruiken:\n\nwordbank_dataset_NA %&gt;% \n  drop_na(age_range) %&gt;% \n  group_by(form_type) %&gt;% \n  summarize(mean_age_range = mean(age_range))\n\n# A tibble: 2 × 2\n  form_type mean_age_range\n  &lt;fct&gt;              &lt;dbl&gt;\n1 WG                  11.8\n2 WS                  17.2\n\n\nWe gebruiken hiervoor de functie mean() om het gemiddelde te berekenen. Binnen summarize() geven we hierbij aan hoe we de variabele waarin het gemiddelde wordt opgeslagen willen noemen. Dit doen we voor het =-teken. Let op dat je wel eerst de missing values verwijdert, want anders geeft de functie mean() NAs als resultaat, aangezien er van een reeks getallen met een NA geen gemiddelde kan worden berekend.\n\nwordbank_dataset_NA %&gt;% \n  group_by(form_type) %&gt;% \n  summarize(mean_age_range = mean(age_range))\n\n# A tibble: 2 × 2\n  form_type mean_age_range\n  &lt;fct&gt;              &lt;dbl&gt;\n1 WG                    NA\n2 WS                    NA\n\n\nBij de functie mean() kun je overigens ook in de functie zelf aangeven dat je missing values niet mee wilt nemen in de berekening:\n\nwordbank_dataset_NA %&gt;% \n  group_by(form_type) %&gt;% \n  summarize(mean_age_range = mean(age_range, na.rm = TRUE))\n\n# A tibble: 2 × 2\n  form_type mean_age_range\n  &lt;fct&gt;              &lt;dbl&gt;\n1 WG                  11.8\n2 WS                  17.2\n\n\nDoor het argument na.rm de waarde TRUE (of afgekort T) te geven worden NAs niet meegenomen. Wanneer je binnen summarize() een telling wilt toevoegen dan maak je gebruik van n() i.p.v. count().\n\nwordbank_dataset_NA %&gt;% \n  group_by(form_type) %&gt;% \n  summarize(mean_age_range = mean(age_range, na.rm = TRUE),\n            n = n())\n\n# A tibble: 2 × 3\n  form_type mean_age_range     n\n  &lt;fct&gt;              &lt;dbl&gt; &lt;int&gt;\n1 WG                  11.8    42\n2 WS                  17.2    50\n\n\nIn Hoofdstuk 7 vind je meer voorbeelden van functies die je binnen summarize() kunt gebruiken."
  },
  {
    "objectID": "bewerken.html#verder-leren",
    "href": "bewerken.html#verder-leren",
    "title": "4  Data Bewerken",
    "section": "Verder leren",
    "text": "Verder leren\n\nIn hoofdstuk 2 (t/m 2.6) uit Winter (2019) worden de belangrijkste tidyverse-functies besproken met andere voorbeelden.\nIn hoofdstuk 3 van Wickham et al. (2023) vind je een uitgebreidere beschrijving van de functies die in dit hoofdstuk aan bod zijn gekomen.\nhet dplyr cheatsheet geeft een overzicht van de werking van de functies.\n\n\nWinter, B. (2019). Statistics for Linguists: An Introduction Using R. Routledge. https://doi.org/10.4324/9781315165547\n\nWickham, H., Çetinkaya-Rundel, M., & Grolemund, G. (2023). R for Data Science (2de dr.). O’Reilly. https://r4ds.hadley.nz/\nNu zou je in staat moeten zijn Practicum 2 te maken."
  },
  {
    "objectID": "practica.html#hoe-haal-je-het-meeste-uit-een-practicum",
    "href": "practica.html#hoe-haal-je-het-meeste-uit-een-practicum",
    "title": "Practica",
    "section": "Hoe haal je het meeste uit een practicum?",
    "text": "Hoe haal je het meeste uit een practicum?\nTijdens de practica lopen de docent en studentassistent rond om vragen te beantwoorden. Je haalt dus het meeste uit een practicum door vragen te stellen. Hiervoor moet je natuurlijk wel vragen hebben. Een goede voorbereiding is hierbij de sleutel. We zien maar al te vaak dat studenten onvoorbereid op het practicum komen en ter plekke de documenten openen. Het resultaat is dat ze aan het eind van het practicum nog met de eerste opdrachten bezig zijn en niet aan de latere opdrachten toekomen, die vaak moeilijker zijn. Die opdrachten moet je dan zonder hulp maken. Verstandiger is het dus om goed voorbereid op het practicum te komen. Hoe bereid je je goed voor?\n\nBestudeer de opgegeven hoofdstukken ter voorbereiding op het practicum. Zie hiervoor ook het overzicht in Tabel 1;\nMaak voor jezelf een overzicht van de functies die in de hoofdstukken worden besproken. Voeg deze toe aan je eigen codeboek;\nLees de practicumopdrachten door en bedenk welke functies je bij iedere opdracht zou kunnen gebruiken. Noteer deze bij de opdracht of in een apart document;\nMaak een scriptbestand aan voor het practicum (zie hieronder) en werk al wat code uit. Kijk tegen welke problemen je aanloopt en stel hier vragen over op het practicum.\n\n\n\n\n\n\n\n\n\n\n\nPracticum\nOnderwerp\nVoorbereiding\n\n\n\n\n1\nWerken met data in R\nhoofdstukken 1, 2 en 3\n\n\n2\nBewerken van data\nHoofdstuk 4\n\n\n3\nGrafieken maken met ggplot\nHoofdstuk 5\n\n\n\nTabel 1: voorbereiding per practicum"
  },
  {
    "objectID": "practica.html#wat-heb-je-nodig",
    "href": "practica.html#wat-heb-je-nodig",
    "title": "Practica",
    "section": "Wat heb je nodig?",
    "text": "Wat heb je nodig?\nJe werkt binnen RStudio. Zorg dat dit programma samen met R geïnstalleerd is op je computer (zie sectie 2.1). We werken voor alle practica in hetzelfde R-project OBS_practica.Rproj. Download hiervoor het bestand OBS_practica.zip van Brightspace en pak dat uit op je eigen computer. Zet deze map op een handige locatie op je computer (bijv. in de map voor de cursus OBS). Je vindt in de map de volgende bestanden:\n\nOBS_practica.Rproj: hierin staat informatie voor RStudio over wat er allemaal bij de practica hoort.\neen map datasets: hierin vind je de databestanden die bij de practica in deze cursus gebruikt worden (uitgezonderd die voor de opdrachten). Zie het bestand ReadMe.txt voor meer informatie.\neen map templates_scripts_quarto: hierin vind je drie templates die je kunt gebruiken bij het uitwerken van je code voor een practicum. Zie het bestand ReadMe.txt voor meer informatie.\nvoornaam_achternaam_script_Practicum1.R: voor Practicum 1 hebben we al een script aangemaakt waarin je de practicumopdracht kunt maken. Dit is het document waarin je verschillende commando’s kunt uitwerken en vervolgens laten uitvoeren door R. Voor de volgende practica moet je dit zelf doen door een van de templates te kopiëren uit de map templates_scripts_quarto. Verander voor je begint de naam van het bestand door je eigen voor- en achternaam en het cijfer van het betreffende practicum in te vullen (dus bijv. peter_deswart_script_Practicum1.R)."
  },
  {
    "objectID": "practica.html#aan-de-slag",
    "href": "practica.html#aan-de-slag",
    "title": "Practica",
    "section": "Aan de slag",
    "text": "Aan de slag\nJe begint elk practicum door het bestand OBS_practica.Rproj te openen (en dus niet het programma RStudio). Wen jezelf dit aan. Op deze manier heb je namelijk meteen toegang tot alle relevante bestanden. Het scheelt je een hoop foutmeldingen (en daarvan komen er nog genoeg). Om aan de slag te gaan, open je dus de aangemaakte folder voor de cursus (bijv. OBS) en dubbelklik je op OBS_practica.Rproj. RStudio opent dan en je kunt gaan werken aan de practicumopdrachten. Klik in het window rechtsonder (met de tab Files open) op voornaam_achternaam_script_Practicum1.R (dat je als het goed is al hebt aangepast naar je eigen naam). Let op: zorg dat je voor ieder practicum een nieuw script aanmaakt op basis van het templaat waarin je je eigen naam en het cijfer van het practicum aanpast. Wanneer je het script opent vanuit RStudio, zal het zichtbaar worden in een window linksboven in RStudio. In het script kun je je code gaan schrijven (denk aan de richtlijnen uit Sectie 3.3). De code kun je uitvoeren door met de cursor op de betreffende regel te gaan staan of een deel ervan te selecteren en vervolgens op ‘Run’ te klikken. Je kunt hier ook de toetscombinatie Ctrl + Enter (Cmd + enter op Mac) voor gebruiken (zie ook sectie 1.15 in het boek van Winter (2019) voor andere handige shortcuts die je kunt gebruiken). Het resultaat van de actie wordt dan zichtbaar in de R-console (linksonder in RStudio). Je kunt ook commentaar toevoegen in je script: alles op een regel na een \\# wordt niet door R uitgevoerd.\n\nWinter, B. (2019). Statistics for Linguists: An Introduction Using R. Routledge. https://doi.org/10.4324/9781315165547\nRStudio weet dat je met een R-script bezig bent en zal soms\n\nsuggesties geven voor te gebruiken functies;\ndingen die het herkent een kleurtje geven;\nspontaan dingen aanvullen, zoals haakjes;\nin de kantlijn een markering zetten als er iets niet lijkt te kloppen.\n\n\n\n\n\n\n\nLet op\n\n\n\nSla je script regelmatig op, zodat je geen code kwijtraakt. Klik hiervoor op het floppy-disk-symbool of gebruik de sneltoetsen Ctrl + S/cmd + S."
  }
]